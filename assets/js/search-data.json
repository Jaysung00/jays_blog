{
  
    
        "post0": {
            "title": "파이썬 예제3 AxB",
            "content": ". 문제 두 정수 A와 B를 입력받은 다음, A×B를 출력하는 프로그램을 작성하시오. . 입력 첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10) . 출력 첫째 줄에 A×B를 출력한다. . 예제 입력 1 . 1 2 . 예제 출력 1 . 2 . 예제 입력 2 . 3 4 . 예제 출력 2 . 12 . a, b = map(int, input().split()) # 3 4 print(a*b) . 12 .",
            "url": "https://jaysung00.github.io/jays_blog/boj%20problem/2021/10/16/BOJ10998_AxB.html",
            "relUrl": "/boj%20problem/2021/10/16/BOJ10998_AxB.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "파이썬 예제2 A+B",
            "content": ". 문제 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. . 입력 첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10) . 출력 첫째 줄에 A+B를 출력한다. . 예제 입력 1 1 2 예제 출력 1 3 . # 첫번째 시도 a = input() # 1 b = input() # 2 print(a + b) # int 형으로 인식되지 않는다 . 12 . type(a) . str . # 개선1 a = int(input()) b = int(input()) print(a + b) # int형으로 인식되나, 한줄에 입력받지 못함 . ValueError Traceback (most recent call last) &lt;ipython-input-11-625471334fa1&gt; in &lt;module&gt; 1 # 개선1 -&gt; 2 a = int(input()) 3 b = int(input()) 4 5 print(a + b) # int형으로 인식되나, 한줄에 입력받지 못함 ValueError: invalid literal for int() with base 10: &#39;1 2&#39; . # 개선2 a, b = input().split() print(int(a) + int(b)) . 3 . split&#51012; &#51060;&#50857;&#54644;&#49436; &#54620; &#51460;&#47196; &#51077;&#47141;&#48155;&#45716; &#44163;&#51060; &#44032;&#45733;&#54664;&#45796;. . 한 번에 값을 여러 개 입력받으려면 input에서 split을 사용한 변수 여러 개에 저장해주면 된다. . 변수1, 변수2 = input().split() | 변수1, 변수2 = input().split(&#39;기준문자열&#39;) | 변수1, 변수2 = input(&#39;문자열&#39;).split() | 변수1, 변수2 = input(&#39;문자열&#39;).split(&#39;기준문자열&#39;) | . # 개선3 a, b = map(int, input().split()) print(a + b) . 3 . map&#51012; &#51060;&#50857;&#54644;&#49436; &#45908;&#50865; &#44036;&#45800;&#54616;&#44172; . map에 int와 input().split()을 넣으면 split의 결과를 모두 int로 변환해줌 . 변수1, 변수2 = map(int, input().split()) | 변수1, 변수2 = map(int, input().split(&#39;기준문자열&#39;)) | 변수1, 변수2 = map(int, input(&#39;문자열&#39;).split()) | 변수1, 변수2 = map(int, input(&#39;문자열&#39;).split(&#39;기준문자열&#39;)) | .",
            "url": "https://jaysung00.github.io/jays_blog/boj%20problem/2021/10/16/BOJ1000_A+B.html",
            "relUrl": "/boj%20problem/2021/10/16/BOJ1000_A+B.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Bayesian Networkとは何か？ ①",
            "content": ". &#12505;&#12452;&#12472;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#65288;BN; Bayesian Network&#65289;&#12392;&#12399;? . 確率変数（RV;Random variables）間の条件付き独立などの関係を見せることにより、RVのfull joint distributionなどを簡潔に表現できるグラフ表記法（Graphical Notation）である。 | . . &#29992;&#35486;&#12398;&#35500;&#26126; . ここで グラフ（Graph） とは、数学においてチャート（Chart）と対照されて定義された nodeとedgeの集合 . | edgeの方向が指定されていればdirected、そうでなければundirected . | グラフの全てのedgeがdirectedの時、directed graph . | directed edgeにおいて、始まる側のノードをparent nodeとし、反対側はchild nodeと言う。 . | つながっている複数のdirected edgeの方向が同じ場合、これをdirected pathとし、directed pathの最初のノードは経路上のすべてのノードのancestor nodeであり、逆に残りのノードは最初のノードのdescendant nodeである。 . | directed pathの開始点と終了点が一致する場合はこれをcyclic、そうでない場合はacyclicと呼ぶ。 . | . . &#12505;&#12540;&#12472;&#12517;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#65288;BN&#65289; &#12398;&#26465;&#20214; . NetworkはNodeと彼らを繋ぐEdgeで構成されている。 . | 方向性の非循環グラフ（DAG; Directed Acyclic Graph）である。 . | 個別のNodeはRVである$X$に対して$ bf P(X | Paranets(X))$を意味する。 . | 個別のEdgeとは親が子供に与える直接的な影響（Direct Influence） を意味する。 . | . . . &#12414;&#12378;&#30906;&#29575;&#12395;&#38306;&#12377;&#12427;&#31777;&#21336;&#12394;&#24489;&#32722;&#12363;&#12425; . ベージュアンネットワークというものは結局確率変数（RV）間の関係を表現したものである。 | 確率というのは相対的な頻度である。 | . . 独立性 （Independence） . $P(A|B) = P(A)$ $ Leftrightarrow P(A,B) = P(A)P(B)$ $ Leftrightarrow P(B|A) = P(B) $; A とB が独立ならば、B はA と独立である。 . 事象Bが発生したという情報は、事象Aが発生する確率に追加的な情報を提供しない。 . | これは、下述のConditional Independence と対立する意味で Marginal Independence と言える。 . | . | . . 条件付き独立（Conditional Independence） . $P(A|B,C) = P(A|C)$ . 事象Cが与えられたときに二つの事象AとBが独立なら、これはCという条件の下で条件付き独立 である。 | . | . . 条件付き確率（Conditional Probability） . $P(A= true|B=true)$ . &quot;Probablity of A given B&quot; . | Bが与えられた時、Aの確率 . | . | . 結合確率（joint Probability） . $P(A= true, B=true)$ . &quot;the probability of A=true and B=true&quot; . | A=trueとB=trueが同時に満足できる確率 . | 条件付き確率と結合確率の関係は一般に、$P(X|Y) = cfrac{P(X,Y)}{P(Y)}$ . | . | . 総確率法則（Law of Total Probability） . &quot;Summing out&quot; or &quot;Marginalization&quot; . | $P(A) = sum_kP(A,B_k) = sum_kP(A|B_k)P(B_k)$ . $P(A) = sum_kP(A,B_k)$は$B_1,B_2,...,B_n$がそれぞれ相互背反的な集合であり、これらの和集合が全体集合となるので成立（marginalize） . | $ sum_kP(A,B_k) = sum_kP(A|B_k)P(B_k)$は条件付き確率と結合確率の関係を利用すると誘導可能 . | . | これによる利点は、$P(A)$を直接求めるより、$P(A|B_k)$のような条件付き確率を求めて合わせることが一般的により容易であることである。 . | あるいは結合確率を知っている時、様々な確率が計算できる。 . 例えば、結合確率である$P(a,b,c,d)$を知っているとき、$P(c|b)$は以下のように表せる。 . | $P(c|b) = sum_a sum_d P(a,c,d|b) = cfrac{1}{P(b)} sum_a sum_d { bf P(a,b,c,d)}$ . | しかし、jointの場合にはparameterの数がexponentialに増えることになる！ （Chain Ruleの必要性） . | . | . . 確率の連鎖法則（Chain Rule for probability） . 全てのjoint distribution について、結合確率と条件付き確率の関係により常に以下のように表せる。 . | $P(a,b,c,...,z) = P(a|b,c,...,z)P(b,c,....,z)$ . | これを繰り返すと、$P(a,b,c,...,z) = P(a|b,c,...,z)P(b|c,...,z)P(c|d,...,z)...P(z)$で表現可能（Factorization） . | . . 乗分解法則（Rule of product decomposition） . Bayesian Networkでは、グラフに属するRVの結合分布（joint distribution）は、familyのすべての条件付き分布$P(Child|Parent)$の乗$^{[*1]}$で表現できる。 （次のポストのFactorization of Bayes Networkの内容を参照されたい） . | $P(x_1,x_2,...,x_n) = prod _iP(x_i|Parents(x_i))$ （Parentsは直接的に接続されて影響を受ける変数だけを意味） . 例えば、$X rightarrow Y rightarrow Z$ のグラフで$P(X=x,Y=y,Z=z)$を求めることを考えてみよう . | 本来は可能なすべての組み合わせの$(x, y, z)$に該当する確率テーブルを作らなければならない . | しかし、この法則を利用すると$P(X=x,Y=y,Z=z) = P(X=x)P(Y=y|X=x)P(Z=z|Y=y)$で簡潔に表現可能 . | このように高次元を低次元にすることで次元の呪い（curse of dimensionality）からも比較的自由になることができる。 . | . | . . $^{[*1]}:$ このように表現可能な理由は、後述するベイジアンネットワークのTypical Local Structures Rules に関連している。 . . &#12505;&#12452;&#12472;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;Rules of Typical Local Structures . . Rule 1. 鎖または滝型（Chain or Cascading） . . 変数$X$と変数$Y$の間で一つの方向性経路だけがあって変数$Z$が当該経路を塞いでいるとき、$Z$が条件付きで与えられると、二つの変数$X$と$Y$は条件付き独立 である。 . | $X perp Y|Z$ $ Leftrightarrow P(Y|X,Z) = P(Y|Z)$ . | . . Rule 2. 分岐あるいは共通の親型（Fork or Common parent） . . 変数$Z$が$X$と$Y$の共通原因で、$X$と$Y$の間にたった一つの経路があるとき、$Z$の条件が与えられると、$X$と$Y$は条件付き独立 である。 . | $X perp Y|Z$ $ Leftrightarrow P(X,Y|Z) = P(X|Z)P(Y|Z)$ . | . . Rule 3.衝突部あるいはV-構造(Collider or V-structure) . . 変数$Z$が二つの変数$X$と$Y$の間の衝突ノードで、$X$と$Y$の間でたった一つの経路だけあるとき、$X$と$Y$は非条件付き独立（underconditionally independent） である。しかし、$Z$または$Z$のdescendantを条件付きにした場合、$X$と$Y$は従属となる可能性 がある。 . | $ sim (X perp Y|Z)$ $ Leftrightarrow P(X,Y,Z)=P(X)P(Y)P(Z|X,Y)$ . | つまり$Z$が not given の時は独立だが、逆に$Z$がgivenで与えられれば$X$、$Y$が従属となる可能性が生じてしまう。 . | . . . Bayes Ball Algorithm . 目的：$X perp Y | Z$（$Z$がgivenの場合、$X$と$Y$が独立）が成立するかどうかを判定するためのアルゴリズム . | $X$からボールが出発すると仮定した時、 $Y$までボールが到達するかを確認する方法 . | ここでボールはInformationを意味し、矢印はボールの動きを意味する。ノード間が直接的なedgeで結ばれていなくても、ボールが転がって到達できるならIndirect influenceが存在するため、2つの変数はdepedentであることを意味する。 . | . . Rule 1の場合 . (1) $Z$がgivenでない時、ボールは通ることができる。 ($X, Y$は従属) . . (2) $Z$が given の時、ボールは通れない。 ($X perp Y|Z$) . . . Rule 2の場合 . (1) $Z$がgivenでない時、ボールは通ることができる。 ($X, Y$は従属) . . (2) $Z$が given の時、ボールは通れない。 ($X perp Y|Z$) . . . Rule 3の場合 . (1) $Z$が givenでない時、ボールは通れない。 ($ bf X perp Y$) . . (2) $X_C$がgivenであるとき、逆にpathができてボールが通ることができるようになる。 ($X, Y$は従属 $|Z$) . . . . Bayes Ball Algorithm&#12398;&#20363;&#38988; . . 問題 1. $X_1 perp X_4|X_2$ . 二つの経路でボールを転がすことができる。 . (1) $X_1 rightarrow{ bf X_2} (given) rightarrow X_4$の経路は$X_2$が鎖のgivenで塞がれているので通ることができない。 . (2) $X_1 rightarrow X_3 rightarrow X_5 rightarrow X_6 leftarrow{ bf X_2}(given) rightarrow X_4$の経路は$X_6$が衝突部のnot givenで塞がれているので通ることができない。 . 従って、いかなる経路でもボールは通れないので$X_2$がgivenのとき$X_1$と$X_4$は独立 である。 . | . . 問題 2. $X_2 perp X_5|X_1$ | . 二つの経路でボールを転がすことができる。 . (1) $X_2 rightarrow X_6 leftarrow X_5$ の経路は$X_6$が衝突部のnot givenで塞がれているので通れない。 . (2) $X_2 leftarrow{ bf X_1}(given) rightarrow X_3 rightarrow X_5$の経路は$X_1$が分岐のdivenで塞がれているので通れない。 . 従って、どんな経路でもボールは通れないので$X_1$がgivenのとき$X_2$と$X_5$は独立 である。 . . 問題 3. $X_1 perp X_6| {X_2, X_3 } $ | . 二つの経路でボールを転がすことができる。 . (1) $X_1 rightarrow{ bf X_2}(given) rightarrow X_6$の経路は$X_2$が鎖のgivenで塞がれているので通ることができない。 . (2) $X_1 rightarrow{ bf X_3}(given) rightarrow X_5 rightarrow X_6$の経路は$X_3$が鎖のgivenで塞がれているので通れない。 . 従って、いかなる経路でもボールは通れないので、$ {X_2, X_3 }$がgivenのとき$X_1$と$X_6$は独立 である。 . . 問題 4. $X_2 perp X_3| {X_1, X_6 } $ | . 二つの経路でボールを転がすことができる。 . (1) $X_2 leftarrow{ bf X_1}(given) rightarrow X_3$ の経路は$X_1$が分岐のgivenで塞がれているので通れない。 . (2) $X_2 rightarrow{ bf X_6}(given) leftarrow X_5 leftarrow X_3$の経路は$X_6$が衝突部のgivenで開いているので通ることができる。 . 従って、二番目のパスでボールは通過できるので、$ {X_1, X_6 }$がgivenのとき$X_2$と$X_3$は独立が成立しない。 . . . $d$-Seperation&#12398;&#23450;&#32681; . $d$は方向性（directly）を意味する。 . | Bayesian Ball Algorithmで$d$-Seperationかどうかを確認することができる。 . | 整理すると、パスpが条件付き集合 $ {W }$により$d$-Seperateされるという命題は以下と必要十分条件である。 . 1.経路pは条件付き集合 $ {W }$に属する中間ノード$Z$の鎖$X rightarrow Z rightarrow Y$または分岐$X leftarrow Z rightarrow Y$を含む。 . 2.経路pは条件付き集合 $ {W }$に属さない中間ノード$Z&#39;$の衝突部$X rightarrow Z&#39; leftarrow Y$を含む。 . | . . . Additional reference . [1] Judea Pearl, Madelyn Glymour, Nicholas P. Jewell (2016). Causal Inference in Statistics: A Primer . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/bayesian_network/2021/02/08/Bayesian-Network-1.html",
            "relUrl": "/bayesian_network/2021/02/08/Bayesian-Network-1.html",
            "date": " • Feb 8, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Market Basket Analysis in Python ①",
            "content": ". &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12392;&#12399;&#65311; . バスケット分析によって以下のようなことができる。 . 1. &#20341;&#22770;&#20998;&#26512; . 一回の買い物でよく一緒に買われるものは何か？ . 2. &#20341;&#22770;&#20998;&#26512;&#12395;&#22522;&#12389;&#12356;&#12390;&#26377;&#29992;&#12394;&#25512;&#22888;&#20107;&#38917;&#12398;&#25552;&#20379; . e.g. ・棚の近くに置くべき商品カテゴリー ・棚の遠くに置くべき商品カテゴリー など . . &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12398;&#20351;&#29992;&#20363; . e.g. ・Netflixスタイルの推奨エンジン ・eコマースにおける商品推奨の改善 ・小売店でのクロスセル（Cross-sell$^{[*1]}$）製品 ・在庫管理の改善 ・アップセル（Up-sell$^{[*2]}$）するアイテム選択　など . . $^{[*1]}$ Cross-sell : 顧客が購買する、あるいはすでに利用している製品・サービスに関連するものを販売していくこと $^{[*2]}$ Up-sell : 顧客が検討しているものよりランクの高い製品・サービスの販売をすること&lt;/p&gt; &lt;/span&gt; . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; . &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12398;&#26041;&#27861; . Association Rule によって構成される . ・{A} $ rightarrow$ {B} . 「Aを買うと、Bを買う」という意味 . . (&#23455;&#35013;) &#12463;&#12525;&#12523;&#12475;&#12523;&#35069;&#21697;&#36984;&#25246; . 小売店ではガムをコーヒーかシリアルかパンかどれかとクロスセルしようとしている。 . ・{coffee} $ rightarrow$ {gum} ・{cereal} $ rightarrow$ {gum} ・{bread} $ rightarrow$ {gum} のうち、最も関係性が強いものを選びたい。 . . transactionsは [&#39;coffee&#39;,&#39;gum&#39;] &amp; [&#39;cereal&#39;,&#39;gum&#39;] &amp; [&#39;bread&#39;,&#39;gum&#39;] の３つのペアからなっている。 . # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np transactions = pd.read_csv(&#39;./dataset/transactions.csv&#39;, header=None) transactions . 0 1 . 0 bread | gum | . 1 bread | gum | . 2 cereal | gum | . 3 coffee | gum | . 4 bread | gum | . ... ... | ... | . 80 bread | gum | . 81 coffee | gum | . 82 bread | gum | . 83 coffee | gum | . 84 coffee | gum | . 85 rows × 2 columns . 各ペアの数をカウントする . # Count the number of transactions with coffee and gum coffee = transactions[(transactions[0] == &#39;coffee&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Count the number of transactions with cereal and gum cereal = transactions[(transactions[0] == &#39;cereal&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Count the number of transactions with bread and gum bread = transactions[(transactions[0] == &#39;bread&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Print the counts for each transaction. print(&#39;coffee:&#39;, len(coffee)) print(&#39;cereal:&#39;, len(cereal)) print(&#39;bread:&#39;, len(bread)) . coffee: 40 cereal: 25 bread: 20 . . Association Rules&#12398;&#20840;&#12390;&#12398;&#20505;&#35036;&#12434;&#30906;&#35469;&#12377;&#12427; . &#12487;&#12540;&#12479;&#12398;&#28310;&#20633; . 小売店の併売データを読み込む . # Load transactions from pandas groceries = pd.read_csv(&#39;./dataset/small_grocery_store.csv&#39;) # Split transaction strings into lists transactions = groceries[&#39;Transaction&#39;].apply(lambda t: t.split(&#39;,&#39;)) # Convert DataFrame column into list of strings transactions = list(transactions) # Print the list of transactions print(transactions) . [[&#39;milk&#39;, &#39;bread&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;milk&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;tea&#39;], [&#39;jam&#39;, &#39;bread&#39;, &#39;milk&#39;], [&#39;tea&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;tea&#39;], [&#39;tea&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;tea&#39;, &#39;biscuit&#39;], [&#39;jam&#39;, &#39;bread&#39;, &#39;tea&#39;], [&#39;bread&#39;, &#39;milk&#39;], [&#39;coffee&#39;, &#39;orange&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;coffee&#39;, &#39;orange&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;coffee&#39;, &#39;sugar&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;orange&#39;], [&#39;bread&#39;, &#39;sugar&#39;, &#39;biscuit&#39;], [&#39;coffee&#39;, &#39;sugar&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;sugar&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;sugar&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;sugar&#39;], [&#39;tea&#39;, &#39;milk&#39;, &#39;coffee&#39;, &#39;cereal&#39;]] . Association rules&#12398;&#29983;&#25104; . ９つの食料品のリストを抽出し、すべての可能な単独原因単独結果の組み合わせ（Association rules）をitertoolsを使って生成する . # Import permutations from the itertools module from itertools import permutations # Define the set of groceries flattened = [i for t in transactions for i in t] groceries = list(set(flattened)) # Generate all possible rules rules = list(permutations(groceries, 2)) # Print the set of rules print(rules) # Print the number of rules print(&#39; n&#39;) print(len(rules),&quot;通り&quot;) . [(&#39;jam&#39;, &#39;cereal&#39;), (&#39;jam&#39;, &#39;sugar&#39;), (&#39;jam&#39;, &#39;tea&#39;), (&#39;jam&#39;, &#39;orange&#39;), (&#39;jam&#39;, &#39;bread&#39;), (&#39;jam&#39;, &#39;milk&#39;), (&#39;jam&#39;, &#39;coffee&#39;), (&#39;jam&#39;, &#39;biscuit&#39;), (&#39;cereal&#39;, &#39;jam&#39;), (&#39;cereal&#39;, &#39;sugar&#39;), (&#39;cereal&#39;, &#39;tea&#39;), (&#39;cereal&#39;, &#39;orange&#39;), (&#39;cereal&#39;, &#39;bread&#39;), (&#39;cereal&#39;, &#39;milk&#39;), (&#39;cereal&#39;, &#39;coffee&#39;), (&#39;cereal&#39;, &#39;biscuit&#39;), (&#39;sugar&#39;, &#39;jam&#39;), (&#39;sugar&#39;, &#39;cereal&#39;), (&#39;sugar&#39;, &#39;tea&#39;), (&#39;sugar&#39;, &#39;orange&#39;), (&#39;sugar&#39;, &#39;bread&#39;), (&#39;sugar&#39;, &#39;milk&#39;), (&#39;sugar&#39;, &#39;coffee&#39;), (&#39;sugar&#39;, &#39;biscuit&#39;), (&#39;tea&#39;, &#39;jam&#39;), (&#39;tea&#39;, &#39;cereal&#39;), (&#39;tea&#39;, &#39;sugar&#39;), (&#39;tea&#39;, &#39;orange&#39;), (&#39;tea&#39;, &#39;bread&#39;), (&#39;tea&#39;, &#39;milk&#39;), (&#39;tea&#39;, &#39;coffee&#39;), (&#39;tea&#39;, &#39;biscuit&#39;), (&#39;orange&#39;, &#39;jam&#39;), (&#39;orange&#39;, &#39;cereal&#39;), (&#39;orange&#39;, &#39;sugar&#39;), (&#39;orange&#39;, &#39;tea&#39;), (&#39;orange&#39;, &#39;bread&#39;), (&#39;orange&#39;, &#39;milk&#39;), (&#39;orange&#39;, &#39;coffee&#39;), (&#39;orange&#39;, &#39;biscuit&#39;), (&#39;bread&#39;, &#39;jam&#39;), (&#39;bread&#39;, &#39;cereal&#39;), (&#39;bread&#39;, &#39;sugar&#39;), (&#39;bread&#39;, &#39;tea&#39;), (&#39;bread&#39;, &#39;orange&#39;), (&#39;bread&#39;, &#39;milk&#39;), (&#39;bread&#39;, &#39;coffee&#39;), (&#39;bread&#39;, &#39;biscuit&#39;), (&#39;milk&#39;, &#39;jam&#39;), (&#39;milk&#39;, &#39;cereal&#39;), (&#39;milk&#39;, &#39;sugar&#39;), (&#39;milk&#39;, &#39;tea&#39;), (&#39;milk&#39;, &#39;orange&#39;), (&#39;milk&#39;, &#39;bread&#39;), (&#39;milk&#39;, &#39;coffee&#39;), (&#39;milk&#39;, &#39;biscuit&#39;), (&#39;coffee&#39;, &#39;jam&#39;), (&#39;coffee&#39;, &#39;cereal&#39;), (&#39;coffee&#39;, &#39;sugar&#39;), (&#39;coffee&#39;, &#39;tea&#39;), (&#39;coffee&#39;, &#39;orange&#39;), (&#39;coffee&#39;, &#39;bread&#39;), (&#39;coffee&#39;, &#39;milk&#39;), (&#39;coffee&#39;, &#39;biscuit&#39;), (&#39;biscuit&#39;, &#39;jam&#39;), (&#39;biscuit&#39;, &#39;cereal&#39;), (&#39;biscuit&#39;, &#39;sugar&#39;), (&#39;biscuit&#39;, &#39;tea&#39;), (&#39;biscuit&#39;, &#39;orange&#39;), (&#39;biscuit&#39;, &#39;bread&#39;), (&#39;biscuit&#39;, &#39;milk&#39;), (&#39;biscuit&#39;, &#39;coffee&#39;)] 72 通り . . Metric &amp; Pruning . 全ての可能な組み合わせを候補として置くのは、かなり時間とコストがかかる。 そのため、有用な規則だけに絞りたい。 → Metric &amp; Pruning Process . ①Metric : Association rulesにスコアを割り当て . ②Pruning : 特定の基準に従い、基準に満たさないRulesを放棄する . One-hot encoding transaction data . # Import the transaction encoder function from mlxtend from mlxtend.preprocessing import TransactionEncoder # Instantiate transaction encoder and identify unique items encoder = TransactionEncoder().fit(transactions) # One-hot encode transactions onehot = encoder.transform(transactions) # Convert one-hot encoded data to DataFrame onehot = pd.DataFrame(onehot, columns = encoder.columns_) # Print the one-hot encoded transaction dataset print(onehot) . biscuit bread cereal coffee jam milk orange sugar tea 0 True True False False False True False False False 1 True True True False False True False False False 2 False True False False False False False False True 3 False True False False True True False False False 4 True False False False False False False False True 5 False True False False False False False False True 6 False False True False False False False False True 7 True True False False False False False False True 8 False True False False True False False False True 9 False True False False False True False False False 10 True False True True False False True False False 11 True False True True False False True False False 12 False False False True False False False True False 13 False True False True False False True False False 14 True True False False False False False True False 15 False False True True False False False True False 16 True True False False False False False True False 17 False True False True False False False True False 18 False True False True False False False True False 19 False False True True False True False False True . # Compute the support support = onehot.mean() # Print the support print(support) . biscuit 0.40 bread 0.65 cereal 0.30 coffee 0.40 jam 0.10 milk 0.25 orange 0.15 sugar 0.30 tea 0.35 dtype: float64 . # Add a jam+bread column to the DataFrame onehot onehot[&#39;jam+bread&#39;] = np.logical_and(onehot[&#39;jam&#39;], onehot[&#39;bread&#39;]) # Compute the support support = onehot.mean() # Print the support values print(support) . biscuit 0.40 bread 0.65 cereal 0.30 coffee 0.40 jam 0.10 milk 0.25 orange 0.15 sugar 0.30 tea 0.35 jam+bread 0.10 dtype: float64 . . Additional Reference JMR生活総合研究所. アップセリング（Up-selling）、クロスセリング（Cross-selling）. マーケティング用語集. https://www.jmrlsi.co.jp/knowledge/yougo/my06/my0618.html . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] . &lt;/div&gt; .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/08/Basket-analysis-1.html",
            "relUrl": "/datacamp/2021/02/08/Basket-analysis-1.html",
            "date": " • Feb 8, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Analyzing Marketing Campaigns with pandas ④",
            "content": ". A/B&#12486;&#12473;&#12488;&#12392;&#12399; . どのバリアントのパフォーマンスが優れているかを評価するランダム化実験 | . A/B&#12486;&#12473;&#12488;&#12434;&#34892;&#12358;&#26178;&#12398;&#27880;&#24847;&#20107;&#38917; . 明確なコントロールが必要 | テストを行う前にKPI（Key Performance Index）を設定 | ポジティブな結果を見つけようと、成功を再定義することは望ましくない | KPIを事前に文書化することで、テストの成功を明確に保つことができる | . . # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . &#12486;&#12473;&#12488;&#12398;&#21106;&#12426;&#24403;&#12390; . このデータは実際A/Bテストが行われている。variant列がpersonlizationかcontrolかによって割り当てされている。 . 以下のコードではmarketing_channelがEmailであるデータの中でA/Bテストの結果を分析する。 . email = marketing[marketing[&#39;marketing_channel&#39;] == &#39;Email&#39;] # Group the email DataFrame by variant alloc = email.groupby([&#39;variant&#39;])[&#39;user_id&#39;].nunique() # Plot a bar chart of the test allocation alloc.plot(kind=&#39;bar&#39;) plt.title(&#39;Personalization test allocation&#39;) plt.ylabel(&#39;# participants&#39;) plt.show() . Personalizaiton&#12464;&#12523;&#12540;&#12503;&#12392;Control&#12464;&#12523;&#12540;&#12503;&#12398;&#36578;&#25563;&#29575;&#12398;&#24179;&#22343;&#35336;&#31639; . subscribers = email.groupby([&#39;user_id&#39;, &#39;variant&#39;])[&#39;converted&#39;].max() subscribers_df = pd.DataFrame(subscribers.unstack(level=1)) # Drop missing values from the control column control = subscribers_df[&#39;control&#39;].dropna() # Drop missing values from the personalization column personalization = subscribers_df[&#39;personalization&#39;].dropna() print(&#39;Control conversion rate:&#39;, np.mean(control)) print(&#39;Personalization conversion rate:&#39;, np.mean(personalization)) . Control conversion rate: 0.2814814814814815 Personalization conversion rate: 0.3908450704225352 . Lift&#20516;&#12398;&#35336;&#31639; . $Lift = cfrac{Treatment space conversion space rate space - space Control space conversion space rate}{Control space conversion space rate}$ . # Lift関数の定義 def lift(control, treat): # Calcuate the mean of control and treatment control_mean = np.mean(control) treat_mean = np.mean(treat) # Calculate the lift using control_mean and treat_mean lift = (treat_mean-control_mean)/control_mean return str(round(lift*100, 2)) + &#39;%&#39; # Print lift() with control and personalization as inputs print(lift(control, personalization)) . 38.85% . A/B&#12486;&#12473;&#12488;&amp;&#12475;&#12464;&#12513;&#12531;&#12486;&#12540;&#12471;&#12519;&#12531;&amp;T-test &#38306;&#25968; . E-mailのマーケッティングの実績における別の特徴（セグメント）ごとにLift値＆T-test（統計的有意性）を計算する関数 . from scipy import stats . def ab_segmentation(segment): # Build a for loop for each segment in marketing for subsegment in np.unique(marketing[segment].values): print(subsegment) # Limit marketing to email and subsegment email = marketing[(marketing[&#39;marketing_channel&#39;] == &#39;Email&#39;) &amp; (marketing[segment] == subsegment)] subscribers = email.groupby([&#39;user_id&#39;, &#39;variant&#39;])[&#39;converted&#39;].max() subscribers = pd.DataFrame(subscribers.unstack(level=1)) control = subscribers[&#39;control&#39;].dropna() personalization = subscribers[&#39;personalization&#39;].dropna() print(&#39;lift:&#39;, lift(control, personalization)) print(&#39;t-statistic:&#39;, stats.ttest_ind(control, personalization), &#39; n n&#39;) . ab_segmentation(&#39;language_displayed&#39;) . Arabic lift: 50.0% t-statistic: Ttest_indResult(statistic=-0.5773502691896255, pvalue=0.5795840000000001) English lift: 39.0% t-statistic: Ttest_indResult(statistic=-2.2183598646203166, pvalue=0.026991701290720815) German lift: -1.62% t-statistic: Ttest_indResult(statistic=0.1910083418078718, pvalue=0.8494394170062678) Spanish lift: 166.67% t-statistic: Ttest_indResult(statistic=-2.3570226039551585, pvalue=0.040156718110477524) . ab_segmentation(&#39;age_group&#39;) . 0-18 years lift: 121.4% t-statistic: Ttest_indResult(statistic=-2.966044912142211, pvalue=0.0038724494391297226) 19-24 years lift: 106.24% t-statistic: Ttest_indResult(statistic=-3.03179438478667, pvalue=0.0030623836114689134) 24-30 years lift: 161.19% t-statistic: Ttest_indResult(statistic=-3.861539544326876, pvalue=0.00018743381094867337) 30-36 years lift: -100.0% t-statistic: Ttest_indResult(statistic=3.1859064644147996, pvalue=0.0023238487431765137) 36-45 years lift: -85.23% t-statistic: Ttest_indResult(statistic=2.4317901279318503, pvalue=0.01797568600978829) 45-55 years lift: -72.22% t-statistic: Ttest_indResult(statistic=2.065499127317933, pvalue=0.043062339688201196) 55+ years lift: -100.0% t-statistic: Ttest_indResult(statistic=3.3265654564203397, pvalue=0.0016358623456360435) . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/04/Marketing-4.html",
            "relUrl": "/datacamp/2021/02/04/Marketing-4.html",
            "date": " • Feb 4, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Analyzing Marketing Campaigns with pandas ③",
            "content": ". # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np . marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . . &#36578;&#25563;&#29575;&#12434;&#27714;&#12417;&#12427;&#38306;&#25968;&#12398;&#20316;&#25104; . def conversion_rate(dataframe, column_names): # Total number of converted users column_conv = dataframe[dataframe[&#39;converted&#39;] == True] .groupby(column_names)[&#39;user_id&#39;].nunique() # Total number users column_total = dataframe.groupby(column_names)[&#39;user_id&#39;].nunique() # Conversion rate conversion_rate = column_conv/column_total # Fill missing values with 0 conversion_rate = conversion_rate.fillna(0) return conversion_rate . age_group_conv = conversion_rate(marketing, [&#39;date_served&#39;, &#39;age_group&#39;]) # Unstack and create a DataFrame age_group_df = pd.DataFrame(age_group_conv.unstack(level = 1)) # Visualize conversion by age_group age_group_df.plot() plt.title(&#39;Conversion rate by age group n&#39;, size = 16) plt.ylabel(&#39;Conversion rate&#39;, size = 14) plt.xlabel(&#39;Age group&#39;, size = 14) plt.show() . 別々にプロットする関数を作成してみよう。 . def plotting_conv(dataframe): for column in dataframe: # Plot column by dataframe&#39;s index plt.plot(dataframe.index, dataframe[column]) plt.title(&#39;Daily &#39; + str(column) + &#39; conversion rate n&#39;, size = 16) plt.ylabel(&#39;Conversion rate&#39;, size = 14) plt.xlabel(&#39;Date&#39;, size = 14) plt.xticks(rotation = 45) # Show plot plt.show() plt.clf() . age_group_conv = conversion_rate(marketing, [&#39;date_served&#39;, &#39;age_group&#39;]) # Unstack age_group_conv and create a DataFrame age_group_df = pd.DataFrame(age_group_conv.unstack(level=1)) # Plot the results plotting_conv(age_group_df) . &lt;Figure size 432x288 with 0 Axes&gt; . . &#21839;&#38988;&#30330;&#35211;&#12363;&#12425;&#28508;&#22312;&#30340;&#21407;&#22240;&#12434;&#32771;&#12360;&#12427; . &#21839;&#38988;&#30330;&#35211;&#12398;&#20363; . daily_conv_channel = conversion_rate(marketing, [&#39;date_served&#39;, &#39;marketing_channel&#39;]) # Unstack daily_conv_channel and convert it to a DataFrame daily_conv_channel = pd.DataFrame(daily_conv_channel.unstack(level = 1)) # Plot results of daily_conv_channel plotting_conv(daily_conv_channel) . &lt;Figure size 432x288 with 0 Axes&gt; . House Adsのチャネルで広告を打ったとき、1月11日頃から転換率が急に落ちている。 | . &#28508;&#22312;&#30340;&#12394;&#21407;&#22240;&#12434;&#25506;&#12377; . ① チャネルごとの曜日別転換率の差を見る . marketing[&#39;DoW_served&#39;] = marketing[&#39;date_served&#39;].dt.dayofweek # Calculate conversion rate by day of week DoW_conversion = conversion_rate(marketing, [&#39;DoW_served&#39;, &#39;marketing_channel&#39;]) # Unstack channels DoW_df = pd.DataFrame(DoW_conversion.unstack(level=1)) # Plot conversion rate by day of week DoW_df.plot() plt.title(&#39;Conversion rate by day of week n&#39;) plt.ylim(0) plt.show() . 【結果】特に関係性が見られない。 . ②House Adsチャネルのうち、広告表示言語ごとに日別転換率を計算 . house_ads = marketing[marketing[&#39;marketing_channel&#39;] == &#39;House Ads&#39;] # Calculate conversion by date served and language displayed conv_lang_channel = conversion_rate(house_ads, [&#39;date_served&#39;, &#39;language_displayed&#39;]) # Unstack conv_lang_channel conv_lang_df = pd.DataFrame(conv_lang_channel.unstack(level=1)) # Use plotting function to display results plotting_conv(conv_lang_df) . &lt;Figure size 432x288 with 0 Axes&gt; . 【結果】ほとんどの言語で1月11日以降転換率が落ちている。 . ③ユーザーの使用言語と広告の表示言語がどれだけ一致しているかを日別に見る . house_ads[&#39;is_correct_lang&#39;] = np.where( house_ads[&#39;language_preferred&#39;] == house_ads[&#39;language_displayed&#39;], &#39;Yes&#39;, &#39;No&#39;) # Groupby date_served and is_correct_lang language_check = house_ads.groupby([&#39;date_served&#39;,&#39;is_correct_lang&#39;])[&#39;is_correct_lang&#39;].count() # Unstack language_check and fill missing values with 0&#39;s language_check_df = pd.DataFrame(language_check.unstack(level=1)).fillna(0) # Print results print(language_check_df) . is_correct_lang No Yes date_served 2018-01-01 2.0 189.0 2018-01-02 3.0 247.0 2018-01-03 0.0 220.0 2018-01-04 0.0 168.0 2018-01-05 0.0 160.0 2018-01-06 1.0 151.0 2018-01-07 2.0 130.0 2018-01-08 0.0 154.0 2018-01-09 0.0 157.0 2018-01-10 0.0 170.0 2018-01-11 20.0 135.0 2018-01-12 18.0 130.0 2018-01-13 26.0 122.0 2018-01-14 20.0 131.0 2018-01-15 16.0 192.0 2018-01-16 28.0 127.0 2018-01-17 21.0 127.0 2018-01-18 31.0 121.0 2018-01-19 22.0 127.0 2018-01-20 28.0 124.0 2018-01-21 14.0 100.0 2018-01-22 13.0 72.0 2018-01-23 16.0 69.0 2018-01-24 13.0 83.0 2018-01-25 19.0 74.0 2018-01-26 24.0 92.0 2018-01-27 18.0 149.0 2018-01-28 28.0 136.0 2018-01-29 24.0 142.0 2018-01-30 23.0 145.0 2018-01-31 23.0 135.0 . /Users/sungminje/opt/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:5: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34; . language_check_df[&#39;pct&#39;] = language_check_df[&#39;Yes&#39;]/language_check_df.sum(axis=1) # Plot and show your results plt.plot(language_check_df.index.values, language_check_df[&#39;pct&#39;]) plt.xticks(rotation = 45) plt.show() . 【結果】1月11日以降間違った言語で送られたHouse Adsの広告が多いことが分かった。 →おそらく、このHouse Adsのバグによって転換率が低下した。 . &#12496;&#12464;&#12364;&#12394;&#12363;&#12387;&#12383;&#22580;&#21512;&#12434;&#20104;&#28204;&#12377;&#12427; . house_ads_bug = house_ads[house_ads[&#39;date_served&#39;] &lt; &#39;2018-01-11&#39;] lang_conv = conversion_rate(house_ads_bug, [&#39;language_displayed&#39;]) # Index other language conversion rate against English spanish_index = lang_conv[&#39;Spanish&#39;]/lang_conv[&#39;English&#39;] arabic_index = lang_conv[&#39;Arabic&#39;]/lang_conv[&#39;English&#39;] german_index = lang_conv[&#39;German&#39;]/lang_conv[&#39;English&#39;] print(&quot;Spanish index:&quot;, spanish_index) print(&quot;Arabic index:&quot;, arabic_index) print(&quot;German index:&quot;, german_index) . Spanish index: 1.681924882629108 Arabic index: 5.045774647887324 German index: 4.485133020344287 . converted = house_ads.groupby([&#39;date_served&#39;, &#39;language_preferred&#39;]) .agg({&#39;user_id&#39;:&#39;nunique&#39;, &#39;converted&#39;:&#39;sum&#39;}) # Unstack converted converted_df = pd.DataFrame(converted.unstack(level=1)) . converted_df[&#39;english_conv_rate&#39;] = converted_df.loc[&#39;2018-01-11&#39;:&#39;2018-01-31&#39;][(&#39;converted&#39;,&#39;English&#39;)] # Create expected conversion rates for each language converted_df[&#39;expected_spanish_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*spanish_index converted_df[&#39;expected_arabic_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*arabic_index converted_df[&#39;expected_german_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*german_index # Multiply number of users by the expected conversion rate converted_df[&#39;expected_spanish_conv&#39;] = converted_df[&#39;expected_spanish_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;Spanish&#39;)] converted_df[&#39;expected_arabic_conv&#39;] = converted_df[&#39;expected_arabic_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;Arabic&#39;)] converted_df[&#39;expected_german_conv&#39;] = converted_df[&#39;expected_german_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;German&#39;)] . converted_df = converted_df.loc[&#39;2018-01-11&#39;:&#39;2018-01-31&#39;] # Sum expected subscribers for each language expected_subs = converted_df[&#39;expected_spanish_conv&#39;].sum() + converted_df[&#39;expected_arabic_conv&#39;].sum() + converted_df[&#39;expected_german_conv&#39;].sum() # Calculate how many subscribers we actually got actual_subs = converted_df[(&#39;converted&#39;,&#39;Spanish&#39;)].sum() + converted_df[(&#39;converted&#39;,&#39;Arabic&#39;)].sum() + converted_df[(&#39;converted&#39;,&#39;German&#39;)].sum() # Subtract how many subscribers we got despite the bug lost_subs = expected_subs - actual_subs print(lost_subs) . 32.144143192488265 . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev]　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/03/Marketing-3.html",
            "relUrl": "/datacamp/2021/02/03/Marketing-3.html",
            "date": " • Feb 3, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Analyzing Marketing Campaigns with pandas ②",
            "content": ". # import data import pandas as pd marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) . marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . . &#12461;&#12515;&#12531;&#12506;&#12540;&#12531;&#12399;&#25104;&#21151;&#12375;&#12383;&#12398;&#12363;&#65311; . これを評価するために、いくつかの指標が使われる。 . 転換率（Conversion rate） | 保持率（Retention rate） | . etc. . &#36578;&#25563;&#29575;&#65288;Conversion rate&#65289;&#12434;&#27714;&#12417;&#12427; . $Conversion space rate = cfrac{Number space of space people space who space convert}{Total space number space of space people space we space marketed space to} $ . # すべての顧客を求める。(Total number of people we marketed to) total = marketing[&#39;user_id&#39;].nunique() # 転換した顧客を求める。(Number of people who converted) subscribers = marketing[marketing[&quot;converted&quot;] == True][&#39;user_id&#39;].nunique() # 転換率を計算する。 conversion_rate = subscribers/total print(round(conversion_rate*100, 2), &quot;%&quot;) . 13.89 % . &#20445;&#25345;&#29575;&#65288;Retention rate&#65289;&#12434;&#27714;&#12417;&#12427; . $Retention space rate = cfrac{Number space of space people space who space remain space subscribed}{Total space number space of space people space who space converted} $ . # 転換した顧客を求める。 (Total number of people who converted) total_subscribers = marketing[marketing[&quot;converted&quot;] == True] [&#39;user_id&#39;].nunique() # 保持した顧客を求める。(Number of people who remained subscribed) retained = marketing[marketing[&#39;is_retained&#39;] == True] [&#39;user_id&#39;].nunique() # 保持率を計算する。 retention_rate = retained/total_subscribers print(round(retention_rate*100, 2), &quot;%&quot;) . 66.8 % . . &#12475;&#12464;&#12513;&#12531;&#12486;&#12540;&#12471;&#12519;&#12531; . 顧客をセグメント化するには、いくつかの一般的な基準がある。 . 年齢 | 性別 | 場所 | 過去の取引 | 取引したマーケッティングチャネル | . etc. . # 英語使用者を抽出 english_speakers = marketing[marketing[&#39;language_displayed&#39;] == &#39;English&#39;] # 英語使用者のユニークIDを数える total = english_speakers[&#39;user_id&#39;].nunique() # 転換した英語使用者 subscribers = english_speakers[english_speakers[&#39;converted&#39;] == True] [&#39;user_id&#39;].nunique() # 英語使用者の転換率 conversion_rate = subscribers/total print(&#39;英語使用者の転換率：&#39;, round(conversion_rate*100,2), &#39;%&#39;) . 英語使用者の転換率： 12.92 % . # 各言語ごとにグループ化し、ユニークIDをカウント total = marketing.groupby([&#39;language_displayed&#39;])[&#39;user_id&#39;].nunique() # 各言語ごとにグループ化し、そのうち転換したIDをカウント subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;language_displayed&#39;])[&#39;user_id&#39;].nunique() # グループごとに転換率計算 language_conversion_rate = subscribers/total print(language_conversion_rate) . language_displayed Arabic 0.500000 English 0.129167 German 0.716216 Spanish 0.200000 Name: user_id, dtype: float64 . # 日付ごとにグループ化し、ユニークIDをカウント total = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;] .nunique() # 日付ごとにグループ化し、そのうち転換したIDをカウント subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;date_served&#39;]) [&#39;user_id&#39;].nunique() # 日付ごとの転換率 daily_conversion_rate = subscribers/total print(daily_conversion_rate) . date_served 2018-01-01 0.099448 2018-01-02 0.098930 2018-01-03 0.103448 2018-01-04 0.108359 2018-01-05 0.125392 2018-01-06 0.113636 2018-01-07 0.141818 2018-01-08 0.115385 2018-01-09 0.125000 2018-01-10 0.118694 2018-01-11 0.080645 2018-01-12 0.076412 2018-01-13 0.084967 2018-01-14 0.085246 2018-01-15 0.113429 2018-01-16 0.255155 2018-01-17 0.219512 2018-01-18 0.091195 2018-01-19 0.059016 2018-01-20 0.067524 2018-01-21 0.087336 2018-01-22 0.123596 2018-01-23 0.122093 2018-01-24 0.115789 2018-01-25 0.125000 2018-01-26 0.090090 2018-01-27 0.065625 2018-01-28 0.062500 2018-01-29 0.059561 2018-01-30 0.066246 2018-01-31 0.052941 Name: user_id, dtype: float64 . . &#12461;&#12515;&#12531;&#12506;&#12540;&#12531;&#32080;&#26524;&#12434;&#12503;&#12525;&#12483;&#12488; . import matplotlib.pyplot as plt # Create a bar chart using language_conversion_rate DataFrame language_conversion_rate.plot(kind = &#39;bar&#39;) # Add a title and x and y-axis labels plt.title(&#39;Conversion rate by language n&#39;, size = 16) plt.ylabel(&#39;Conversion rate (%)&#39;, size = 14) plt.xlabel(&#39;Language&#39;, size = 14) # Display the plot plt.show() . # Group by date_served and count unique users total = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;] .nunique() # Group by date_served and calculate subscribers subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;date_served&#39;]) [&#39;user_id&#39;].nunique() # Calculate the conversion rate for all languages daily_conversion_rate = subscribers/total # Reset index to turn the results into a DataFrame daily_conversion_rate = pd.DataFrame(daily_conversion_rate.reset_index(0)) # Rename columns daily_conversion_rate.columns = [&#39;date_served&#39;, &#39;conversion_rate&#39;] # Create a line chart using daily_conversion_rate DataFrame daily_conversion_rate.plot(&#39;date_served&#39;, &#39;conversion_rate&#39;) plt.title(&#39;Daily conversion rate n&#39;, size = 16) plt.ylabel(&#39;Conversion rate (%)&#39;, size = 14) plt.xlabel(&#39;Date&#39;, size = 14) # Set the y-axis to begin at 0 plt.ylim(0) # Display the plot plt.show() . channel_age = marketing.groupby([&#39;marketing_channel&#39;, &#39;age_group&#39;]) [&#39;user_id&#39;].count() # Unstack channel_age and transform it into a DataFrame channel_age_df = pd.DataFrame(channel_age.unstack(level = 1)) # Plot the results channel_age_df.plot(kind = &#39;bar&#39;) plt.title(&#39;Marketing channels by age group&#39;) plt.xlabel(&#39;Age Group&#39;) plt.ylabel(&#39;Users&#39;) # Add a legend to the plot plt.legend(loc = &#39;upper right&#39;, labels = channel_age_df.columns.values) plt.show() . # Count the subs by subscribing channel and date subscribed retention_total = marketing.groupby([&#39;date_subscribed&#39;, &#39;subscribing_channel&#39;]) [&#39;user_id&#39;].nunique() # Count the retained subs by subscribing channel and date subscribed retention_subs = marketing[marketing[&#39;is_retained&#39;] == True] .groupby([&#39;date_subscribed&#39;, &#39;subscribing_channel&#39;]) [&#39;user_id&#39;].nunique() # Divide retained subscribers by total subscribers retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) retention_rate_df.head(10) . subscribing_channel Email Facebook House Ads Instagram Push . date_subscribed . 2018-01-01 1.00 | 0.875000 | 0.687500 | 0.750000 | 1.000000 | . 2018-01-02 0.75 | 1.000000 | 0.588235 | 0.625000 | 1.000000 | . 2018-01-03 NaN | 0.800000 | 0.647059 | 0.909091 | 0.666667 | . 2018-01-04 0.50 | 0.666667 | 0.466667 | 0.500000 | NaN | . 2018-01-05 1.00 | 0.571429 | 0.500000 | 0.636364 | 1.000000 | . 2018-01-06 0.80 | 0.571429 | 0.941176 | 0.500000 | 0.500000 | . 2018-01-07 0.50 | 0.750000 | 0.526316 | 0.400000 | 0.666667 | . 2018-01-08 NaN | 0.888889 | 0.500000 | 0.625000 | 1.000000 | . 2018-01-09 0.50 | 0.285714 | 0.850000 | 0.666667 | 0.500000 | . 2018-01-10 1.00 | 0.714286 | 0.666667 | 0.555556 | 1.000000 | . # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate (%)&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev]　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/02/Marketing-2.html",
            "relUrl": "/datacamp/2021/02/02/Marketing-2.html",
            "date": " • Feb 2, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Analyzing Marketing Campaigns with pandas ①",
            "content": ". &#12510;&#12540;&#12465;&#12486;&#12451;&#12531;&#12464;&#12481;&#12540;&#12512;&#12391;&#12487;&#12540;&#12479;&#12469;&#12452;&#12456;&#12531;&#12486;&#12451;&#12473;&#12488;&#12364;&#12420;&#12427;&#12371;&#12392; . マーケッティングキャンペーンの効果分析 &amp; ターゲッティング | マーケッティングチャネルの転換率や収益を考慮し、妥当性を分析 | A/B テストを行う | . . # import data import pandas as pd marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;) . &#12487;&#12540;&#12479;&#12434;&#30906;&#35469; . marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 1/1/18 | House Ads | personalization | True | English | English | 0-18 years | 1/1/18 | NaN | House Ads | True | . 1 a100000030 | 1/1/18 | House Ads | personalization | True | English | English | 19-24 years | 1/1/18 | NaN | House Ads | True | . 2 a100000031 | 1/1/18 | House Ads | personalization | True | English | English | 24-30 years | 1/1/18 | NaN | House Ads | True | . 3 a100000032 | 1/1/18 | House Ads | personalization | True | English | English | 30-36 years | 1/1/18 | NaN | House Ads | True | . 4 a100000033 | 1/1/18 | House Ads | personalization | True | English | English | 36-45 years | 1/1/18 | NaN | House Ads | True | . marketing.describe() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . count 10037 | 10021 | 10022 | 10037 | 10022 | 10037 | 10037 | 10037 | 1856 | 577 | 1856 | 1856 | . unique 7309 | 31 | 5 | 2 | 2 | 4 | 4 | 7 | 31 | 115 | 5 | 2 | . top a100000882 | 1/15/18 | House Ads | control | False | English | English | 19-24 years | 1/16/18 | 4/2/18 | Instagram | True | . freq 12 | 789 | 4733 | 5091 | 8946 | 9793 | 9275 | 1682 | 163 | 15 | 600 | 1279 | . marketing.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 10037 entries, 0 to 10036 Data columns (total 12 columns): # Column Non-Null Count Dtype -- -- 0 user_id 10037 non-null object 1 date_served 10021 non-null object 2 marketing_channel 10022 non-null object 3 variant 10037 non-null object 4 converted 10022 non-null object 5 language_displayed 10037 non-null object 6 language_preferred 10037 non-null object 7 age_group 10037 non-null object 8 date_subscribed 1856 non-null object 9 date_canceled 577 non-null object 10 subscribing_channel 1856 non-null object 11 is_retained 1856 non-null object dtypes: object(12) memory usage: 941.1+ KB . &#21015;&#12372;&#12392;&#12395;&#12487;&#12540;&#12479;&#22411;&#12434;&#26356;&#26032;&#12377;&#12427; . &#12487;&#12540;&#12479;&#22411;&#12398;&#22793;&#25563; . # Check the data type print(marketing[&#39;is_retained&#39;].dtype) . object . # Convert is_retained to a boolean marketing[&#39;is_retained&#39;] = marketing[&#39;is_retained&#39;].astype(&#39;bool&#39;) # Check the data type of is_retained, again print(marketing[&#39;is_retained&#39;].dtype) . bool . &#26032;&#12375;&#12356;&#21015;&#12398;&#36861;&#21152; . # Mapping for channels channel_dict = {&quot;House Ads&quot;: 1, &quot;Instagram&quot;: 2, &quot;Facebook&quot;: 3, &quot;Email&quot;: 4, &quot;Push&quot;: 5} # チャネルをコードにMappingする marketing[&#39;channel_code&#39;] = marketing[&#39;subscribing_channel&#39;].map(channel_dict) . # 結果 marketing[[&#39;subscribing_channel&#39;, &#39;channel_code&#39;]] . subscribing_channel channel_code . 0 House Ads | 1.0 | . 1 House Ads | 1.0 | . 2 House Ads | 1.0 | . 3 House Ads | 1.0 | . 4 House Ads | 1.0 | . ... ... | ... | . 10032 Email | 4.0 | . 10033 Email | 4.0 | . 10034 Email | 4.0 | . 10035 Email | 4.0 | . 10036 Email | 4.0 | . 10037 rows × 2 columns . import numpy as np # 列同士の一致有無を表す列を追加 marketing[&#39;is_correct_lang&#39;] = np.where( marketing[&#39;language_preferred&#39;] == marketing[&#39;language_displayed&#39;], &#39;Yes&#39;, &#39;No&#39; ) # 結果 marketing[[&#39;language_preferred&#39;, &#39;language_displayed&#39;, &#39;is_correct_lang&#39;]] . language_preferred language_displayed is_correct_lang . 0 English | English | Yes | . 1 English | English | Yes | . 2 English | English | Yes | . 3 English | English | Yes | . 4 English | English | Yes | . ... ... | ... | ... | . 10032 German | German | Yes | . 10033 German | German | Yes | . 10034 German | German | Yes | . 10035 German | German | Yes | . 10036 German | German | Yes | . 10037 rows × 3 columns . # インポートの時にdatatime型にすることも可能 # marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, # parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) # 曜日の列を数字で表した列追加 # 月曜日:0, ... ,日曜日:6 marketing_with_date[&#39;DoW&#39;] = marketing_with_date[&#39;date_subscribed&#39;].dt.dayofweek #結果 marketing_with_date[[&#39;date_subscribed&#39;, &#39;DoW&#39;]] . date_subscribed DoW . 0 2018-01-01 | 0.0 | . 1 2018-01-01 | 0.0 | . 2 2018-01-01 | 0.0 | . 3 2018-01-01 | 0.0 | . 4 2018-01-01 | 0.0 | . ... ... | ... | . 10032 2018-01-17 | 2.0 | . 10033 2018-01-17 | 2.0 | . 10034 2018-01-17 | 2.0 | . 10035 2018-01-17 | 2.0 | . 10036 2018-01-17 | 2.0 | . 10037 rows × 2 columns . &#25506;&#32034;&#30340;&#12487;&#12540;&#12479;&#35299;&#26512;&#65288;EDA&#65289; . # date_served列をグループ化し、項目ごとにユニークなIDを数える daily_users = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;].nunique() # print head print(daily_users.head()) . date_served 1/1/18 362 1/10/18 337 1/11/18 310 1/12/18 301 1/13/18 306 Name: user_id, dtype: int64 . import matplotlib.pyplot as plt # Plot daily_subscribers daily_users.plot() # Include a title and y-axis label plt.title(&#39;Daily users&#39;) plt.ylabel(&#39;Number of users&#39;) # Rotate the x-axis labels by 45 degrees plt.xticks(rotation = 45) # Display the plot plt.show() . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/02/Marketing-1.html",
            "relUrl": "/datacamp/2021/02/02/Marketing-1.html",
            "date": " • Feb 2, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jaysung00.github.io/jays_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jaysung00.github.io/jays_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jaysung00.github.io/jays_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}