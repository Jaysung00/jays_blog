{
  
    
        "post0": {
            "title": "Today I Learned 211018",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 매직 메소드(1-1, 2-1, 2-2) . . &#54028;&#51060;&#50028;&#51032; &#54645;&#49900; . 시퀀스(Sequence) | 반복(Iterator) | 함수(Functions) | 클래스(Class) | . . &#47588;&#51649; &#47700;&#49548;&#46300; (&#49828;&#54168;&#49500; &#47700;&#49548;&#46300;)&#46976;? . 클래스 안에 정의할 수 있는 특별한 Built-in 메서드 . # 기본형 print(int) print(float) # 모든 속성 및 메소드 출력 print(dir(int)) print(dir(float)) . &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;, &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;, &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;, &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;] [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__bool__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getformat__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__set_format__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;as_integer_ratio&#39;, &#39;conjugate&#39;, &#39;fromhex&#39;, &#39;hex&#39;, &#39;imag&#39;, &#39;is_integer&#39;, &#39;real&#39;] . n = 10 print(n + 100) # 여기서 내부적으로 일어나는 일. print(n.__add__(100)) #int class의 매직메소드인 __add__가 호출됨 . 110 110 . print(bool(n), n.__bool__()) #내부적으로 일어나는 일 print(n * 100, n.__mul__(100)) . True True 1000 1000 . #클래스 예제1 class Fruit: def __init__(self, name, price): self._name = name self._price = price def __str__(self): return &#39;Fruit Class Info : {} , {}&#39;.format(self._name, self._price) def __add__(self, x): print(&#39;Called &gt;&gt; __add__&#39;) return self._price + x._price def __sub__(self, x): print(&#39;Called &gt;&gt; __sub__&#39;) return self._price - x._price def __le__(self, x): print(&#39;Called &gt;&gt; __le__&#39;) if self._price &lt;= x._price: return True else: return False def __ge__(self, x): print(&#39;Called &gt;&gt; __ge__&#39;) if self._price &gt;= x._price: return True else: return False . #인스턴스 생성 s1 = Fruit(&#39;Orange&#39;, 7500) s2 = Fruit(&#39;Banana&#39;, 3000) . #일반적인 계산 print(s1._price + s2._price) ##코드 양도 늘어나고 가독성도 떨어지므로 좋지않은 방식 . 10500 . # __add__ 매소드의 이용 print(s1 + s2) ## + 를 사용하므로써 __add__가 실행되는 빌트인 매직메소드 . Called &gt;&gt; __add__ 10500 . # 매직메소드 print(s1 &gt;= s2) print(s1 &lt;= s2) print(s1 - s2) print(s2 - s1) print(s1) ## __str__ print(s2) . Called &gt;&gt; __ge__ True Called &gt;&gt; __le__ False Called &gt;&gt; __sub__ 4500 Called &gt;&gt; __sub__ -4500 Fruit Class Info : Orange , 7500 Fruit Class Info : Banana , 3000 . &#48372;&#52649;&#51648;&#49885; . *args . 매개변수 앞에 애스터리스크(*)를 붙여주면, 여러개의 변수를 하나의 튜플로 묶어 패킹(packing)해줌 함수에 값을 넘길때, 리스트나 튜플같이 컨테이너형 변수에 애스터리스크를 붙이면 unpacking되어 전달된다. . **kwargs . 키와 밸류값을 가변적으로 패킹하여 전달받을 수 있다. . # 클래스 예제2 # 벡터를 다루는 클래스를 만들어보자 ## 예1) (5,2) + (4,3) = (9,5) ## 예2) (10,3) * 3 = (50,15) ## 예3) Max((5,10)) = 10 class Vector(object): def __init__(self, *args): # packing해서 넘겨받아 나중에 unpacking &#39;&#39;&#39; Create a vector, example : v = Vector(5,10) &#39;&#39;&#39; if len(args) == 0: self._x, self._y = 0, 0 else: self._x, self._y = args def __repr__(self): &#39;&#39;&#39;Returns the vector informations.&#39;&#39;&#39; return &#39;Vector(%r, %r)&#39; % (self._x, self._y) def __add__(self, other): &#39;&#39;&#39;Returns the vector addition of self and other&#39;&#39;&#39; return Vector(self._x + other._x, self._y + other._y) def __mul__(self, y): return Vector(self._x * y, self._y * y) def __bool__(self): return bool(max(self._x, self._y)) #좌표 평면에서 0,0인지 확인 print(Vector.__doc__) #클래스 자체의 주석은 없음 print(Vector.__init__.__doc__) #메소드 단위의 주석 . None Create a vector, example : v = Vector(5,10) . # Vector 인스턴스 생성 v1 = Vector(5,7) v2 = Vector(23, 53) v3 = Vector() . # 매직메소드 출력 print(Vector.__init__.__doc__) print(Vector.__repr__.__doc__) print(Vector.__add__.__doc__) print(v1, v2, v3) print(v1 + v2) print(v1 * 3) print(v2 * 10) print(bool(v1), bool(v2)) print(bool(v3)) . Create a vector, example : v = Vector(5,10) Returns the vector informations. Returns the vector addition of self and other Vector(5, 7) Vector(23, 53) Vector(0, 0) Vector(28, 60) Vector(15, 21) Vector(230, 530) True True False .",
            "url": "https://jaysung00.github.io/jays_blog/til/2021/10/18/TIL211018.html",
            "relUrl": "/til/2021/10/18/TIL211018.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "파이썬 예제3) 알람시계",
            "content": ". &#47928;&#51228; . 상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다. . 상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다. . 이런 상근이를 불쌍하게 보던, 창영이는 자신이 사용하는 방법을 추천해 주었다. . 바로 &quot;45분 일찍 알람 설정하기&quot;이다. . 이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다. . 현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오. . &#51077;&#47141; . 첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다. . 입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다. . &#52636;&#47141; . 첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.) . 예제 입력 예제 출력 . 10 10 | 9 25 | . 0 30 | 23 45 | . 23 40 | 22 55 | . # 첫번째 시도 h, m = map(int, input().split()) if m &gt;= 45: m -= 45 elif (m &lt;= 45) and (h &gt;= 1): m += 15 h -= 1 else: m += 15 h = 23 print(h, m) #sep 디폴트 옵션은 공백하나, end 디폴트 옵션은 개행. . 22 55 .",
            "url": "https://jaysung00.github.io/jays_blog/python/2021/10/18/BOJ2884.html",
            "relUrl": "/python/2021/10/18/BOJ2884.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Today I Learned 211017",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 클래스 &amp; 메소드 심화(3-1, 3-2) . # 클래스 선언 class Car(object): &#39;&#39;&#39; Car Class Author : Me Date : 2019.11.08 Description : Class, Static, Instance Method &#39;&#39;&#39; # Class Variable price_per_raise = 1.0 def __init__(self, company, details): self._company = company self._details = details def __str__(self): return &#39;str : {} - {}&#39;.format(self._company, self._details) def __repr__(self): return &#39;repr : {} - {}&#39;.format(self._company, self._details) # Instance Method # self : 객체의 고유한 속성 값 사용 def detail_info(self): print(&#39;Current Id : {}&#39;.format(id(self))) print(&#39;Car Detail Info : {} {}&#39;.format(self._company, self._details.get(&#39;price&#39;))) # Instance Method def get_price(self): return &#39;Before Car Price -&gt; company : {}, price : {}&#39;.format(self._company, self._details.get(&#39;price&#39;)) # Instance Method def get_price_culc(self): return &#39;After Car Price -&gt; company : {}, price : {}&#39;.format(self._company, self._details.get(&#39;price&#39;) * Car.price_per_raise) # Class Method @classmethod # decorator def raise_price(cls, per): # 클래스메소드는 self 대신 cls를 받는다. if per &lt;= 1: print(&#39;Please Enter 1 or More&#39;) return cls.price_per_raise = per print(&#39;Succeed! price increased.&#39;) # Static Method @staticmethod def is_bmw(inst): # 아무것도 인수로 받지 않는다.. 그러나 필요성에 대해서는 의문 if inst._company == &#39;Bmw&#39;: return &#39;OK! This car is {}.&#39;.format(inst._company) return &#39;Sorry. This car is not Bmw.&#39; . # 자동차 인스턴스 car1 = Car(&#39;Bmw&#39;, {&#39;color&#39; : &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}) car2 = Car(&#39;Audi&#39;, {&#39;color&#39; : &#39;Silver&#39;, &#39;horsepower&#39;: 300, &#39;price&#39;: 6000}) . # 전체정보 car1.detail_info() car2.detail_info() . Current Id : 4558480720 Car Detail Info : Bmw 5000 Current Id : 4558481560 Car Detail Info : Audi 6000 . # 가격 정보(인상 전) print(car1.get_price()) print(car2.get_price()) . Before Car Price -&gt; company : Bmw, price : 5000 Before Car Price -&gt; company : Audi, price : 6000 . # 가격 인상(클래스 메소드 미사용) Car.price_per_raise = 1.2 . # 가격 정보(인상 후) print(car1.get_price_culc()) print(car2.get_price_culc()) print() . After Car Price -&gt; company : Bmw, price : 6000.0 After Car Price -&gt; company : Audi, price : 7200.0 . # 가격 인상(클래스 메소드 사용) Car.raise_price(1.6) # 가격 정보(인상 후 : 클래스메소드) print(car1.get_price_culc()) print(car2.get_price_culc()) print() . Succeed! price increased. After Car Price -&gt; company : Bmw, price : 8000.0 After Car Price -&gt; company : Audi, price : 9600.0 . # Bmw 여부(스테이틱 메소드 미사용) def is_bmw(inst): if inst._company == &#39;Bmw&#39;: return &#39;OK! This car is {}.&#39;.format(inst._company) return &#39;Sorry. This car is not Bmw.&#39; # 별도의 메소드 작성 후 호출 print(is_bmw(car1)) print(is_bmw(car2)) . OK! This car is Bmw. Sorry. This car is not Bmw. . # Bmw 여부(스테이틱 메소드 사용) print(&#39;Static : &#39;, Car.is_bmw(car1)) print(&#39;Static : &#39;, Car.is_bmw(car2)) print() print(&#39;Static : &#39;, car1.is_bmw(car1)) print(&#39;Static : &#39;, car2.is_bmw(car2)) . Static : OK! This car is Bmw. Static : Sorry. This car is not Bmw. Static : OK! This car is Bmw. Static : Sorry. This car is not Bmw. .",
            "url": "https://jaysung00.github.io/jays_blog/til/2021/10/17/TIL211017_2.html",
            "relUrl": "/til/2021/10/17/TIL211017_2.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Today I Learned 211017",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 클래스 &amp; 메소드 심화(2-1, 2-2) . # 클래스 재 선언 class Car(): &quot;&quot;&quot; Car Class Author : Kim Date : 2019.11.08 &quot;&quot;&quot; # 클래스 변수 (모든 인스턴스가 공유) car_count = 0 def __init__(self, company, details): self._company = company self._details = details Car.car_count += 1 def __str__(self): return &#39;str : {} - {}&#39;.format(self._company, self._details) def __repr__(self): return &#39;repr : {} - {}&#39;.format(self._company, self._details) def detail_info(self): print(&#39;Current Id : {}&#39;.format(id(self))) print(&#39;Car Detail Info : {} {}&#39;.format(self._company, self._details.get(&#39;price&#39;))) def __del__(self): Car.car_count -= 1 . car1 = Car(&#39;Ferrari&#39;, {&#39;color&#39; : &#39;White&#39;, &#39;horsepower&#39;: 400, &#39;price&#39;: 8000}) car2 = Car(&#39;Bmw&#39;, {&#39;color&#39; : &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}) car3 = Car(&#39;Audi&#39;, {&#39;color&#39; : &#39;Silver&#39;, &#39;horsepower&#39;: 300, &#39;price&#39;: 6000}) . # dir 확인 print(dir(car1)) print(dir(car2)) # 매직메서드를 포함한 모든 어트리뷰트 포함 . [&#39;__class__&#39;, &#39;__del__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_company&#39;, &#39;_details&#39;, &#39;car_count&#39;, &#39;detail_info&#39;] [&#39;__class__&#39;, &#39;__del__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_company&#39;, &#39;_details&#39;, &#39;car_count&#39;, &#39;detail_info&#39;] . # __dict__ 확인 print(car1.__dict__) print(car2.__dict__) #딕셔너리 형태로 실제로 사용중인 것만 키와 밸류로 들여다볼수 있음 #네임스페이스 . {&#39;_company&#39;: &#39;Ferrari&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;White&#39;, &#39;horsepower&#39;: 400, &#39;price&#39;: 8000}} {&#39;_company&#39;: &#39;Bmw&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}} . # Doctring print(Car.__doc__) #클래스 내의 설명부분 주석을 보여줌 . Car Class Author : Kim Date : 2019.11.08 . # 메서드 실행 car1.detail_info() car2.detail_info() # 에러 # Car.detail_info() . Current Id : 4361860096 Car Detail Info : Ferrari 8000 Current Id : 4361860152 Car Detail Info : Bmw 5000 . # 비교 print(car1.__class__, car2.__class__) print(id(car1.__class__), id(car2.__class__)) ## 부모에서 나오기 떄문에 아이디는 모두 같다 . &lt;class &#39;__main__.Car&#39;&gt; &lt;class &#39;__main__.Car&#39;&gt; 140610028679592 140610028679592 . # 인스턴스 변수 # 직접 접근(PEP 문법적으로 권장X) print(car1._company, car2._company) print(car2._company, car3._company) . Ferrari Bmw Bmw Audi . # 클래스 변수 # 접근 print(car1.car_count) print(car2.car_count) print(Car.car_count) . 3 3 3 . # 공유 확인 print(Car.__dict__) print(car1.__dict__) print(car2.__dict__) print(car3.__dict__) . {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: &#39; n Car Class n Author : Kim n Date : 2019.11.08 n &#39;, &#39;car_count&#39;: 3, &#39;__init__&#39;: &lt;function Car.__init__ at 0x103f1b6a8&gt;, &#39;__str__&#39;: &lt;function Car.__str__ at 0x103f1b1e0&gt;, &#39;__repr__&#39;: &lt;function Car.__repr__ at 0x103f1b378&gt;, &#39;detail_info&#39;: &lt;function Car.detail_info at 0x103f1b730&gt;, &#39;__del__&#39;: &lt;function Car.__del__ at 0x103f1b598&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Car&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Car&#39; objects&gt;} {&#39;_company&#39;: &#39;Ferrari&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;White&#39;, &#39;horsepower&#39;: 400, &#39;price&#39;: 8000}} {&#39;_company&#39;: &#39;Bmw&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}} {&#39;_company&#39;: &#39;Audi&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;Silver&#39;, &#39;horsepower&#39;: 300, &#39;price&#39;: 6000}} . # 인스턴스 네임스페이스 없으면 상위에서 검색 # 즉, 동일한 이름으로 변수 생성 가능(인스턴스 검색 후 -&gt; 상위(클래스 변수, 부모 클래스 변수)) del car2 print(car1.car_count) print(Car.car_count) . 2 2 .",
            "url": "https://jaysung00.github.io/jays_blog/til/2021/10/17/TIL211017.html",
            "relUrl": "/til/2021/10/17/TIL211017.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "파이썬 예제2) 해시 - 완주하지 못한 선수 (Level1)",
            "content": ". Description . 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. . 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. . &#51228;&#54620;&#49324;&#54637; . 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. . &#51077;&#52636;&#47141; &#50696; . participant completion return . [&quot;leo&quot;, &quot;kiki&quot;, &quot;eden&quot;] | [&quot;eden&quot;, &quot;kiki&quot;] | &quot;leo&quot; | . [&quot;marina&quot;, &quot;josipa&quot;, &quot;nikola&quot;, &quot;vinko&quot;, &quot;filipa&quot;] | [&quot;josipa&quot;, &quot;filipa&quot;, &quot;marina&quot;, &quot;nikola&quot;] | &quot;vinko&quot; | . [&quot;mislav&quot;, &quot;stanko&quot;, &quot;mislav&quot;, &quot;ana&quot;] | [&quot;stanko&quot;, &quot;ana&quot;, &quot;mislav&quot;] | &quot;mislav&quot; | . 입출력 예 설명 . 예제 #1 . &quot;leo&quot;는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. . 예제 #2 . &quot;vinko&quot;는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. . 예제 #3 . &quot;mislav&quot;는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. . participant = [&quot;leo&quot;, &quot;kiki&quot;, &quot;eden&quot;] completion = [&quot;eden&quot;, &quot;kiki&quot;] . # 첫번째 시도 def solution(participant, completion): for i in range(len(completion)): participant.remove(completion[i]) answer = participant[0] return answer print(solution(participant, completion)) # 정답은 무사히 나오지만 해시 구조를 사용하지 않았으므로, 효율성 면에서 오답처리 . leo . 해시란? . 해시(hash)란 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 자료구조이다. 이 때 매핑 전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing)라고 한다. . # 풀이 1 # 해시 def solution(participant, completion): hash = {} for i in participant: if i in hash: hash[i] += 1 else: hash[i] = 1 for i in completion: if hash[i] == 1: del hash[i] else: hash[i] -= 1 answer = list(hash.keys())[0] return answer print(solution(participant, completion)) . leo . # 풀이 2 # 데이터의 개수를 셀 때 유용한 파이썬의 collections 모듈의 Counter 클래스 사용 import collections def solution(participant, completion): answer = collections.Counter(participant) - collections.Counter(completion) return list(answer.keys())[0] print(solution(participant, completion)) . leo . # 풀이 3 # 별도의 풀이. 정렬해서 다른 부분에서 찾는 방법 def solution(participant, completion): participant.sort() completion.sort() for i in range(len(completion)): if participant[i] != completion[i]: return participant[i] return participant[len(participant)-1] print(solution(participant, completion)) . [&#39;eden&#39;, &#39;kiki&#39;, &#39;leo&#39;] [&#39;eden&#39;, &#39;kiki&#39;] leo .",
            "url": "https://jaysung00.github.io/jays_blog/python/2021/10/17/PGM_hash1.html",
            "relUrl": "/python/2021/10/17/PGM_hash1.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "파이썬 예제1) A+B",
            "content": ". 문제 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. . 입력 첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10) . 출력 첫째 줄에 A+B를 출력한다. . 예제 입력 1 1 2 예제 출력 1 3 . # 첫번째 시도 a = input() # 1 b = input() # 2 print(a + b) # int 형으로 인식되지 않는다 . 12 . type(a) . str . # 개선1 a = int(input()) b = int(input()) print(a + b) # int형으로 인식되나, 한줄에 입력받지 못함 . ValueError Traceback (most recent call last) &lt;ipython-input-11-625471334fa1&gt; in &lt;module&gt; 1 # 개선1 -&gt; 2 a = int(input()) 3 b = int(input()) 4 5 print(a + b) # int형으로 인식되나, 한줄에 입력받지 못함 ValueError: invalid literal for int() with base 10: &#39;1 2&#39; . # 개선2 a, b = input().split() print(int(a) + int(b)) . 3 . split&#51012; &#51060;&#50857;&#54644;&#49436; &#54620; &#51460;&#47196; &#51077;&#47141;&#48155;&#45716; &#44163;&#51060; &#44032;&#45733;&#54664;&#45796;. . 한 번에 값을 여러 개 입력받으려면 input에서 split을 사용한 변수 여러 개에 저장해주면 된다. . 변수1, 변수2 = input().split() | 변수1, 변수2 = input().split(&#39;기준문자열&#39;) | 변수1, 변수2 = input(&#39;문자열&#39;).split() | 변수1, 변수2 = input(&#39;문자열&#39;).split(&#39;기준문자열&#39;) | . # 개선3 a, b = map(int, input().split()) print(a + b) . 3 . map&#51012; &#51060;&#50857;&#54644;&#49436; &#45908;&#50865; &#44036;&#45800;&#54616;&#44172; . map에 int와 input().split()을 넣으면 split의 결과를 모두 int로 변환해줌 . 변수1, 변수2 = map(int, input().split()) | 변수1, 변수2 = map(int, input().split(&#39;기준문자열&#39;)) | 변수1, 변수2 = map(int, input(&#39;문자열&#39;).split()) | 변수1, 변수2 = map(int, input(&#39;문자열&#39;).split(&#39;기준문자열&#39;)) | .",
            "url": "https://jaysung00.github.io/jays_blog/python/2021/10/16/BOJ1000_A+B.html",
            "relUrl": "/python/2021/10/16/BOJ1000_A+B.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Bayesian Networkとは何か？ ①",
            "content": ". &#12505;&#12452;&#12472;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#65288;BN; Bayesian Network&#65289;&#12392;&#12399;? . 確率変数（RV;Random variables）間の条件付き独立などの関係を見せることにより、RVのfull joint distributionなどを簡潔に表現できるグラフ表記法（Graphical Notation）である。 | . . &#29992;&#35486;&#12398;&#35500;&#26126; . ここで グラフ（Graph） とは、数学においてチャート（Chart）と対照されて定義された nodeとedgeの集合 . | edgeの方向が指定されていればdirected、そうでなければundirected . | グラフの全てのedgeがdirectedの時、directed graph . | directed edgeにおいて、始まる側のノードをparent nodeとし、反対側はchild nodeと言う。 . | つながっている複数のdirected edgeの方向が同じ場合、これをdirected pathとし、directed pathの最初のノードは経路上のすべてのノードのancestor nodeであり、逆に残りのノードは最初のノードのdescendant nodeである。 . | directed pathの開始点と終了点が一致する場合はこれをcyclic、そうでない場合はacyclicと呼ぶ。 . | . . &#12505;&#12540;&#12472;&#12517;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#65288;BN&#65289; &#12398;&#26465;&#20214; . NetworkはNodeと彼らを繋ぐEdgeで構成されている。 . | 方向性の非循環グラフ（DAG; Directed Acyclic Graph）である。 . | 個別のNodeはRVである$X$に対して$ bf P(X | Paranets(X))$を意味する。 . | 個別のEdgeとは親が子供に与える直接的な影響（Direct Influence） を意味する。 . | . . . &#12414;&#12378;&#30906;&#29575;&#12395;&#38306;&#12377;&#12427;&#31777;&#21336;&#12394;&#24489;&#32722;&#12363;&#12425; . ベージュアンネットワークというものは結局確率変数（RV）間の関係を表現したものである。 | 確率というのは相対的な頻度である。 | . . 独立性 （Independence） . $P(A|B) = P(A)$ $ Leftrightarrow P(A,B) = P(A)P(B)$ $ Leftrightarrow P(B|A) = P(B) $; A とB が独立ならば、B はA と独立である。 . 事象Bが発生したという情報は、事象Aが発生する確率に追加的な情報を提供しない。 . | これは、下述のConditional Independence と対立する意味で Marginal Independence と言える。 . | . | . . 条件付き独立（Conditional Independence） . $P(A|B,C) = P(A|C)$ . 事象Cが与えられたときに二つの事象AとBが独立なら、これはCという条件の下で条件付き独立 である。 | . | . . 条件付き確率（Conditional Probability） . $P(A= true|B=true)$ . &quot;Probablity of A given B&quot; . | Bが与えられた時、Aの確率 . | . | . 結合確率（joint Probability） . $P(A= true, B=true)$ . &quot;the probability of A=true and B=true&quot; . | A=trueとB=trueが同時に満足できる確率 . | 条件付き確率と結合確率の関係は一般に、$P(X|Y) = cfrac{P(X,Y)}{P(Y)}$ . | . | . 総確率法則（Law of Total Probability） . &quot;Summing out&quot; or &quot;Marginalization&quot; . | $P(A) = sum_kP(A,B_k) = sum_kP(A|B_k)P(B_k)$ . $P(A) = sum_kP(A,B_k)$は$B_1,B_2,...,B_n$がそれぞれ相互背反的な集合であり、これらの和集合が全体集合となるので成立（marginalize） . | $ sum_kP(A,B_k) = sum_kP(A|B_k)P(B_k)$は条件付き確率と結合確率の関係を利用すると誘導可能 . | . | これによる利点は、$P(A)$を直接求めるより、$P(A|B_k)$のような条件付き確率を求めて合わせることが一般的により容易であることである。 . | あるいは結合確率を知っている時、様々な確率が計算できる。 . 例えば、結合確率である$P(a,b,c,d)$を知っているとき、$P(c|b)$は以下のように表せる。 . | $P(c|b) = sum_a sum_d P(a,c,d|b) = cfrac{1}{P(b)} sum_a sum_d { bf P(a,b,c,d)}$ . | しかし、jointの場合にはparameterの数がexponentialに増えることになる！ （Chain Ruleの必要性） . | . | . . 確率の連鎖法則（Chain Rule for probability） . 全てのjoint distribution について、結合確率と条件付き確率の関係により常に以下のように表せる。 . | $P(a,b,c,...,z) = P(a|b,c,...,z)P(b,c,....,z)$ . | これを繰り返すと、$P(a,b,c,...,z) = P(a|b,c,...,z)P(b|c,...,z)P(c|d,...,z)...P(z)$で表現可能（Factorization） . | . . 乗分解法則（Rule of product decomposition） . Bayesian Networkでは、グラフに属するRVの結合分布（joint distribution）は、familyのすべての条件付き分布$P(Child|Parent)$の乗$^{[*1]}$で表現できる。 （次のポストのFactorization of Bayes Networkの内容を参照されたい） . | $P(x_1,x_2,...,x_n) = prod _iP(x_i|Parents(x_i))$ （Parentsは直接的に接続されて影響を受ける変数だけを意味） . 例えば、$X rightarrow Y rightarrow Z$ のグラフで$P(X=x,Y=y,Z=z)$を求めることを考えてみよう . | 本来は可能なすべての組み合わせの$(x, y, z)$に該当する確率テーブルを作らなければならない . | しかし、この法則を利用すると$P(X=x,Y=y,Z=z) = P(X=x)P(Y=y|X=x)P(Z=z|Y=y)$で簡潔に表現可能 . | このように高次元を低次元にすることで次元の呪い（curse of dimensionality）からも比較的自由になることができる。 . | . | . . $^{[*1]}:$ このように表現可能な理由は、後述するベイジアンネットワークのTypical Local Structures Rules に関連している。 . . &#12505;&#12452;&#12472;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;Rules of Typical Local Structures . . Rule 1. 鎖または滝型（Chain or Cascading） . . 変数$X$と変数$Y$の間で一つの方向性経路だけがあって変数$Z$が当該経路を塞いでいるとき、$Z$が条件付きで与えられると、二つの変数$X$と$Y$は条件付き独立 である。 . | $X perp Y|Z$ $ Leftrightarrow P(Y|X,Z) = P(Y|Z)$ . | . . Rule 2. 分岐あるいは共通の親型（Fork or Common parent） . . 変数$Z$が$X$と$Y$の共通原因で、$X$と$Y$の間にたった一つの経路があるとき、$Z$の条件が与えられると、$X$と$Y$は条件付き独立 である。 . | $X perp Y|Z$ $ Leftrightarrow P(X,Y|Z) = P(X|Z)P(Y|Z)$ . | . . Rule 3.衝突部あるいはV-構造(Collider or V-structure) . . 変数$Z$が二つの変数$X$と$Y$の間の衝突ノードで、$X$と$Y$の間でたった一つの経路だけあるとき、$X$と$Y$は非条件付き独立（underconditionally independent） である。しかし、$Z$または$Z$のdescendantを条件付きにした場合、$X$と$Y$は従属となる可能性 がある。 . | $ sim (X perp Y|Z)$ $ Leftrightarrow P(X,Y,Z)=P(X)P(Y)P(Z|X,Y)$ . | つまり$Z$が not given の時は独立だが、逆に$Z$がgivenで与えられれば$X$、$Y$が従属となる可能性が生じてしまう。 . | . . . Bayes Ball Algorithm . 目的：$X perp Y | Z$（$Z$がgivenの場合、$X$と$Y$が独立）が成立するかどうかを判定するためのアルゴリズム . | $X$からボールが出発すると仮定した時、 $Y$までボールが到達するかを確認する方法 . | ここでボールはInformationを意味し、矢印はボールの動きを意味する。ノード間が直接的なedgeで結ばれていなくても、ボールが転がって到達できるならIndirect influenceが存在するため、2つの変数はdepedentであることを意味する。 . | . . Rule 1の場合 . (1) $Z$がgivenでない時、ボールは通ることができる。 ($X, Y$は従属) . . (2) $Z$が given の時、ボールは通れない。 ($X perp Y|Z$) . . . Rule 2の場合 . (1) $Z$がgivenでない時、ボールは通ることができる。 ($X, Y$は従属) . . (2) $Z$が given の時、ボールは通れない。 ($X perp Y|Z$) . . . Rule 3の場合 . (1) $Z$が givenでない時、ボールは通れない。 ($ bf X perp Y$) . . (2) $X_C$がgivenであるとき、逆にpathができてボールが通ることができるようになる。 ($X, Y$は従属 $|Z$) . . . . Bayes Ball Algorithm&#12398;&#20363;&#38988; . . 問題 1. $X_1 perp X_4|X_2$ . 二つの経路でボールを転がすことができる。 . (1) $X_1 rightarrow{ bf X_2} (given) rightarrow X_4$の経路は$X_2$が鎖のgivenで塞がれているので通ることができない。 . (2) $X_1 rightarrow X_3 rightarrow X_5 rightarrow X_6 leftarrow{ bf X_2}(given) rightarrow X_4$の経路は$X_6$が衝突部のnot givenで塞がれているので通ることができない。 . 従って、いかなる経路でもボールは通れないので$X_2$がgivenのとき$X_1$と$X_4$は独立 である。 . | . . 問題 2. $X_2 perp X_5|X_1$ | . 二つの経路でボールを転がすことができる。 . (1) $X_2 rightarrow X_6 leftarrow X_5$ の経路は$X_6$が衝突部のnot givenで塞がれているので通れない。 . (2) $X_2 leftarrow{ bf X_1}(given) rightarrow X_3 rightarrow X_5$の経路は$X_1$が分岐のdivenで塞がれているので通れない。 . 従って、どんな経路でもボールは通れないので$X_1$がgivenのとき$X_2$と$X_5$は独立 である。 . . 問題 3. $X_1 perp X_6| {X_2, X_3 } $ | . 二つの経路でボールを転がすことができる。 . (1) $X_1 rightarrow{ bf X_2}(given) rightarrow X_6$の経路は$X_2$が鎖のgivenで塞がれているので通ることができない。 . (2) $X_1 rightarrow{ bf X_3}(given) rightarrow X_5 rightarrow X_6$の経路は$X_3$が鎖のgivenで塞がれているので通れない。 . 従って、いかなる経路でもボールは通れないので、$ {X_2, X_3 }$がgivenのとき$X_1$と$X_6$は独立 である。 . . 問題 4. $X_2 perp X_3| {X_1, X_6 } $ | . 二つの経路でボールを転がすことができる。 . (1) $X_2 leftarrow{ bf X_1}(given) rightarrow X_3$ の経路は$X_1$が分岐のgivenで塞がれているので通れない。 . (2) $X_2 rightarrow{ bf X_6}(given) leftarrow X_5 leftarrow X_3$の経路は$X_6$が衝突部のgivenで開いているので通ることができる。 . 従って、二番目のパスでボールは通過できるので、$ {X_1, X_6 }$がgivenのとき$X_2$と$X_3$は独立が成立しない。 . . . $d$-Seperation&#12398;&#23450;&#32681; . $d$は方向性（directly）を意味する。 . | Bayesian Ball Algorithmで$d$-Seperationかどうかを確認することができる。 . | 整理すると、パスpが条件付き集合 $ {W }$により$d$-Seperateされるという命題は以下と必要十分条件である。 . 1.経路pは条件付き集合 $ {W }$に属する中間ノード$Z$の鎖$X rightarrow Z rightarrow Y$または分岐$X leftarrow Z rightarrow Y$を含む。 . 2.経路pは条件付き集合 $ {W }$に属さない中間ノード$Z&#39;$の衝突部$X rightarrow Z&#39; leftarrow Y$を含む。 . | . . . Additional reference . [1] Judea Pearl, Madelyn Glymour, Nicholas P. Jewell (2016). Causal Inference in Statistics: A Primer . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/bayesian_network/2021/02/08/Bayesian-Network-1.html",
            "relUrl": "/bayesian_network/2021/02/08/Bayesian-Network-1.html",
            "date": " • Feb 8, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Market Basket Analysis in Python ①",
            "content": ". &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12392;&#12399;&#65311; . バスケット分析によって以下のようなことができる。 . 1. &#20341;&#22770;&#20998;&#26512; . 一回の買い物でよく一緒に買われるものは何か？ . 2. &#20341;&#22770;&#20998;&#26512;&#12395;&#22522;&#12389;&#12356;&#12390;&#26377;&#29992;&#12394;&#25512;&#22888;&#20107;&#38917;&#12398;&#25552;&#20379; . e.g. ・棚の近くに置くべき商品カテゴリー ・棚の遠くに置くべき商品カテゴリー など . . &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12398;&#20351;&#29992;&#20363; . e.g. ・Netflixスタイルの推奨エンジン ・eコマースにおける商品推奨の改善 ・小売店でのクロスセル（Cross-sell$^{[*1]}$）製品 ・在庫管理の改善 ・アップセル（Up-sell$^{[*2]}$）するアイテム選択　など . . $^{[*1]}$ Cross-sell : 顧客が購買する、あるいはすでに利用している製品・サービスに関連するものを販売していくこと $^{[*2]}$ Up-sell : 顧客が検討しているものよりランクの高い製品・サービスの販売をすること&lt;/p&gt; &lt;/span&gt; . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; . &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12398;&#26041;&#27861; . Association Rule によって構成される . ・{A} $ rightarrow$ {B} . 「Aを買うと、Bを買う」という意味 . . (&#23455;&#35013;) &#12463;&#12525;&#12523;&#12475;&#12523;&#35069;&#21697;&#36984;&#25246; . 小売店ではガムをコーヒーかシリアルかパンかどれかとクロスセルしようとしている。 . ・{coffee} $ rightarrow$ {gum} ・{cereal} $ rightarrow$ {gum} ・{bread} $ rightarrow$ {gum} のうち、最も関係性が強いものを選びたい。 . . transactionsは [&#39;coffee&#39;,&#39;gum&#39;] &amp; [&#39;cereal&#39;,&#39;gum&#39;] &amp; [&#39;bread&#39;,&#39;gum&#39;] の３つのペアからなっている。 . # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np transactions = pd.read_csv(&#39;./dataset/transactions.csv&#39;, header=None) transactions . 0 1 . 0 bread | gum | . 1 bread | gum | . 2 cereal | gum | . 3 coffee | gum | . 4 bread | gum | . ... ... | ... | . 80 bread | gum | . 81 coffee | gum | . 82 bread | gum | . 83 coffee | gum | . 84 coffee | gum | . 85 rows × 2 columns . 各ペアの数をカウントする . # Count the number of transactions with coffee and gum coffee = transactions[(transactions[0] == &#39;coffee&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Count the number of transactions with cereal and gum cereal = transactions[(transactions[0] == &#39;cereal&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Count the number of transactions with bread and gum bread = transactions[(transactions[0] == &#39;bread&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Print the counts for each transaction. print(&#39;coffee:&#39;, len(coffee)) print(&#39;cereal:&#39;, len(cereal)) print(&#39;bread:&#39;, len(bread)) . coffee: 40 cereal: 25 bread: 20 . . Association Rules&#12398;&#20840;&#12390;&#12398;&#20505;&#35036;&#12434;&#30906;&#35469;&#12377;&#12427; . &#12487;&#12540;&#12479;&#12398;&#28310;&#20633; . 小売店の併売データを読み込む . # Load transactions from pandas groceries = pd.read_csv(&#39;./dataset/small_grocery_store.csv&#39;) # Split transaction strings into lists transactions = groceries[&#39;Transaction&#39;].apply(lambda t: t.split(&#39;,&#39;)) # Convert DataFrame column into list of strings transactions = list(transactions) # Print the list of transactions print(transactions) . [[&#39;milk&#39;, &#39;bread&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;milk&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;tea&#39;], [&#39;jam&#39;, &#39;bread&#39;, &#39;milk&#39;], [&#39;tea&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;tea&#39;], [&#39;tea&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;tea&#39;, &#39;biscuit&#39;], [&#39;jam&#39;, &#39;bread&#39;, &#39;tea&#39;], [&#39;bread&#39;, &#39;milk&#39;], [&#39;coffee&#39;, &#39;orange&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;coffee&#39;, &#39;orange&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;coffee&#39;, &#39;sugar&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;orange&#39;], [&#39;bread&#39;, &#39;sugar&#39;, &#39;biscuit&#39;], [&#39;coffee&#39;, &#39;sugar&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;sugar&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;sugar&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;sugar&#39;], [&#39;tea&#39;, &#39;milk&#39;, &#39;coffee&#39;, &#39;cereal&#39;]] . Association rules&#12398;&#29983;&#25104; . ９つの食料品のリストを抽出し、すべての可能な単独原因単独結果の組み合わせ（Association rules）をitertoolsを使って生成する . # Import permutations from the itertools module from itertools import permutations # Define the set of groceries flattened = [i for t in transactions for i in t] groceries = list(set(flattened)) # Generate all possible rules rules = list(permutations(groceries, 2)) # Print the set of rules print(rules) # Print the number of rules print(&#39; n&#39;) print(len(rules),&quot;通り&quot;) . [(&#39;jam&#39;, &#39;cereal&#39;), (&#39;jam&#39;, &#39;sugar&#39;), (&#39;jam&#39;, &#39;tea&#39;), (&#39;jam&#39;, &#39;orange&#39;), (&#39;jam&#39;, &#39;bread&#39;), (&#39;jam&#39;, &#39;milk&#39;), (&#39;jam&#39;, &#39;coffee&#39;), (&#39;jam&#39;, &#39;biscuit&#39;), (&#39;cereal&#39;, &#39;jam&#39;), (&#39;cereal&#39;, &#39;sugar&#39;), (&#39;cereal&#39;, &#39;tea&#39;), (&#39;cereal&#39;, &#39;orange&#39;), (&#39;cereal&#39;, &#39;bread&#39;), (&#39;cereal&#39;, &#39;milk&#39;), (&#39;cereal&#39;, &#39;coffee&#39;), (&#39;cereal&#39;, &#39;biscuit&#39;), (&#39;sugar&#39;, &#39;jam&#39;), (&#39;sugar&#39;, &#39;cereal&#39;), (&#39;sugar&#39;, &#39;tea&#39;), (&#39;sugar&#39;, &#39;orange&#39;), (&#39;sugar&#39;, &#39;bread&#39;), (&#39;sugar&#39;, &#39;milk&#39;), (&#39;sugar&#39;, &#39;coffee&#39;), (&#39;sugar&#39;, &#39;biscuit&#39;), (&#39;tea&#39;, &#39;jam&#39;), (&#39;tea&#39;, &#39;cereal&#39;), (&#39;tea&#39;, &#39;sugar&#39;), (&#39;tea&#39;, &#39;orange&#39;), (&#39;tea&#39;, &#39;bread&#39;), (&#39;tea&#39;, &#39;milk&#39;), (&#39;tea&#39;, &#39;coffee&#39;), (&#39;tea&#39;, &#39;biscuit&#39;), (&#39;orange&#39;, &#39;jam&#39;), (&#39;orange&#39;, &#39;cereal&#39;), (&#39;orange&#39;, &#39;sugar&#39;), (&#39;orange&#39;, &#39;tea&#39;), (&#39;orange&#39;, &#39;bread&#39;), (&#39;orange&#39;, &#39;milk&#39;), (&#39;orange&#39;, &#39;coffee&#39;), (&#39;orange&#39;, &#39;biscuit&#39;), (&#39;bread&#39;, &#39;jam&#39;), (&#39;bread&#39;, &#39;cereal&#39;), (&#39;bread&#39;, &#39;sugar&#39;), (&#39;bread&#39;, &#39;tea&#39;), (&#39;bread&#39;, &#39;orange&#39;), (&#39;bread&#39;, &#39;milk&#39;), (&#39;bread&#39;, &#39;coffee&#39;), (&#39;bread&#39;, &#39;biscuit&#39;), (&#39;milk&#39;, &#39;jam&#39;), (&#39;milk&#39;, &#39;cereal&#39;), (&#39;milk&#39;, &#39;sugar&#39;), (&#39;milk&#39;, &#39;tea&#39;), (&#39;milk&#39;, &#39;orange&#39;), (&#39;milk&#39;, &#39;bread&#39;), (&#39;milk&#39;, &#39;coffee&#39;), (&#39;milk&#39;, &#39;biscuit&#39;), (&#39;coffee&#39;, &#39;jam&#39;), (&#39;coffee&#39;, &#39;cereal&#39;), (&#39;coffee&#39;, &#39;sugar&#39;), (&#39;coffee&#39;, &#39;tea&#39;), (&#39;coffee&#39;, &#39;orange&#39;), (&#39;coffee&#39;, &#39;bread&#39;), (&#39;coffee&#39;, &#39;milk&#39;), (&#39;coffee&#39;, &#39;biscuit&#39;), (&#39;biscuit&#39;, &#39;jam&#39;), (&#39;biscuit&#39;, &#39;cereal&#39;), (&#39;biscuit&#39;, &#39;sugar&#39;), (&#39;biscuit&#39;, &#39;tea&#39;), (&#39;biscuit&#39;, &#39;orange&#39;), (&#39;biscuit&#39;, &#39;bread&#39;), (&#39;biscuit&#39;, &#39;milk&#39;), (&#39;biscuit&#39;, &#39;coffee&#39;)] 72 通り . . Metric &amp; Pruning . 全ての可能な組み合わせを候補として置くのは、かなり時間とコストがかかる。 そのため、有用な規則だけに絞りたい。 → Metric &amp; Pruning Process . ①Metric : Association rulesにスコアを割り当て . ②Pruning : 特定の基準に従い、基準に満たさないRulesを放棄する . One-hot encoding transaction data . # Import the transaction encoder function from mlxtend from mlxtend.preprocessing import TransactionEncoder # Instantiate transaction encoder and identify unique items encoder = TransactionEncoder().fit(transactions) # One-hot encode transactions onehot = encoder.transform(transactions) # Convert one-hot encoded data to DataFrame onehot = pd.DataFrame(onehot, columns = encoder.columns_) # Print the one-hot encoded transaction dataset print(onehot) . biscuit bread cereal coffee jam milk orange sugar tea 0 True True False False False True False False False 1 True True True False False True False False False 2 False True False False False False False False True 3 False True False False True True False False False 4 True False False False False False False False True 5 False True False False False False False False True 6 False False True False False False False False True 7 True True False False False False False False True 8 False True False False True False False False True 9 False True False False False True False False False 10 True False True True False False True False False 11 True False True True False False True False False 12 False False False True False False False True False 13 False True False True False False True False False 14 True True False False False False False True False 15 False False True True False False False True False 16 True True False False False False False True False 17 False True False True False False False True False 18 False True False True False False False True False 19 False False True True False True False False True . # Compute the support support = onehot.mean() # Print the support print(support) . biscuit 0.40 bread 0.65 cereal 0.30 coffee 0.40 jam 0.10 milk 0.25 orange 0.15 sugar 0.30 tea 0.35 dtype: float64 . # Add a jam+bread column to the DataFrame onehot onehot[&#39;jam+bread&#39;] = np.logical_and(onehot[&#39;jam&#39;], onehot[&#39;bread&#39;]) # Compute the support support = onehot.mean() # Print the support values print(support) . biscuit 0.40 bread 0.65 cereal 0.30 coffee 0.40 jam 0.10 milk 0.25 orange 0.15 sugar 0.30 tea 0.35 jam+bread 0.10 dtype: float64 . . Additional Reference JMR生活総合研究所. アップセリング（Up-selling）、クロスセリング（Cross-selling）. マーケティング用語集. https://www.jmrlsi.co.jp/knowledge/yougo/my06/my0618.html . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] . &lt;/div&gt; .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/08/Basket-analysis-1.html",
            "relUrl": "/datacamp/2021/02/08/Basket-analysis-1.html",
            "date": " • Feb 8, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "Analyzing Marketing Campaigns with pandas ④",
            "content": ". A/B&#12486;&#12473;&#12488;&#12392;&#12399; . どのバリアントのパフォーマンスが優れているかを評価するランダム化実験 | . A/B&#12486;&#12473;&#12488;&#12434;&#34892;&#12358;&#26178;&#12398;&#27880;&#24847;&#20107;&#38917; . 明確なコントロールが必要 | テストを行う前にKPI（Key Performance Index）を設定 | ポジティブな結果を見つけようと、成功を再定義することは望ましくない | KPIを事前に文書化することで、テストの成功を明確に保つことができる | . . # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . &#12486;&#12473;&#12488;&#12398;&#21106;&#12426;&#24403;&#12390; . このデータは実際A/Bテストが行われている。variant列がpersonlizationかcontrolかによって割り当てされている。 . 以下のコードではmarketing_channelがEmailであるデータの中でA/Bテストの結果を分析する。 . email = marketing[marketing[&#39;marketing_channel&#39;] == &#39;Email&#39;] # Group the email DataFrame by variant alloc = email.groupby([&#39;variant&#39;])[&#39;user_id&#39;].nunique() # Plot a bar chart of the test allocation alloc.plot(kind=&#39;bar&#39;) plt.title(&#39;Personalization test allocation&#39;) plt.ylabel(&#39;# participants&#39;) plt.show() . Personalizaiton&#12464;&#12523;&#12540;&#12503;&#12392;Control&#12464;&#12523;&#12540;&#12503;&#12398;&#36578;&#25563;&#29575;&#12398;&#24179;&#22343;&#35336;&#31639; . subscribers = email.groupby([&#39;user_id&#39;, &#39;variant&#39;])[&#39;converted&#39;].max() subscribers_df = pd.DataFrame(subscribers.unstack(level=1)) # Drop missing values from the control column control = subscribers_df[&#39;control&#39;].dropna() # Drop missing values from the personalization column personalization = subscribers_df[&#39;personalization&#39;].dropna() print(&#39;Control conversion rate:&#39;, np.mean(control)) print(&#39;Personalization conversion rate:&#39;, np.mean(personalization)) . Control conversion rate: 0.2814814814814815 Personalization conversion rate: 0.3908450704225352 . Lift&#20516;&#12398;&#35336;&#31639; . $Lift = cfrac{Treatment space conversion space rate space - space Control space conversion space rate}{Control space conversion space rate}$ . # Lift関数の定義 def lift(control, treat): # Calcuate the mean of control and treatment control_mean = np.mean(control) treat_mean = np.mean(treat) # Calculate the lift using control_mean and treat_mean lift = (treat_mean-control_mean)/control_mean return str(round(lift*100, 2)) + &#39;%&#39; # Print lift() with control and personalization as inputs print(lift(control, personalization)) . 38.85% . A/B&#12486;&#12473;&#12488;&amp;&#12475;&#12464;&#12513;&#12531;&#12486;&#12540;&#12471;&#12519;&#12531;&amp;T-test &#38306;&#25968; . E-mailのマーケッティングの実績における別の特徴（セグメント）ごとにLift値＆T-test（統計的有意性）を計算する関数 . from scipy import stats . def ab_segmentation(segment): # Build a for loop for each segment in marketing for subsegment in np.unique(marketing[segment].values): print(subsegment) # Limit marketing to email and subsegment email = marketing[(marketing[&#39;marketing_channel&#39;] == &#39;Email&#39;) &amp; (marketing[segment] == subsegment)] subscribers = email.groupby([&#39;user_id&#39;, &#39;variant&#39;])[&#39;converted&#39;].max() subscribers = pd.DataFrame(subscribers.unstack(level=1)) control = subscribers[&#39;control&#39;].dropna() personalization = subscribers[&#39;personalization&#39;].dropna() print(&#39;lift:&#39;, lift(control, personalization)) print(&#39;t-statistic:&#39;, stats.ttest_ind(control, personalization), &#39; n n&#39;) . ab_segmentation(&#39;language_displayed&#39;) . Arabic lift: 50.0% t-statistic: Ttest_indResult(statistic=-0.5773502691896255, pvalue=0.5795840000000001) English lift: 39.0% t-statistic: Ttest_indResult(statistic=-2.2183598646203166, pvalue=0.026991701290720815) German lift: -1.62% t-statistic: Ttest_indResult(statistic=0.1910083418078718, pvalue=0.8494394170062678) Spanish lift: 166.67% t-statistic: Ttest_indResult(statistic=-2.3570226039551585, pvalue=0.040156718110477524) . ab_segmentation(&#39;age_group&#39;) . 0-18 years lift: 121.4% t-statistic: Ttest_indResult(statistic=-2.966044912142211, pvalue=0.0038724494391297226) 19-24 years lift: 106.24% t-statistic: Ttest_indResult(statistic=-3.03179438478667, pvalue=0.0030623836114689134) 24-30 years lift: 161.19% t-statistic: Ttest_indResult(statistic=-3.861539544326876, pvalue=0.00018743381094867337) 30-36 years lift: -100.0% t-statistic: Ttest_indResult(statistic=3.1859064644147996, pvalue=0.0023238487431765137) 36-45 years lift: -85.23% t-statistic: Ttest_indResult(statistic=2.4317901279318503, pvalue=0.01797568600978829) 45-55 years lift: -72.22% t-statistic: Ttest_indResult(statistic=2.065499127317933, pvalue=0.043062339688201196) 55+ years lift: -100.0% t-statistic: Ttest_indResult(statistic=3.3265654564203397, pvalue=0.0016358623456360435) . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/04/Marketing-4.html",
            "relUrl": "/datacamp/2021/02/04/Marketing-4.html",
            "date": " • Feb 4, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Analyzing Marketing Campaigns with pandas ③",
            "content": ". # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np . marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . . &#36578;&#25563;&#29575;&#12434;&#27714;&#12417;&#12427;&#38306;&#25968;&#12398;&#20316;&#25104; . def conversion_rate(dataframe, column_names): # Total number of converted users column_conv = dataframe[dataframe[&#39;converted&#39;] == True] .groupby(column_names)[&#39;user_id&#39;].nunique() # Total number users column_total = dataframe.groupby(column_names)[&#39;user_id&#39;].nunique() # Conversion rate conversion_rate = column_conv/column_total # Fill missing values with 0 conversion_rate = conversion_rate.fillna(0) return conversion_rate . age_group_conv = conversion_rate(marketing, [&#39;date_served&#39;, &#39;age_group&#39;]) # Unstack and create a DataFrame age_group_df = pd.DataFrame(age_group_conv.unstack(level = 1)) # Visualize conversion by age_group age_group_df.plot() plt.title(&#39;Conversion rate by age group n&#39;, size = 16) plt.ylabel(&#39;Conversion rate&#39;, size = 14) plt.xlabel(&#39;Age group&#39;, size = 14) plt.show() . 別々にプロットする関数を作成してみよう。 . def plotting_conv(dataframe): for column in dataframe: # Plot column by dataframe&#39;s index plt.plot(dataframe.index, dataframe[column]) plt.title(&#39;Daily &#39; + str(column) + &#39; conversion rate n&#39;, size = 16) plt.ylabel(&#39;Conversion rate&#39;, size = 14) plt.xlabel(&#39;Date&#39;, size = 14) plt.xticks(rotation = 45) # Show plot plt.show() plt.clf() . age_group_conv = conversion_rate(marketing, [&#39;date_served&#39;, &#39;age_group&#39;]) # Unstack age_group_conv and create a DataFrame age_group_df = pd.DataFrame(age_group_conv.unstack(level=1)) # Plot the results plotting_conv(age_group_df) . &lt;Figure size 432x288 with 0 Axes&gt; . . &#21839;&#38988;&#30330;&#35211;&#12363;&#12425;&#28508;&#22312;&#30340;&#21407;&#22240;&#12434;&#32771;&#12360;&#12427; . &#21839;&#38988;&#30330;&#35211;&#12398;&#20363; . daily_conv_channel = conversion_rate(marketing, [&#39;date_served&#39;, &#39;marketing_channel&#39;]) # Unstack daily_conv_channel and convert it to a DataFrame daily_conv_channel = pd.DataFrame(daily_conv_channel.unstack(level = 1)) # Plot results of daily_conv_channel plotting_conv(daily_conv_channel) . &lt;Figure size 432x288 with 0 Axes&gt; . House Adsのチャネルで広告を打ったとき、1月11日頃から転換率が急に落ちている。 | . &#28508;&#22312;&#30340;&#12394;&#21407;&#22240;&#12434;&#25506;&#12377; . ① チャネルごとの曜日別転換率の差を見る . marketing[&#39;DoW_served&#39;] = marketing[&#39;date_served&#39;].dt.dayofweek # Calculate conversion rate by day of week DoW_conversion = conversion_rate(marketing, [&#39;DoW_served&#39;, &#39;marketing_channel&#39;]) # Unstack channels DoW_df = pd.DataFrame(DoW_conversion.unstack(level=1)) # Plot conversion rate by day of week DoW_df.plot() plt.title(&#39;Conversion rate by day of week n&#39;) plt.ylim(0) plt.show() . 【結果】特に関係性が見られない。 . ②House Adsチャネルのうち、広告表示言語ごとに日別転換率を計算 . house_ads = marketing[marketing[&#39;marketing_channel&#39;] == &#39;House Ads&#39;] # Calculate conversion by date served and language displayed conv_lang_channel = conversion_rate(house_ads, [&#39;date_served&#39;, &#39;language_displayed&#39;]) # Unstack conv_lang_channel conv_lang_df = pd.DataFrame(conv_lang_channel.unstack(level=1)) # Use plotting function to display results plotting_conv(conv_lang_df) . &lt;Figure size 432x288 with 0 Axes&gt; . 【結果】ほとんどの言語で1月11日以降転換率が落ちている。 . ③ユーザーの使用言語と広告の表示言語がどれだけ一致しているかを日別に見る . house_ads[&#39;is_correct_lang&#39;] = np.where( house_ads[&#39;language_preferred&#39;] == house_ads[&#39;language_displayed&#39;], &#39;Yes&#39;, &#39;No&#39;) # Groupby date_served and is_correct_lang language_check = house_ads.groupby([&#39;date_served&#39;,&#39;is_correct_lang&#39;])[&#39;is_correct_lang&#39;].count() # Unstack language_check and fill missing values with 0&#39;s language_check_df = pd.DataFrame(language_check.unstack(level=1)).fillna(0) # Print results print(language_check_df) . is_correct_lang No Yes date_served 2018-01-01 2.0 189.0 2018-01-02 3.0 247.0 2018-01-03 0.0 220.0 2018-01-04 0.0 168.0 2018-01-05 0.0 160.0 2018-01-06 1.0 151.0 2018-01-07 2.0 130.0 2018-01-08 0.0 154.0 2018-01-09 0.0 157.0 2018-01-10 0.0 170.0 2018-01-11 20.0 135.0 2018-01-12 18.0 130.0 2018-01-13 26.0 122.0 2018-01-14 20.0 131.0 2018-01-15 16.0 192.0 2018-01-16 28.0 127.0 2018-01-17 21.0 127.0 2018-01-18 31.0 121.0 2018-01-19 22.0 127.0 2018-01-20 28.0 124.0 2018-01-21 14.0 100.0 2018-01-22 13.0 72.0 2018-01-23 16.0 69.0 2018-01-24 13.0 83.0 2018-01-25 19.0 74.0 2018-01-26 24.0 92.0 2018-01-27 18.0 149.0 2018-01-28 28.0 136.0 2018-01-29 24.0 142.0 2018-01-30 23.0 145.0 2018-01-31 23.0 135.0 . /Users/sungminje/opt/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:5: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34; . language_check_df[&#39;pct&#39;] = language_check_df[&#39;Yes&#39;]/language_check_df.sum(axis=1) # Plot and show your results plt.plot(language_check_df.index.values, language_check_df[&#39;pct&#39;]) plt.xticks(rotation = 45) plt.show() . 【結果】1月11日以降間違った言語で送られたHouse Adsの広告が多いことが分かった。 →おそらく、このHouse Adsのバグによって転換率が低下した。 . &#12496;&#12464;&#12364;&#12394;&#12363;&#12387;&#12383;&#22580;&#21512;&#12434;&#20104;&#28204;&#12377;&#12427; . house_ads_bug = house_ads[house_ads[&#39;date_served&#39;] &lt; &#39;2018-01-11&#39;] lang_conv = conversion_rate(house_ads_bug, [&#39;language_displayed&#39;]) # Index other language conversion rate against English spanish_index = lang_conv[&#39;Spanish&#39;]/lang_conv[&#39;English&#39;] arabic_index = lang_conv[&#39;Arabic&#39;]/lang_conv[&#39;English&#39;] german_index = lang_conv[&#39;German&#39;]/lang_conv[&#39;English&#39;] print(&quot;Spanish index:&quot;, spanish_index) print(&quot;Arabic index:&quot;, arabic_index) print(&quot;German index:&quot;, german_index) . Spanish index: 1.681924882629108 Arabic index: 5.045774647887324 German index: 4.485133020344287 . converted = house_ads.groupby([&#39;date_served&#39;, &#39;language_preferred&#39;]) .agg({&#39;user_id&#39;:&#39;nunique&#39;, &#39;converted&#39;:&#39;sum&#39;}) # Unstack converted converted_df = pd.DataFrame(converted.unstack(level=1)) . converted_df[&#39;english_conv_rate&#39;] = converted_df.loc[&#39;2018-01-11&#39;:&#39;2018-01-31&#39;][(&#39;converted&#39;,&#39;English&#39;)] # Create expected conversion rates for each language converted_df[&#39;expected_spanish_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*spanish_index converted_df[&#39;expected_arabic_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*arabic_index converted_df[&#39;expected_german_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*german_index # Multiply number of users by the expected conversion rate converted_df[&#39;expected_spanish_conv&#39;] = converted_df[&#39;expected_spanish_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;Spanish&#39;)] converted_df[&#39;expected_arabic_conv&#39;] = converted_df[&#39;expected_arabic_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;Arabic&#39;)] converted_df[&#39;expected_german_conv&#39;] = converted_df[&#39;expected_german_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;German&#39;)] . converted_df = converted_df.loc[&#39;2018-01-11&#39;:&#39;2018-01-31&#39;] # Sum expected subscribers for each language expected_subs = converted_df[&#39;expected_spanish_conv&#39;].sum() + converted_df[&#39;expected_arabic_conv&#39;].sum() + converted_df[&#39;expected_german_conv&#39;].sum() # Calculate how many subscribers we actually got actual_subs = converted_df[(&#39;converted&#39;,&#39;Spanish&#39;)].sum() + converted_df[(&#39;converted&#39;,&#39;Arabic&#39;)].sum() + converted_df[(&#39;converted&#39;,&#39;German&#39;)].sum() # Subtract how many subscribers we got despite the bug lost_subs = expected_subs - actual_subs print(lost_subs) . 32.144143192488265 . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev]　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/03/Marketing-3.html",
            "relUrl": "/datacamp/2021/02/03/Marketing-3.html",
            "date": " • Feb 3, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Analyzing Marketing Campaigns with pandas ②",
            "content": ". # import data import pandas as pd marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) . marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . . &#12461;&#12515;&#12531;&#12506;&#12540;&#12531;&#12399;&#25104;&#21151;&#12375;&#12383;&#12398;&#12363;&#65311; . これを評価するために、いくつかの指標が使われる。 . 転換率（Conversion rate） | 保持率（Retention rate） | . etc. . &#36578;&#25563;&#29575;&#65288;Conversion rate&#65289;&#12434;&#27714;&#12417;&#12427; . $Conversion space rate = cfrac{Number space of space people space who space convert}{Total space number space of space people space we space marketed space to} $ . # すべての顧客を求める。(Total number of people we marketed to) total = marketing[&#39;user_id&#39;].nunique() # 転換した顧客を求める。(Number of people who converted) subscribers = marketing[marketing[&quot;converted&quot;] == True][&#39;user_id&#39;].nunique() # 転換率を計算する。 conversion_rate = subscribers/total print(round(conversion_rate*100, 2), &quot;%&quot;) . 13.89 % . &#20445;&#25345;&#29575;&#65288;Retention rate&#65289;&#12434;&#27714;&#12417;&#12427; . $Retention space rate = cfrac{Number space of space people space who space remain space subscribed}{Total space number space of space people space who space converted} $ . # 転換した顧客を求める。 (Total number of people who converted) total_subscribers = marketing[marketing[&quot;converted&quot;] == True] [&#39;user_id&#39;].nunique() # 保持した顧客を求める。(Number of people who remained subscribed) retained = marketing[marketing[&#39;is_retained&#39;] == True] [&#39;user_id&#39;].nunique() # 保持率を計算する。 retention_rate = retained/total_subscribers print(round(retention_rate*100, 2), &quot;%&quot;) . 66.8 % . . &#12475;&#12464;&#12513;&#12531;&#12486;&#12540;&#12471;&#12519;&#12531; . 顧客をセグメント化するには、いくつかの一般的な基準がある。 . 年齢 | 性別 | 場所 | 過去の取引 | 取引したマーケッティングチャネル | . etc. . # 英語使用者を抽出 english_speakers = marketing[marketing[&#39;language_displayed&#39;] == &#39;English&#39;] # 英語使用者のユニークIDを数える total = english_speakers[&#39;user_id&#39;].nunique() # 転換した英語使用者 subscribers = english_speakers[english_speakers[&#39;converted&#39;] == True] [&#39;user_id&#39;].nunique() # 英語使用者の転換率 conversion_rate = subscribers/total print(&#39;英語使用者の転換率：&#39;, round(conversion_rate*100,2), &#39;%&#39;) . 英語使用者の転換率： 12.92 % . # 各言語ごとにグループ化し、ユニークIDをカウント total = marketing.groupby([&#39;language_displayed&#39;])[&#39;user_id&#39;].nunique() # 各言語ごとにグループ化し、そのうち転換したIDをカウント subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;language_displayed&#39;])[&#39;user_id&#39;].nunique() # グループごとに転換率計算 language_conversion_rate = subscribers/total print(language_conversion_rate) . language_displayed Arabic 0.500000 English 0.129167 German 0.716216 Spanish 0.200000 Name: user_id, dtype: float64 . # 日付ごとにグループ化し、ユニークIDをカウント total = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;] .nunique() # 日付ごとにグループ化し、そのうち転換したIDをカウント subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;date_served&#39;]) [&#39;user_id&#39;].nunique() # 日付ごとの転換率 daily_conversion_rate = subscribers/total print(daily_conversion_rate) . date_served 2018-01-01 0.099448 2018-01-02 0.098930 2018-01-03 0.103448 2018-01-04 0.108359 2018-01-05 0.125392 2018-01-06 0.113636 2018-01-07 0.141818 2018-01-08 0.115385 2018-01-09 0.125000 2018-01-10 0.118694 2018-01-11 0.080645 2018-01-12 0.076412 2018-01-13 0.084967 2018-01-14 0.085246 2018-01-15 0.113429 2018-01-16 0.255155 2018-01-17 0.219512 2018-01-18 0.091195 2018-01-19 0.059016 2018-01-20 0.067524 2018-01-21 0.087336 2018-01-22 0.123596 2018-01-23 0.122093 2018-01-24 0.115789 2018-01-25 0.125000 2018-01-26 0.090090 2018-01-27 0.065625 2018-01-28 0.062500 2018-01-29 0.059561 2018-01-30 0.066246 2018-01-31 0.052941 Name: user_id, dtype: float64 . . &#12461;&#12515;&#12531;&#12506;&#12540;&#12531;&#32080;&#26524;&#12434;&#12503;&#12525;&#12483;&#12488; . import matplotlib.pyplot as plt # Create a bar chart using language_conversion_rate DataFrame language_conversion_rate.plot(kind = &#39;bar&#39;) # Add a title and x and y-axis labels plt.title(&#39;Conversion rate by language n&#39;, size = 16) plt.ylabel(&#39;Conversion rate (%)&#39;, size = 14) plt.xlabel(&#39;Language&#39;, size = 14) # Display the plot plt.show() . # Group by date_served and count unique users total = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;] .nunique() # Group by date_served and calculate subscribers subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;date_served&#39;]) [&#39;user_id&#39;].nunique() # Calculate the conversion rate for all languages daily_conversion_rate = subscribers/total # Reset index to turn the results into a DataFrame daily_conversion_rate = pd.DataFrame(daily_conversion_rate.reset_index(0)) # Rename columns daily_conversion_rate.columns = [&#39;date_served&#39;, &#39;conversion_rate&#39;] # Create a line chart using daily_conversion_rate DataFrame daily_conversion_rate.plot(&#39;date_served&#39;, &#39;conversion_rate&#39;) plt.title(&#39;Daily conversion rate n&#39;, size = 16) plt.ylabel(&#39;Conversion rate (%)&#39;, size = 14) plt.xlabel(&#39;Date&#39;, size = 14) # Set the y-axis to begin at 0 plt.ylim(0) # Display the plot plt.show() . channel_age = marketing.groupby([&#39;marketing_channel&#39;, &#39;age_group&#39;]) [&#39;user_id&#39;].count() # Unstack channel_age and transform it into a DataFrame channel_age_df = pd.DataFrame(channel_age.unstack(level = 1)) # Plot the results channel_age_df.plot(kind = &#39;bar&#39;) plt.title(&#39;Marketing channels by age group&#39;) plt.xlabel(&#39;Age Group&#39;) plt.ylabel(&#39;Users&#39;) # Add a legend to the plot plt.legend(loc = &#39;upper right&#39;, labels = channel_age_df.columns.values) plt.show() . # Count the subs by subscribing channel and date subscribed retention_total = marketing.groupby([&#39;date_subscribed&#39;, &#39;subscribing_channel&#39;]) [&#39;user_id&#39;].nunique() # Count the retained subs by subscribing channel and date subscribed retention_subs = marketing[marketing[&#39;is_retained&#39;] == True] .groupby([&#39;date_subscribed&#39;, &#39;subscribing_channel&#39;]) [&#39;user_id&#39;].nunique() # Divide retained subscribers by total subscribers retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) retention_rate_df.head(10) . subscribing_channel Email Facebook House Ads Instagram Push . date_subscribed . 2018-01-01 1.00 | 0.875000 | 0.687500 | 0.750000 | 1.000000 | . 2018-01-02 0.75 | 1.000000 | 0.588235 | 0.625000 | 1.000000 | . 2018-01-03 NaN | 0.800000 | 0.647059 | 0.909091 | 0.666667 | . 2018-01-04 0.50 | 0.666667 | 0.466667 | 0.500000 | NaN | . 2018-01-05 1.00 | 0.571429 | 0.500000 | 0.636364 | 1.000000 | . 2018-01-06 0.80 | 0.571429 | 0.941176 | 0.500000 | 0.500000 | . 2018-01-07 0.50 | 0.750000 | 0.526316 | 0.400000 | 0.666667 | . 2018-01-08 NaN | 0.888889 | 0.500000 | 0.625000 | 1.000000 | . 2018-01-09 0.50 | 0.285714 | 0.850000 | 0.666667 | 0.500000 | . 2018-01-10 1.00 | 0.714286 | 0.666667 | 0.555556 | 1.000000 | . # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate (%)&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev]　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/02/Marketing-2.html",
            "relUrl": "/datacamp/2021/02/02/Marketing-2.html",
            "date": " • Feb 2, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Analyzing Marketing Campaigns with pandas ①",
            "content": ". &#12510;&#12540;&#12465;&#12486;&#12451;&#12531;&#12464;&#12481;&#12540;&#12512;&#12391;&#12487;&#12540;&#12479;&#12469;&#12452;&#12456;&#12531;&#12486;&#12451;&#12473;&#12488;&#12364;&#12420;&#12427;&#12371;&#12392; . マーケッティングキャンペーンの効果分析 &amp; ターゲッティング | マーケッティングチャネルの転換率や収益を考慮し、妥当性を分析 | A/B テストを行う | . . # import data import pandas as pd marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;) . &#12487;&#12540;&#12479;&#12434;&#30906;&#35469; . marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 1/1/18 | House Ads | personalization | True | English | English | 0-18 years | 1/1/18 | NaN | House Ads | True | . 1 a100000030 | 1/1/18 | House Ads | personalization | True | English | English | 19-24 years | 1/1/18 | NaN | House Ads | True | . 2 a100000031 | 1/1/18 | House Ads | personalization | True | English | English | 24-30 years | 1/1/18 | NaN | House Ads | True | . 3 a100000032 | 1/1/18 | House Ads | personalization | True | English | English | 30-36 years | 1/1/18 | NaN | House Ads | True | . 4 a100000033 | 1/1/18 | House Ads | personalization | True | English | English | 36-45 years | 1/1/18 | NaN | House Ads | True | . marketing.describe() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . count 10037 | 10021 | 10022 | 10037 | 10022 | 10037 | 10037 | 10037 | 1856 | 577 | 1856 | 1856 | . unique 7309 | 31 | 5 | 2 | 2 | 4 | 4 | 7 | 31 | 115 | 5 | 2 | . top a100000882 | 1/15/18 | House Ads | control | False | English | English | 19-24 years | 1/16/18 | 4/2/18 | Instagram | True | . freq 12 | 789 | 4733 | 5091 | 8946 | 9793 | 9275 | 1682 | 163 | 15 | 600 | 1279 | . marketing.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 10037 entries, 0 to 10036 Data columns (total 12 columns): # Column Non-Null Count Dtype -- -- 0 user_id 10037 non-null object 1 date_served 10021 non-null object 2 marketing_channel 10022 non-null object 3 variant 10037 non-null object 4 converted 10022 non-null object 5 language_displayed 10037 non-null object 6 language_preferred 10037 non-null object 7 age_group 10037 non-null object 8 date_subscribed 1856 non-null object 9 date_canceled 577 non-null object 10 subscribing_channel 1856 non-null object 11 is_retained 1856 non-null object dtypes: object(12) memory usage: 941.1+ KB . &#21015;&#12372;&#12392;&#12395;&#12487;&#12540;&#12479;&#22411;&#12434;&#26356;&#26032;&#12377;&#12427; . &#12487;&#12540;&#12479;&#22411;&#12398;&#22793;&#25563; . # Check the data type print(marketing[&#39;is_retained&#39;].dtype) . object . # Convert is_retained to a boolean marketing[&#39;is_retained&#39;] = marketing[&#39;is_retained&#39;].astype(&#39;bool&#39;) # Check the data type of is_retained, again print(marketing[&#39;is_retained&#39;].dtype) . bool . &#26032;&#12375;&#12356;&#21015;&#12398;&#36861;&#21152; . # Mapping for channels channel_dict = {&quot;House Ads&quot;: 1, &quot;Instagram&quot;: 2, &quot;Facebook&quot;: 3, &quot;Email&quot;: 4, &quot;Push&quot;: 5} # チャネルをコードにMappingする marketing[&#39;channel_code&#39;] = marketing[&#39;subscribing_channel&#39;].map(channel_dict) . # 結果 marketing[[&#39;subscribing_channel&#39;, &#39;channel_code&#39;]] . subscribing_channel channel_code . 0 House Ads | 1.0 | . 1 House Ads | 1.0 | . 2 House Ads | 1.0 | . 3 House Ads | 1.0 | . 4 House Ads | 1.0 | . ... ... | ... | . 10032 Email | 4.0 | . 10033 Email | 4.0 | . 10034 Email | 4.0 | . 10035 Email | 4.0 | . 10036 Email | 4.0 | . 10037 rows × 2 columns . import numpy as np # 列同士の一致有無を表す列を追加 marketing[&#39;is_correct_lang&#39;] = np.where( marketing[&#39;language_preferred&#39;] == marketing[&#39;language_displayed&#39;], &#39;Yes&#39;, &#39;No&#39; ) # 結果 marketing[[&#39;language_preferred&#39;, &#39;language_displayed&#39;, &#39;is_correct_lang&#39;]] . language_preferred language_displayed is_correct_lang . 0 English | English | Yes | . 1 English | English | Yes | . 2 English | English | Yes | . 3 English | English | Yes | . 4 English | English | Yes | . ... ... | ... | ... | . 10032 German | German | Yes | . 10033 German | German | Yes | . 10034 German | German | Yes | . 10035 German | German | Yes | . 10036 German | German | Yes | . 10037 rows × 3 columns . # インポートの時にdatatime型にすることも可能 # marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, # parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) # 曜日の列を数字で表した列追加 # 月曜日:0, ... ,日曜日:6 marketing_with_date[&#39;DoW&#39;] = marketing_with_date[&#39;date_subscribed&#39;].dt.dayofweek #結果 marketing_with_date[[&#39;date_subscribed&#39;, &#39;DoW&#39;]] . date_subscribed DoW . 0 2018-01-01 | 0.0 | . 1 2018-01-01 | 0.0 | . 2 2018-01-01 | 0.0 | . 3 2018-01-01 | 0.0 | . 4 2018-01-01 | 0.0 | . ... ... | ... | . 10032 2018-01-17 | 2.0 | . 10033 2018-01-17 | 2.0 | . 10034 2018-01-17 | 2.0 | . 10035 2018-01-17 | 2.0 | . 10036 2018-01-17 | 2.0 | . 10037 rows × 2 columns . &#25506;&#32034;&#30340;&#12487;&#12540;&#12479;&#35299;&#26512;&#65288;EDA&#65289; . # date_served列をグループ化し、項目ごとにユニークなIDを数える daily_users = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;].nunique() # print head print(daily_users.head()) . date_served 1/1/18 362 1/10/18 337 1/11/18 310 1/12/18 301 1/13/18 306 Name: user_id, dtype: int64 . import matplotlib.pyplot as plt # Plot daily_subscribers daily_users.plot() # Include a title and y-axis label plt.title(&#39;Daily users&#39;) plt.ylabel(&#39;Number of users&#39;) # Rotate the x-axis labels by 45 degrees plt.xticks(rotation = 45) # Display the plot plt.show() . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/datacamp/2021/02/02/Marketing-1.html",
            "relUrl": "/datacamp/2021/02/02/Marketing-1.html",
            "date": " • Feb 2, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jaysung00.github.io/jays_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jaysung00.github.io/jays_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jaysung00.github.io/jays_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}