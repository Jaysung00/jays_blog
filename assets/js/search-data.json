{
  
    
        "post0": {
            "title": "파이썬 예제13) 메뉴 리뉴얼",
            "content": ". # 내 시도 orders = [&quot;ABCFG&quot;, &quot;AC&quot;, &quot;CDE&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;ACDEH&quot;] course = [2, 3, 4] from itertools import combinations from collections import defaultdict def solution(orders, course): answer = [] dic = defaultdict(int) for n in course: for order in orders: for i in list(combinations(order, n)): dic[i] += 1 #모든 갯수를 구하지 않아도, 2이상이면 그만 구해도 될텐데.... # for k in dic: # for c in range(2, len(k)): # for i in list(combinations(list(k), c)): # dic[i] = 0 print(dic) course_menu = list(filter(lambda x : dic[x] &gt;= 2, dic)) for n in course: answer += [menu for menu in course_menu if len(menu) == n] answer.sort() return answer print(solution(orders, course)) . defaultdict(&lt;class &#39;int&#39;&gt;, {(&#39;A&#39;, &#39;B&#39;): 1, (&#39;A&#39;, &#39;C&#39;): 4, (&#39;A&#39;, &#39;F&#39;): 1, (&#39;A&#39;, &#39;G&#39;): 1, (&#39;B&#39;, &#39;C&#39;): 2, (&#39;B&#39;, &#39;F&#39;): 2, (&#39;B&#39;, &#39;G&#39;): 2, (&#39;C&#39;, &#39;F&#39;): 2, (&#39;C&#39;, &#39;G&#39;): 2, (&#39;F&#39;, &#39;G&#39;): 2, (&#39;C&#39;, &#39;D&#39;): 3, (&#39;C&#39;, &#39;E&#39;): 3, (&#39;D&#39;, &#39;E&#39;): 3, (&#39;A&#39;, &#39;D&#39;): 2, (&#39;A&#39;, &#39;E&#39;): 2, (&#39;A&#39;, &#39;H&#39;): 1, (&#39;C&#39;, &#39;H&#39;): 1, (&#39;D&#39;, &#39;H&#39;): 1, (&#39;E&#39;, &#39;H&#39;): 1, (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;): 1, (&#39;A&#39;, &#39;B&#39;, &#39;F&#39;): 1, (&#39;A&#39;, &#39;B&#39;, &#39;G&#39;): 1, (&#39;A&#39;, &#39;C&#39;, &#39;F&#39;): 1, (&#39;A&#39;, &#39;C&#39;, &#39;G&#39;): 1, (&#39;A&#39;, &#39;F&#39;, &#39;G&#39;): 1, (&#39;B&#39;, &#39;C&#39;, &#39;F&#39;): 2, (&#39;B&#39;, &#39;C&#39;, &#39;G&#39;): 2, (&#39;B&#39;, &#39;F&#39;, &#39;G&#39;): 2, (&#39;C&#39;, &#39;F&#39;, &#39;G&#39;): 2, (&#39;C&#39;, &#39;D&#39;, &#39;E&#39;): 3, (&#39;A&#39;, &#39;C&#39;, &#39;D&#39;): 2, (&#39;A&#39;, &#39;C&#39;, &#39;E&#39;): 2, (&#39;A&#39;, &#39;D&#39;, &#39;E&#39;): 2, (&#39;A&#39;, &#39;C&#39;, &#39;H&#39;): 1, (&#39;A&#39;, &#39;D&#39;, &#39;H&#39;): 1, (&#39;A&#39;, &#39;E&#39;, &#39;H&#39;): 1, (&#39;C&#39;, &#39;D&#39;, &#39;H&#39;): 1, (&#39;C&#39;, &#39;E&#39;, &#39;H&#39;): 1, (&#39;D&#39;, &#39;E&#39;, &#39;H&#39;): 1, (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;F&#39;): 1, (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;G&#39;): 1, (&#39;A&#39;, &#39;B&#39;, &#39;F&#39;, &#39;G&#39;): 1, (&#39;A&#39;, &#39;C&#39;, &#39;F&#39;, &#39;G&#39;): 1, (&#39;B&#39;, &#39;C&#39;, &#39;F&#39;, &#39;G&#39;): 2, (&#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;): 2, (&#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;H&#39;): 1, (&#39;A&#39;, &#39;C&#39;, &#39;E&#39;, &#39;H&#39;): 1, (&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;H&#39;): 1, (&#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;H&#39;): 1}) [(&#39;A&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;D&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;), (&#39;A&#39;, &#39;C&#39;, &#39;E&#39;), (&#39;A&#39;, &#39;D&#39;), (&#39;A&#39;, &#39;D&#39;, &#39;E&#39;), (&#39;A&#39;, &#39;E&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;F&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;F&#39;, &#39;G&#39;), (&#39;B&#39;, &#39;C&#39;, &#39;G&#39;), (&#39;B&#39;, &#39;F&#39;), (&#39;B&#39;, &#39;F&#39;, &#39;G&#39;), (&#39;B&#39;, &#39;G&#39;), (&#39;C&#39;, &#39;D&#39;), (&#39;C&#39;, &#39;D&#39;, &#39;E&#39;), (&#39;C&#39;, &#39;E&#39;), (&#39;C&#39;, &#39;F&#39;), (&#39;C&#39;, &#39;F&#39;, &#39;G&#39;), (&#39;C&#39;, &#39;G&#39;), (&#39;D&#39;, &#39;E&#39;), (&#39;F&#39;, &#39;G&#39;)] . for i in range(2,2): print(i) . # 다른사람 풀이 # 평가 1 ; 기본적으로 같은 방법임. not(list)를 활용해서 빈 리스트 일 경우 0 (false)를 활용한 리턴값 def solution(s): answer = [] for i in s: if not(answer): answer.append(i) else: if(answer[-1] == i): answer.pop() else: answer.append(i) return not(answer) .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/04/python13.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/04/python13.html",
            "date": " • Nov 4, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "파이썬 예제12) 짝지어 제거하기",
            "content": ". # 내 시도 s = &quot;abbcdaadca&quot; def solution(s): answer = 0 slist = [] for i in range(len(s)): if len(slist) == 0: slist.append(s[i]) elif slist[-1] != s[i]: slist.append(s[i]) else: slist.pop() if len(slist) == 0: answer = 1 return answer print(solution(s)) . 1 . # 다른사람 풀이 # 평가 1 ; 기본적으로 같은 방법임. not(list)를 활용해서 빈 리스트 일 경우 0 (false)를 활용한 리턴값 def solution(s): answer = [] for i in s: if not(answer): answer.append(i) else: if(answer[-1] == i): answer.pop() else: answer.append(i) return not(answer) .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/04/python12.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/04/python12.html",
            "date": " • Nov 4, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Today I Learned 211104",
            "content": ". 인프런 파이썬 중급 (Inflearn Original) . 시퀀스(2-1, 2-2, 3, 4-1, 4-2) - 파이썬 시퀀스 실습 | . . &#53916;&#54540;(Tuple) &#44256;&#44553;&#49324;&#50857; . # Tuple Advanced # Unpacking # b, a = a, b print(divmod(100, 9)) print(divmod(*(100, 9))) print(*(divmod(100, 9))) . (11, 1) (11, 1) 11 1 . x, y, *rest = range(10) print(x, y, rest) x, y, *rest = range(2) print(x, y, rest) x, y, *rest = 1, 2, 3, 4, 5 # 컴마만 사용하면 자동으로 튜플되는거 까먹지않기 print(x, y, rest) type(rest) # 왜 튜플이 아니라 리스트인걸까....? . 0 1 [2, 3, 4, 5, 6, 7, 8, 9] 0 1 [] 1 2 [3, 4, 5] . list . . Mutable(&#44032;&#48320;) vs Immutable(&#48520;&#48320;) . l = (15, 20 ,25) m = [15, 20 ,25] print(l, id(l)) print(m, id(m)) l = l * 2 m = m * 2 print(l, id(l)) print(m, id(m)) l *= 2 m *= 2 print(l, id(l)) # 튜플형은 계속 새로운 id값을 만들며 재할당 할 수 밖에없음 print(m, id(m)) # 연산자의 활용에 따라 리스트는 자기 자신의 id에 추가를 하기도 한다. . (15, 20, 25) 4504239200 [15, 20, 25] 4502056648 (15, 20, 25, 15, 20, 25) 4504075624 [15, 20, 25, 15, 20, 25] 4504115464 (15, 20, 25, 15, 20, 25, 15, 20, 25, 15, 20, 25) 4451539992 [15, 20, 25, 15, 20, 25, 15, 20, 25, 15, 20, 25] 4504115464 . . Sort vs Sorted &#49892;&#49845; . ## reverse, key=len, key=str.lower, key =func ... # sorted : 정렬 후 새로운 객체 반환 f_list = [&#39;orange&#39;, &#39;apple&#39;, &#39;mango&#39;, &#39;papaya&#39;, &#39;lemon&#39;, &#39;strawberry&#39;, &#39;coconut&#39;] print(&#39;sorted - &#39;, sorted(f_list)) print(&#39;sorted - &#39;, sorted(f_list, reverse=True)) # 역순 print(&#39;sorted - &#39;, sorted(f_list, key=len)) # 길이순 정렬 print(&#39;sorted - &#39;, sorted(f_list, key=lambda x : x[-1])) #(람다)함수를 통해 마지막글자 비교 print(&#39;sorted - &#39;, sorted(f_list, key=lambda x : x[-1], reverse=True)) . sorted - [&#39;apple&#39;, &#39;coconut&#39;, &#39;lemon&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;papaya&#39;, &#39;strawberry&#39;] sorted - [&#39;strawberry&#39;, &#39;papaya&#39;, &#39;orange&#39;, &#39;mango&#39;, &#39;lemon&#39;, &#39;coconut&#39;, &#39;apple&#39;] sorted - [&#39;apple&#39;, &#39;mango&#39;, &#39;lemon&#39;, &#39;orange&#39;, &#39;papaya&#39;, &#39;coconut&#39;, &#39;strawberry&#39;] sorted - [&#39;papaya&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;lemon&#39;, &#39;mango&#39;, &#39;coconut&#39;, &#39;strawberry&#39;] sorted - [&#39;strawberry&#39;, &#39;coconut&#39;, &#39;mango&#39;, &#39;lemon&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;papaya&#39;] . # sort : 정렬 후 객체 직접 변경 # 반환 값 확인(None) print(&#39;sort - &#39;, f_list.sort(), f_list) print(&#39;sort - &#39;, f_list.sort(reverse=True), f_list) print(&#39;sort - &#39;, f_list.sort(key=lambda x : x[-1]), f_list) print(&#39;sort - &#39;, f_list.sort(key=lambda x : x[-1], reverse=True), f_list) . sort - None [&#39;apple&#39;, &#39;coconut&#39;, &#39;lemon&#39;, &#39;mango&#39;, &#39;orange&#39;, &#39;papaya&#39;, &#39;strawberry&#39;] sort - None [&#39;strawberry&#39;, &#39;papaya&#39;, &#39;orange&#39;, &#39;mango&#39;, &#39;lemon&#39;, &#39;coconut&#39;, &#39;apple&#39;] sort - None [&#39;papaya&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;lemon&#39;, &#39;mango&#39;, &#39;coconut&#39;, &#39;strawberry&#39;] sort - None [&#39;strawberry&#39;, &#39;coconut&#39;, &#39;mango&#39;, &#39;lemon&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;papaya&#39;] . . List vs Array(&#48176;&#50676;) &#51201;&#54633;&#54620; &#49324;&#50857;&#48277;&#51008;? . list의 장점 : 융통성이 좋다. 다양한 자료형과 범용적 사용 | array(배열)의 장점 : 숫자기반의 고속연산에 유리 | . . &#54644;&#49884; &#53580;&#51060;&#48660; (Hashtable) . 적은 리소스로 많은 데이터를 효율적으로 관리 | key에 value를 저장하는 구조 | 파이썬에서는 dictionary가 해시테이블의 예이다. | 장점은, 키 값의 연산 결과에 따라 직접 접근이 가능한 구조 | key값을 해싱함수를 통해 해시주소값을 찾아내고, 그것을 기반으로 key에 대한 value를 참조하는 원리 | . # Dict 구조 print(__builtins__.__dict__) # key-value 구조 . {&#39;__name__&#39;: &#39;builtins&#39;, &#39;__doc__&#39;: &#34;Built-in functions, exceptions, and other objects. n nNoteworthy: None is the `nil&#39; object; Ellipsis represents `...&#39; in slices.&#34;, &#39;__package__&#39;: &#39;&#39;, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: ModuleSpec(name=&#39;builtins&#39;, loader=&lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;), &#39;__build_class__&#39;: &lt;built-in function __build_class__&gt;, &#39;__import__&#39;: &lt;built-in function __import__&gt;, &#39;abs&#39;: &lt;built-in function abs&gt;, &#39;all&#39;: &lt;built-in function all&gt;, &#39;any&#39;: &lt;built-in function any&gt;, &#39;ascii&#39;: &lt;built-in function ascii&gt;, &#39;bin&#39;: &lt;built-in function bin&gt;, &#39;breakpoint&#39;: &lt;built-in function breakpoint&gt;, &#39;callable&#39;: &lt;built-in function callable&gt;, &#39;chr&#39;: &lt;built-in function chr&gt;, &#39;compile&#39;: &lt;built-in function compile&gt;, &#39;delattr&#39;: &lt;built-in function delattr&gt;, &#39;dir&#39;: &lt;built-in function dir&gt;, &#39;divmod&#39;: &lt;built-in function divmod&gt;, &#39;eval&#39;: &lt;built-in function eval&gt;, &#39;exec&#39;: &lt;built-in function exec&gt;, &#39;format&#39;: &lt;built-in function format&gt;, &#39;getattr&#39;: &lt;built-in function getattr&gt;, &#39;globals&#39;: &lt;built-in function globals&gt;, &#39;hasattr&#39;: &lt;built-in function hasattr&gt;, &#39;hash&#39;: &lt;built-in function hash&gt;, &#39;hex&#39;: &lt;built-in function hex&gt;, &#39;id&#39;: &lt;built-in function id&gt;, &#39;input&#39;: &lt;bound method Kernel.raw_input of &lt;ipykernel.ipkernel.IPythonKernel object at 0x10c589d68&gt;&gt;, &#39;isinstance&#39;: &lt;built-in function isinstance&gt;, &#39;issubclass&#39;: &lt;built-in function issubclass&gt;, &#39;iter&#39;: &lt;built-in function iter&gt;, &#39;len&#39;: &lt;built-in function len&gt;, &#39;locals&#39;: &lt;built-in function locals&gt;, &#39;max&#39;: &lt;built-in function max&gt;, &#39;min&#39;: &lt;built-in function min&gt;, &#39;next&#39;: &lt;built-in function next&gt;, &#39;oct&#39;: &lt;built-in function oct&gt;, &#39;ord&#39;: &lt;built-in function ord&gt;, &#39;pow&#39;: &lt;built-in function pow&gt;, &#39;print&#39;: &lt;built-in function print&gt;, &#39;repr&#39;: &lt;built-in function repr&gt;, &#39;round&#39;: &lt;built-in function round&gt;, &#39;setattr&#39;: &lt;built-in function setattr&gt;, &#39;sorted&#39;: &lt;built-in function sorted&gt;, &#39;sum&#39;: &lt;built-in function sum&gt;, &#39;vars&#39;: &lt;built-in function vars&gt;, &#39;None&#39;: None, &#39;Ellipsis&#39;: Ellipsis, &#39;NotImplemented&#39;: NotImplemented, &#39;False&#39;: False, &#39;True&#39;: True, &#39;bool&#39;: &lt;class &#39;bool&#39;&gt;, &#39;memoryview&#39;: &lt;class &#39;memoryview&#39;&gt;, &#39;bytearray&#39;: &lt;class &#39;bytearray&#39;&gt;, &#39;bytes&#39;: &lt;class &#39;bytes&#39;&gt;, &#39;classmethod&#39;: &lt;class &#39;classmethod&#39;&gt;, &#39;complex&#39;: &lt;class &#39;complex&#39;&gt;, &#39;dict&#39;: &lt;class &#39;dict&#39;&gt;, &#39;enumerate&#39;: &lt;class &#39;enumerate&#39;&gt;, &#39;filter&#39;: &lt;class &#39;filter&#39;&gt;, &#39;float&#39;: &lt;class &#39;float&#39;&gt;, &#39;frozenset&#39;: &lt;class &#39;frozenset&#39;&gt;, &#39;property&#39;: &lt;class &#39;property&#39;&gt;, &#39;int&#39;: &lt;class &#39;int&#39;&gt;, &#39;list&#39;: &lt;class &#39;list&#39;&gt;, &#39;map&#39;: &lt;class &#39;map&#39;&gt;, &#39;object&#39;: &lt;class &#39;object&#39;&gt;, &#39;range&#39;: &lt;class &#39;range&#39;&gt;, &#39;reversed&#39;: &lt;class &#39;reversed&#39;&gt;, &#39;set&#39;: &lt;class &#39;set&#39;&gt;, &#39;slice&#39;: &lt;class &#39;slice&#39;&gt;, &#39;staticmethod&#39;: &lt;class &#39;staticmethod&#39;&gt;, &#39;str&#39;: &lt;class &#39;str&#39;&gt;, &#39;super&#39;: &lt;class &#39;super&#39;&gt;, &#39;tuple&#39;: &lt;class &#39;tuple&#39;&gt;, &#39;type&#39;: &lt;class &#39;type&#39;&gt;, &#39;zip&#39;: &lt;class &#39;zip&#39;&gt;, &#39;__debug__&#39;: True, &#39;BaseException&#39;: &lt;class &#39;BaseException&#39;&gt;, &#39;Exception&#39;: &lt;class &#39;Exception&#39;&gt;, &#39;TypeError&#39;: &lt;class &#39;TypeError&#39;&gt;, &#39;StopAsyncIteration&#39;: &lt;class &#39;StopAsyncIteration&#39;&gt;, &#39;StopIteration&#39;: &lt;class &#39;StopIteration&#39;&gt;, &#39;GeneratorExit&#39;: &lt;class &#39;GeneratorExit&#39;&gt;, &#39;SystemExit&#39;: &lt;class &#39;SystemExit&#39;&gt;, &#39;KeyboardInterrupt&#39;: &lt;class &#39;KeyboardInterrupt&#39;&gt;, &#39;ImportError&#39;: &lt;class &#39;ImportError&#39;&gt;, &#39;ModuleNotFoundError&#39;: &lt;class &#39;ModuleNotFoundError&#39;&gt;, &#39;OSError&#39;: &lt;class &#39;OSError&#39;&gt;, &#39;EnvironmentError&#39;: &lt;class &#39;OSError&#39;&gt;, &#39;IOError&#39;: &lt;class &#39;OSError&#39;&gt;, &#39;EOFError&#39;: &lt;class &#39;EOFError&#39;&gt;, &#39;RuntimeError&#39;: &lt;class &#39;RuntimeError&#39;&gt;, &#39;RecursionError&#39;: &lt;class &#39;RecursionError&#39;&gt;, &#39;NotImplementedError&#39;: &lt;class &#39;NotImplementedError&#39;&gt;, &#39;NameError&#39;: &lt;class &#39;NameError&#39;&gt;, &#39;UnboundLocalError&#39;: &lt;class &#39;UnboundLocalError&#39;&gt;, &#39;AttributeError&#39;: &lt;class &#39;AttributeError&#39;&gt;, &#39;SyntaxError&#39;: &lt;class &#39;SyntaxError&#39;&gt;, &#39;IndentationError&#39;: &lt;class &#39;IndentationError&#39;&gt;, &#39;TabError&#39;: &lt;class &#39;TabError&#39;&gt;, &#39;LookupError&#39;: &lt;class &#39;LookupError&#39;&gt;, &#39;IndexError&#39;: &lt;class &#39;IndexError&#39;&gt;, &#39;KeyError&#39;: &lt;class &#39;KeyError&#39;&gt;, &#39;ValueError&#39;: &lt;class &#39;ValueError&#39;&gt;, &#39;UnicodeError&#39;: &lt;class &#39;UnicodeError&#39;&gt;, &#39;UnicodeEncodeError&#39;: &lt;class &#39;UnicodeEncodeError&#39;&gt;, &#39;UnicodeDecodeError&#39;: &lt;class &#39;UnicodeDecodeError&#39;&gt;, &#39;UnicodeTranslateError&#39;: &lt;class &#39;UnicodeTranslateError&#39;&gt;, &#39;AssertionError&#39;: &lt;class &#39;AssertionError&#39;&gt;, &#39;ArithmeticError&#39;: &lt;class &#39;ArithmeticError&#39;&gt;, &#39;FloatingPointError&#39;: &lt;class &#39;FloatingPointError&#39;&gt;, &#39;OverflowError&#39;: &lt;class &#39;OverflowError&#39;&gt;, &#39;ZeroDivisionError&#39;: &lt;class &#39;ZeroDivisionError&#39;&gt;, &#39;SystemError&#39;: &lt;class &#39;SystemError&#39;&gt;, &#39;ReferenceError&#39;: &lt;class &#39;ReferenceError&#39;&gt;, &#39;MemoryError&#39;: &lt;class &#39;MemoryError&#39;&gt;, &#39;BufferError&#39;: &lt;class &#39;BufferError&#39;&gt;, &#39;Warning&#39;: &lt;class &#39;Warning&#39;&gt;, &#39;UserWarning&#39;: &lt;class &#39;UserWarning&#39;&gt;, &#39;DeprecationWarning&#39;: &lt;class &#39;DeprecationWarning&#39;&gt;, &#39;PendingDeprecationWarning&#39;: &lt;class &#39;PendingDeprecationWarning&#39;&gt;, &#39;SyntaxWarning&#39;: &lt;class &#39;SyntaxWarning&#39;&gt;, &#39;RuntimeWarning&#39;: &lt;class &#39;RuntimeWarning&#39;&gt;, &#39;FutureWarning&#39;: &lt;class &#39;FutureWarning&#39;&gt;, &#39;ImportWarning&#39;: &lt;class &#39;ImportWarning&#39;&gt;, &#39;UnicodeWarning&#39;: &lt;class &#39;UnicodeWarning&#39;&gt;, &#39;BytesWarning&#39;: &lt;class &#39;BytesWarning&#39;&gt;, &#39;ResourceWarning&#39;: &lt;class &#39;ResourceWarning&#39;&gt;, &#39;ConnectionError&#39;: &lt;class &#39;ConnectionError&#39;&gt;, &#39;BlockingIOError&#39;: &lt;class &#39;BlockingIOError&#39;&gt;, &#39;BrokenPipeError&#39;: &lt;class &#39;BrokenPipeError&#39;&gt;, &#39;ChildProcessError&#39;: &lt;class &#39;ChildProcessError&#39;&gt;, &#39;ConnectionAbortedError&#39;: &lt;class &#39;ConnectionAbortedError&#39;&gt;, &#39;ConnectionRefusedError&#39;: &lt;class &#39;ConnectionRefusedError&#39;&gt;, &#39;ConnectionResetError&#39;: &lt;class &#39;ConnectionResetError&#39;&gt;, &#39;FileExistsError&#39;: &lt;class &#39;FileExistsError&#39;&gt;, &#39;FileNotFoundError&#39;: &lt;class &#39;FileNotFoundError&#39;&gt;, &#39;IsADirectoryError&#39;: &lt;class &#39;IsADirectoryError&#39;&gt;, &#39;NotADirectoryError&#39;: &lt;class &#39;NotADirectoryError&#39;&gt;, &#39;InterruptedError&#39;: &lt;class &#39;InterruptedError&#39;&gt;, &#39;PermissionError&#39;: &lt;class &#39;PermissionError&#39;&gt;, &#39;ProcessLookupError&#39;: &lt;class &#39;ProcessLookupError&#39;&gt;, &#39;TimeoutError&#39;: &lt;class &#39;TimeoutError&#39;&gt;, &#39;open&#39;: &lt;built-in function open&gt;, &#39;copyright&#39;: Copyright (c) 2001-2019 Python Software Foundation. All Rights Reserved. Copyright (c) 2000 BeOpen.com. All Rights Reserved. Copyright (c) 1995-2001 Corporation for National Research Initiatives. All Rights Reserved. Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam. All Rights Reserved., &#39;credits&#39;: Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands for supporting Python development. See www.python.org for more information., &#39;license&#39;: Type license() to see the full license text, &#39;help&#39;: Type help() for interactive help, or help(object) for help about object., &#39;__IPYTHON__&#39;: True, &#39;display&#39;: &lt;function display at 0x1097cf400&gt;, &#39;get_ipython&#39;: &lt;bound method InteractiveShell.get_ipython of &lt;ipykernel.zmqshell.ZMQInteractiveShell object at 0x10aa57ac8&gt;&gt;} . # Hash 값 확인 t1 = (10, 20, (30, 40, 50)) t2 = (10, 20, [30, 40, 50]) print(hash(t1)) # hash() 안에는 불변형만 가능하다 print(hash(t2)) # 리스트는 수정이 가능하기 때문에 해시값을 뽑아낼 수 없다. . 5737367089334957572 . TypeError Traceback (most recent call last) &lt;ipython-input-29-db22618e85af&gt; in &lt;module&gt; 6 7 print(hash(t1)) # hash() 안에는 불변형만 가능하다 -&gt; 8 print(hash(t2)) # 리스트는 수정이 가능하기 때문에 해시값을 뽑아낼 수 없다. TypeError: unhashable type: &#39;list&#39; . . Setdefault &#49324;&#50857;&#48277; . ## Dict Setdefault 예제 # source라는 tuple을 해시테이블로 만들어보자. source = ((&#39;k1&#39;, &#39;val1&#39;), (&#39;k1&#39;, &#39;val2&#39;), (&#39;k2&#39;, &#39;val3&#39;), (&#39;k2&#39;, &#39;val4&#39;), (&#39;k2&#39;, &#39;val5&#39;)) new_dict1 = {} new_dict2 = {} # No use Setdefault for k, v in source: if k in new_dict1: new_dict1[k].append(v) else: new_dict1[k] = [v] print(new_dict1) # Use Setdefault for k, v in source: new_dict2.setdefault(k, []).append(v) print(new_dict2) # 주의 new_dict3 = {k : v for k, v in source} print(new_dict3) # 같은 key값은 덮어써버리므로 원하는 모양이 아님 . {&#39;k1&#39;: [&#39;val1&#39;, &#39;val2&#39;], &#39;k2&#39;: [&#39;val3&#39;, &#39;val4&#39;, &#39;val5&#39;]} {&#39;k1&#39;: [&#39;val1&#39;, &#39;val2&#39;], &#39;k2&#39;: [&#39;val3&#39;, &#39;val4&#39;, &#39;val5&#39;]} {&#39;k1&#39;: &#39;val2&#39;, &#39;k2&#39;: &#39;val5&#39;} . . Immutable Dict &#49373;&#49457; . from types import MappingProxyType d = {&#39;key1&#39; : &#39;value1&#39;} # Creat Read Only Dict d_frozen = MappingProxyType(d) print(d, id(d)) print(d_frozen, id(d_frozen)) . {&#39;key1&#39;: &#39;value1&#39;} 4504371136 {&#39;key1&#39;: &#39;value1&#39;} 4504385336 . # Mutable Dict d[&#39;key2&#39;] = &#39;value2&#39; print(d) . {&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;} . # immutable Dict d_frozen[&#39;key2&#39;] = &#39;value2&#39; print(d_frozen) # 수정불가 . TypeError Traceback (most recent call last) &lt;ipython-input-41-41483b3de209&gt; in &lt;module&gt; 2 # immutable Dict 3 -&gt; 4 d_frozen[&#39;key2&#39;] = &#39;value2&#39; 5 print(d_frozen) # 수정불가 TypeError: &#39;mappingproxy&#39; object does not support item assignment . . Immutable Set &#49373;&#49457; . # 집합 선언 방법 s1 = {&#39;Apple&#39;, &#39;Orange&#39;, &#39;Apple&#39;, &#39;Orange&#39;, &#39;Kiwi&#39;} s2 = set([&#39;Apple&#39;, &#39;Orange&#39;, &#39;Apple&#39;, &#39;Orange&#39;, &#39;Kiwi&#39;]) s3 = {3} s4 = set() # Not {} =&gt; dict s5 = frozenset({&#39;Apple&#39;, &#39;Orange&#39;, &#39;Apple&#39;, &#39;Orange&#39;, &#39;Kiwi&#39;}) # 불변 . {&#39;Melon&#39;, &#39;Kiwi&#39;, &#39;Apple&#39;, &#39;Orange&#39;} . # 기본은 수정가능 s1.add(&#39;Melon&#39;) print(s1) . {&#39;Melon&#39;, &#39;Kiwi&#39;, &#39;Apple&#39;, &#39;Orange&#39;} . # frozen set은 수정불가 s5.add(&#39;Melon&#39;) print(s5) . AttributeError Traceback (most recent call last) &lt;ipython-input-46-ac373a51cfc9&gt; in &lt;module&gt; 1 2 # frozen set은 수정불가 -&gt; 3 s5.add(&#39;Melon&#39;) 4 print(s5) AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39; . ## 선언 최적화 # 바이트코드 -&gt; 파이썬 인터프리터 설정 from dis import dis print(&#39;&#39;) print(dis(&#39;{10}&#39;)) # 이쪽이 더 최적화된 선언방법! print(&#39;&#39;) print(dis(&#39;set([10])&#39;)) . 1 0 LOAD_CONST 0 (10) 2 BUILD_SET 1 4 RETURN_VALUE None 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (10) 4 BUILD_LIST 1 6 CALL_FUNCTION 1 8 RETURN_VALUE None . . &#51648;&#45733;&#54805; &#51665;&#54633;(Comprehending Set) . from unicodedata import name print({name(chr(i), &#39;&#39;) for i in range(0, 256)}) . {&#39;&#39;, &#39;BROKEN BAR&#39;, &#39;DOLLAR SIGN&#39;, &#39;GREATER-THAN SIGN&#39;, &#39;LATIN SMALL LETTER C WITH CEDILLA&#39;, &#39;QUESTION MARK&#39;, &#39;LATIN CAPITAL LETTER O WITH GRAVE&#39;, &#39;LATIN SMALL LETTER Y WITH DIAERESIS&#39;, &#39;LATIN CAPITAL LETTER C&#39;, &#39;ASTERISK&#39;, &#39;LATIN CAPITAL LETTER U&#39;, &#39;LATIN CAPITAL LETTER E&#39;, &#39;LATIN CAPITAL LETTER I WITH ACUTE&#39;, &#39;LATIN CAPITAL LETTER A WITH CIRCUMFLEX&#39;, &#39;VULGAR FRACTION THREE QUARTERS&#39;, &#39;LATIN SMALL LETTER J&#39;, &#39;LATIN SMALL LETTER N&#39;, &#39;LATIN SMALL LETTER H&#39;, &#39;LATIN SMALL LETTER O&#39;, &#39;DIGIT ZERO&#39;, &#39;LATIN SMALL LETTER T&#39;, &#39;NOT SIGN&#39;, &#39;LATIN SMALL LETTER I WITH CIRCUMFLEX&#39;, &#39;LATIN SMALL LETTER B&#39;, &#39;LATIN SMALL LETTER A WITH RING ABOVE&#39;, &#39;CEDILLA&#39;, &#39;LATIN CAPITAL LETTER Z&#39;, &#39;LATIN SMALL LETTER O WITH CIRCUMFLEX&#39;, &#39;NUMBER SIGN&#39;, &#39;RIGHT CURLY BRACKET&#39;, &#39;LATIN SMALL LETTER SHARP S&#39;, &#39;LATIN SMALL LETTER I WITH DIAERESIS&#39;, &#39;LATIN CAPITAL LETTER A WITH ACUTE&#39;, &#39;LATIN CAPITAL LETTER F&#39;, &#39;LATIN SMALL LETTER K&#39;, &#39;APOSTROPHE&#39;, &#39;DIAERESIS&#39;, &#39;AMPERSAND&#39;, &#39;LATIN CAPITAL LETTER T&#39;, &#39;LATIN SMALL LETTER I&#39;, &#39;LATIN SMALL LETTER M&#39;, &#39;LATIN SMALL LETTER E WITH GRAVE&#39;, &#39;DIGIT EIGHT&#39;, &#39;DIGIT NINE&#39;, &#39;LATIN SMALL LETTER W&#39;, &#39;LATIN SMALL LETTER THORN&#39;, &#39;LATIN SMALL LETTER A WITH GRAVE&#39;, &#39;DIGIT FOUR&#39;, &#39;LATIN SMALL LETTER O WITH DIAERESIS&#39;, &#39;LATIN SMALL LETTER L&#39;, &#39;LATIN SMALL LETTER F&#39;, &#39;COPYRIGHT SIGN&#39;, &#39;LATIN CAPITAL LETTER A WITH GRAVE&#39;, &#39;PLUS-MINUS SIGN&#39;, &#39;SUPERSCRIPT ONE&#39;, &#39;LATIN SMALL LETTER Z&#39;, &#39;LATIN CAPITAL LETTER B&#39;, &#39;HYPHEN-MINUS&#39;, &#39;PLUS SIGN&#39;, &#39;LATIN CAPITAL LETTER V&#39;, &#39;LATIN SMALL LETTER U WITH DIAERESIS&#39;, &#39;POUND SIGN&#39;, &#39;DIGIT FIVE&#39;, &#39;SUPERSCRIPT THREE&#39;, &#39;PERCENT SIGN&#39;, &#39;LATIN SMALL LETTER U WITH GRAVE&#39;, &#39;REVERSE SOLIDUS&#39;, &#39;LATIN CAPITAL LETTER O&#39;, &#39;LATIN CAPITAL LETTER W&#39;, &#39;LATIN SMALL LETTER E WITH ACUTE&#39;, &#39;LATIN CAPITAL LETTER R&#39;, &#39;YEN SIGN&#39;, &#39;SOLIDUS&#39;, &#39;GRAVE ACCENT&#39;, &#39;SPACE&#39;, &#39;MACRON&#39;, &#39;PILCROW SIGN&#39;, &#39;LATIN SMALL LETTER A WITH DIAERESIS&#39;, &#39;COMMERCIAL AT&#39;, &#39;LATIN SMALL LETTER A WITH ACUTE&#39;, &#39;EXCLAMATION MARK&#39;, &#39;LATIN CAPITAL LETTER U WITH ACUTE&#39;, &#39;LATIN CAPITAL LETTER Y WITH ACUTE&#39;, &#39;LATIN CAPITAL LETTER U WITH CIRCUMFLEX&#39;, &#39;CIRCUMFLEX ACCENT&#39;, &#39;COLON&#39;, &#39;TILDE&#39;, &#39;LATIN SMALL LETTER C&#39;, &#39;LEFT PARENTHESIS&#39;, &#39;LEFT SQUARE BRACKET&#39;, &#39;LATIN SMALL LETTER AE&#39;, &#39;COMMA&#39;, &#39;LATIN CAPITAL LETTER O WITH ACUTE&#39;, &#39;LATIN CAPITAL LETTER I&#39;, &#39;LATIN CAPITAL LETTER E WITH GRAVE&#39;, &#39;LATIN SMALL LETTER D&#39;, &#39;FEMININE ORDINAL INDICATOR&#39;, &#39;VULGAR FRACTION ONE QUARTER&#39;, &#39;NO-BREAK SPACE&#39;, &#39;LATIN CAPITAL LETTER A&#39;, &#39;LATIN CAPITAL LETTER N&#39;, &#39;LATIN CAPITAL LETTER AE&#39;, &#39;LATIN SMALL LETTER E WITH DIAERESIS&#39;, &#39;LATIN SMALL LETTER P&#39;, &#39;LATIN CAPITAL LETTER THORN&#39;, &#39;LOW LINE&#39;, &#39;LATIN CAPITAL LETTER M&#39;, &#39;VERTICAL LINE&#39;, &#39;DIGIT ONE&#39;, &#39;LATIN SMALL LETTER O WITH STROKE&#39;, &#39;RIGHT SQUARE BRACKET&#39;, &#39;LATIN CAPITAL LETTER E WITH DIAERESIS&#39;, &#39;LATIN CAPITAL LETTER ETH&#39;, &#39;LATIN SMALL LETTER N WITH TILDE&#39;, &#39;SOFT HYPHEN&#39;, &#39;LATIN CAPITAL LETTER K&#39;, &#39;DIGIT TWO&#39;, &#39;LATIN CAPITAL LETTER Y&#39;, &#39;LATIN CAPITAL LETTER O WITH STROKE&#39;, &#39;LATIN CAPITAL LETTER U WITH GRAVE&#39;, &#39;DIGIT SEVEN&#39;, &#39;CENT SIGN&#39;, &#39;LATIN SMALL LETTER U WITH ACUTE&#39;, &#39;LATIN SMALL LETTER R&#39;, &#39;LATIN CAPITAL LETTER J&#39;, &#39;MIDDLE DOT&#39;, &#39;LATIN CAPITAL LETTER G&#39;, &#39;LATIN CAPITAL LETTER O WITH TILDE&#39;, &#39;LATIN SMALL LETTER E WITH CIRCUMFLEX&#39;, &#39;LATIN SMALL LETTER O WITH ACUTE&#39;, &#39;LATIN CAPITAL LETTER I WITH DIAERESIS&#39;, &#39;QUOTATION MARK&#39;, &#39;LATIN SMALL LETTER X&#39;, &#39;LATIN CAPITAL LETTER O WITH DIAERESIS&#39;, &#39;LATIN CAPITAL LETTER H&#39;, &#39;LATIN SMALL LETTER A WITH CIRCUMFLEX&#39;, &#39;LATIN SMALL LETTER G&#39;, &#39;LATIN SMALL LETTER U WITH CIRCUMFLEX&#39;, &#39;LATIN SMALL LETTER S&#39;, &#39;INVERTED QUESTION MARK&#39;, &#39;LATIN SMALL LETTER V&#39;, &#39;EQUALS SIGN&#39;, &#39;LATIN CAPITAL LETTER S&#39;, &#39;REGISTERED SIGN&#39;, &#39;LATIN CAPITAL LETTER I WITH CIRCUMFLEX&#39;, &#39;LATIN SMALL LETTER I WITH GRAVE&#39;, &#39;CURRENCY SIGN&#39;, &#39;LATIN SMALL LETTER Y WITH ACUTE&#39;, &#39;MASCULINE ORDINAL INDICATOR&#39;, &#39;LATIN CAPITAL LETTER L&#39;, &#39;RIGHT PARENTHESIS&#39;, &#39;ACUTE ACCENT&#39;, &#39;INVERTED EXCLAMATION MARK&#39;, &#39;LATIN CAPITAL LETTER O WITH CIRCUMFLEX&#39;, &#39;LATIN CAPITAL LETTER X&#39;, &#39;DEGREE SIGN&#39;, &#39;RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK&#39;, &#39;LATIN CAPITAL LETTER A WITH DIAERESIS&#39;, &#39;LATIN CAPITAL LETTER A WITH TILDE&#39;, &#39;LATIN CAPITAL LETTER E WITH ACUTE&#39;, &#39;LATIN SMALL LETTER O WITH GRAVE&#39;, &#39;LATIN CAPITAL LETTER E WITH CIRCUMFLEX&#39;, &#39;MULTIPLICATION SIGN&#39;, &#39;LATIN SMALL LETTER U&#39;, &#39;LATIN CAPITAL LETTER A WITH RING ABOVE&#39;, &#39;DIGIT SIX&#39;, &#39;LATIN SMALL LETTER ETH&#39;, &#39;LATIN CAPITAL LETTER Q&#39;, &#39;LATIN CAPITAL LETTER N WITH TILDE&#39;, &#39;LEFT-POINTING DOUBLE ANGLE QUOTATION MARK&#39;, &#39;SECTION SIGN&#39;, &#39;MICRO SIGN&#39;, &#39;SUPERSCRIPT TWO&#39;, &#39;LATIN SMALL LETTER I WITH ACUTE&#39;, &#39;LATIN SMALL LETTER Q&#39;, &#39;LESS-THAN SIGN&#39;, &#39;LATIN CAPITAL LETTER D&#39;, &#39;LATIN CAPITAL LETTER I WITH GRAVE&#39;, &#39;LATIN SMALL LETTER A WITH TILDE&#39;, &#39;LATIN SMALL LETTER O WITH TILDE&#39;, &#39;DIGIT THREE&#39;, &#39;LATIN SMALL LETTER Y&#39;, &#39;LEFT CURLY BRACKET&#39;, &#39;SEMICOLON&#39;, &#39;LATIN CAPITAL LETTER P&#39;, &#39;LATIN CAPITAL LETTER U WITH DIAERESIS&#39;, &#39;LATIN CAPITAL LETTER C WITH CEDILLA&#39;, &#39;LATIN SMALL LETTER E&#39;, &#39;LATIN SMALL LETTER A&#39;, &#39;DIVISION SIGN&#39;, &#39;FULL STOP&#39;, &#39;VULGAR FRACTION ONE HALF&#39;} .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/11/04/TIL211104.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/11/04/TIL211104.html",
            "date": " • Nov 4, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "파이썬 예제11) 124 나라의 숫자",
            "content": ". # 내 풀이 -&gt; OK n = 5 def solution(n): answer = &#39;&#39; while n &gt; 0: if n % 3 != 0: answer = str(n % 3) + answer n = n // 3 else: answer = &#39;4&#39; + answer n = n // 3 - 1 return answer print(solution(n)) #Return 11 . 12 . # 다른사람 풀이 # 좋은 점 1 ; 리스트에서 인덱싱으로 처리했다. # 좋은 점 2 ; if문 사용하지 않고, 인덱싱과 자리값을 절묘하게 -1로 처리함 def change124(n): num = [&#39;1&#39;,&#39;2&#39;,&#39;4&#39;] answer = &quot;&quot; while n &gt; 0: n -= 1 answer = num[n % 3] + answer n //= 3 return answer . 80.0 .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/03/python11.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/03/python11.html",
            "date": " • Nov 3, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "파이썬 예제10) 멀쩡한 사각형",
            "content": ". # 내 풀이 ## 풀이 전략 # 1. 최대공약수(N)으로 나눠 단위 박스 별로 계산 # 2. 단위 박스에서 각 높이별로 올림 / 내림으로 계산 # 3. 빠지는 박스만큼 전체에서 뺀다 ## 스스로 생각할 때 비효율적이라고 생각하는 점 # float을 조금씩 더해나가면서 올림 혹은 내림을 사용하였기 때문에 시스템오류상 정확히 맞아떨어지지 않는 부분 처리가 귀찮았다. w = 8 h = 12 import math def solution(w,h): answer = 1 # 전체 박스 갯수 all = w * h # 최대 공약수 구하기 g = math.gcd(w, h) min_u = min(w/g, h/g) max_u = max(w/g, h/g) if min_u == 1: return all - g * max_u else: every_h = max_u / min_u not_use_box = math.ceil(max_u / min_u) * 2 for _ in range(int(min_u) - 2): up = math.ceil(every_h + max_u / min_u) down = math.floor(every_h) not_use_box += up - down every_h += max_u / min_u answer = all - (not_use_box * g) return answer print(solution(w,h)) #Return 80 . 80 . # 다른사람 풀이 - 수학적 사고력 이용 w = 8 h = 12 def solution(w,h): return w * h - (w/math.gcd(w, h) + h/math.gcd(w, h) - 1) * math.gcd(w, h) print(solution(w,h)) . 80.0 .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/03/python10.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/03/python10.html",
            "date": " • Nov 3, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Today I Learned 211103",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 시퀀스(1-1, 1-2, 1-3) . . What is python sequence? . 참조 : artofproblemsolving.com#:~:text=In%20Python%2C%20sequence%20is%20the%20generic%20term%20for%20an%20ordered%20set.&amp;text=Lists%20are%20the%20most%20versatile,new%20elements%20can%20be%20inserted.) . . &#51088;&#47308;&#54805;(Data type)&#51032; &#44396;&#48516; . &#49884;&#53248;&#49828; (Sequence; &#50672;&#49549;&#54805; &#51088;&#47196;&#54805;) . &#52968;&#53580;&#51060;&#45320;&#54805; | &#54540;&#47019;&#54805; . 컨테이너(Container; 서로 다른 자료형) [list, tuple, collections, deque]) | 플랫(Flat; 한개의 자료형) [str, bytes, bytearray, array.array, memoryview]) | . &#44032;&#48320;&#54805; | &#48520;&#48320;&#54805; . 가변형 [list, bytearray, array.array, memoryview, deque] | 불변형 [tuple, str, bytes] | . # for문을 이용한 리스트 생성 chars = &#39;+_)(*&amp;^%$#@!)&#39; code_list1 = [] for s in chars: # 유니코드 리스트 code_list1.append(ord(s)) print(&quot;for문 이용 : &quot;, code_list1) # 지능형 리스트(Comprehending Lists) ; 상대적으로 효율적임! code_list2 = [ord(s) for s in chars] print(&quot;comprehend : &quot;, code_list2) . for문 이용 : [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 41] comprehend : [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 41] . ord() &#54632;&#49688; :&#53945;&#51221;&#54620; &#54620; &#47928;&#51088;&#47484; &#50500;&#49828;&#53412; &#53076;&#46300; &#44050;&#51004;&#47196; &#48320;&#54872;&#54644;&#51452;&#45716; &#54632;&#49688;&gt; #### chr() &#54632;&#49688; :&#50500;&#49828;&#53412;&#53076;&#46300; &#44050;&#51012; &#47928;&#51088;&#47196; &#48320;&#54872;&#54644;&#51452;&#45716; &#54632;&#49688; (10&#51652;&#49688;, 16&#51652;&#49688; &#49324;&#50857; &#44032;&#45733;) . # Comprehending Lists + Map, Filter code_list3 = [ord(s) for s in chars if ord(s) &gt; 40] print(&quot;comprehend + if : &quot;, code_list3) code_list4 = list(filter(lambda x : x &gt; 40, map(ord, chars))) print(&quot;comprehend + filter, map : &quot;, code_list4) . comprehend + if : [43, 95, 41, 42, 94, 64, 41] comprehend + filter, map : [43, 95, 41, 42, 94, 64, 41] . # 원상 복구해서 검산 print([chr(s) for s in code_list1]) print([chr(s) for s in code_list2]) print([chr(s) for s in code_list3]) print([chr(s) for s in code_list4]) . [&#39;+&#39;, &#39;_&#39;, &#39;)&#39;, &#39;(&#39;, &#39;*&#39;, &#39;&amp;&#39;, &#39;^&#39;, &#39;%&#39;, &#39;$&#39;, &#39;#&#39;, &#39;@&#39;, &#39;!&#39;, &#39;)&#39;] [&#39;+&#39;, &#39;_&#39;, &#39;)&#39;, &#39;(&#39;, &#39;*&#39;, &#39;&amp;&#39;, &#39;^&#39;, &#39;%&#39;, &#39;$&#39;, &#39;#&#39;, &#39;@&#39;, &#39;!&#39;, &#39;)&#39;] [&#39;+&#39;, &#39;_&#39;, &#39;)&#39;, &#39;*&#39;, &#39;^&#39;, &#39;@&#39;, &#39;)&#39;] [&#39;+&#39;, &#39;_&#39;, &#39;)&#39;, &#39;*&#39;, &#39;^&#39;, &#39;@&#39;, &#39;)&#39;] . (&#44592;&#52488;) lambda &#54632;&#49688; &#51674;&#44256; &#45336;&#50612;&#44032;&#44592; . &#51060;&#47492;&#50630;&#45716; &#54632;&#49688;, &#51068;&#54924;&#49457; &#54632;&#49688; . 일반적인 함수 정의 에서, def plus(a, b) :print(a+b) -&gt; 함수 이름은 plus&gt; 람다함수에서 lambda x, y :x + y&gt; &gt; [예시] . (lambda x,y :x+y)(2, 10) =&gt; Output: 12&gt; &gt; f = lambda x:x*x&gt; f(2) =&gt; Output:4&gt; . [주의사항] . 파이썬 기본 Built-in function과 같은 이름의 함수를 설정하면 우선순위 상으로 내가 만든 함수가 우선되므로, 같은 이름의 함수를 사용하지 않도록! . (&#44592;&#52488;) map &#54632;&#49688; &#51674;&#44256; &#45336;&#50612;&#44032;&#44592; . map(function, iterable) . 첫 번째 매개변수로는 함수가 오고 두 번째 매개변수로는 반복 가능한 자료형(리스트, 튜플 등) . map 함수의 반환 값은 map객체(iterator)이기 때문에 해당 자료형을 list 혹은 tuple로 형 변환시켜주어야 함 . | 함수의 동작은 두 번째 인자로 들어온 반복 가능한 자료형 (리스트나 튜플)을 첫 번째 인자로 들어온 함수에 하나씩 집어넣어서 함수를 수행하는 함수 . | . [예시] . result2 = list(map(func_pow, [1, 2, 3, 4, 5])) . (&#44592;&#52488;) filter &#54632;&#49688; &#51674;&#44256; &#45336;&#50612;&#44032;&#44592; . filter(conditional fuction, iterable) . 두번째 인자로 넘어온 데이터 중에서 첫번째 인자로 넘어온 조건 함수를 만족하는 데이터만을 반환 . 첫번째 인자로 def로 함수를 정의한 함수 이름을 넘겨도 되고, 간단하게 lambda함수를 넘겨도 된다. . | filter 타입(iterator)으로 결과를 리턴하므로 해당 자료형을 list 혹은 tuple로 형 변환시켜주어야 함 . | . [예시] . for woman in filter(lambda u:u[&quot;sex&quot;] != &quot;M&quot;, users):&gt; print(woman) . [참고사항] . map 함수와 사용방법 동일하나, 함수의 결과가 참인지 거짓인지에 따라, 해당요소를 포함할지 결정하는 것이 차이점! . # Generator 생성 ## Generator는 한 번에 한 개의 항목을 생성(메모리 유지x) import array tuple_gen = (ord(s) for s in chars) print(tuple_gen) print(type(tuple_gen)) print(next(tuple_gen)) # 제네레이터 값을 보는 방법 (두가지 다 가능) print(next(tuple_gen)) print(next(tuple_gen)) print(next(tuple_gen)) print(next(tuple_gen)) print(next(tuple_gen)) print(tuple_gen.__next__()) print(tuple_gen.__next__()) print(tuple_gen.__next__()) print(tuple_gen.__next__()) print(tuple_gen.__next__()) print(tuple_gen.__next__()) print(tuple_gen.__next__()) print(tuple_gen.__next__()) # generator로 더이상 다음값이 없음 . &lt;generator object &lt;genexpr&gt; at 0x1044a2228&gt; &lt;class &#39;generator&#39;&gt; 43 95 41 40 42 38 94 37 36 35 64 33 41 . StopIteration Traceback (most recent call last) &lt;ipython-input-27-3a66ada14ac6&gt; in &lt;module&gt; 22 print(tuple_gen.__next__()) 23 print(tuple_gen.__next__()) &gt; 24 print(tuple_gen.__next__()) # generator로 더이상 다음값이 없음 StopIteration: . # Genertor로 array에 격납 array_gen = array.array(&#39;I&#39;, (ord(s) for s in chars)) print(array_gen) print(type(array_gen)) print(array_gen.tolist()) #리스트로 변환 . array(&#39;I&#39;, [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 41]) &lt;class &#39;array.array&#39;&gt; [43, 95, 41, 40, 42, 38, 94, 37, 36, 35, 64, 33, 41] . # Generator 예제 print((&#39;%s&#39; % c + str(n) for c in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] for n in range(1, 21))) . &lt;generator object &lt;genexpr&gt; at 0x1044a2408&gt; . # for문으로 Generator 출력해보면 이러함 for s in (&#39;%s&#39; % c + str(n) for c in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] for n in range(1, 21)): print(s, end = &#39; &#39;) . A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16 A17 A18 A19 A20 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 B15 B16 B17 B18 B19 B20 C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 C11 C12 C13 C14 C15 C16 C17 C18 C19 C20 D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 D12 D13 D14 D15 D16 D17 D18 D19 D20 . ### 리스트를 생성할 때 주의사항! marks1 = [[&#39;~&#39;] * 3 for _ in range(4)] marks2 = [[&#39;~&#39;] * 3] * 4 print(marks1) print(marks2) # when modified marks1[0][1] = &#39;X&#39; marks2[0][1] = &#39;X&#39; # print print(&quot;modified1 =&gt; &quot;, marks1) print(&quot;modified2 =&gt; &quot;, marks2) ### critical한 문제가 발생한다!!! # 원인을 증명해보자 print() print([id(i) for i in marks1]) print([id(i) for i in marks2]) # ID가 다 카피되어있다! -&gt; 주의할것!! . [[&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;]] [[&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;]] modified1 =&gt; [[&#39;~&#39;, &#39;X&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;~&#39;, &#39;~&#39;]] modified2 =&gt; [[&#39;~&#39;, &#39;X&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;X&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;X&#39;, &#39;~&#39;], [&#39;~&#39;, &#39;X&#39;, &#39;~&#39;]] [4367185864, 4367131976, 4366891400, 4367085000] [4366969736, 4366969736, 4366969736, 4366969736] .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/11/03/TIL211103.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/11/03/TIL211103.html",
            "date": " • Nov 3, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Today I Learned 211103",
            "content": ". . &#54532;&#47196;&#44536;&#47000;&#48141;&#51012; &#50948;&#54620; &#44592;&#52488; &#49345;&#49885; CPU&#50752; RAM . 키보드, 마우스, 모니터 등 =&gt; 입출력 장치 | 컴퓨터 본체 (시스템) =&gt; CPU / 주기억 장치 / 보조기억장치 로 구성 | . * CPU(Central Processing Unit)[&#51473;&#50521;&#52376;&#47532; &#51109;&#52824;] : &#47749;&#47161;&#52376;&#47532;, &#52980;&#54504;&#53552;&#50640;&#49436; &#44032;&#51109; &#51473;&#50836; . * RAM(Random Access Memory)[&#51452;&#44592;&#50613; &#51109;&#52824;] : &#49324;&#50857;&#51088;&#44032; &#51088;&#50976;&#47213;&#44172; &#45236;&#50857;&#51012; &#51069;&#44256; &#50416;&#44256; &#51648;&#50872; &#49688; &#51080;&#45716; &#44592;&#50613;&#51109;&#52824; . * HDD(Hard Disk Drive) &#12539; SSD(Solid State Drive) &#46321; [&#48372;&#51312;&#44592;&#50613; &#51109;&#52824;] : &#48372;&#51312;&#51060;&#48064;&#47196; &#50630;&#50612;&#46020; &#46041;&#51089;&#54616;&#44596; &#54616;&#45716; &#44592;&#50613; &#51109;&#52824; . . RAM&#50640; &#45824;&#54620; &#52628;&#44032;&#49444;&#47749; . # . 메모리는 구역별로 Stack, Heap, Data 등으로 분류해서 처리한다. | 전원 공급을 끊어버리면, 메모리에 저장된 내용은 휘발성으로 사라져버린다. | 나중에 쓰기 위해 저장하는 공간은, 보조기억장치 | . . I/O (input / output) . 하드디스크, 웹에서 파일, 키보드에서의 표준입력등이 시스템으로 들어오는 것을 INPUT이라고 한다. | 시스템에서 모니터나 파일 등으로 내보내는 것을 OUTPUT이라고 한다. | . . . . &#44032;&#48320; &#51064;&#49688; (*args) . # 키워드 인수 ; 가변적인 인수를 언패킹해서 전달하는 방법 def plus(x,y,z): return x+y+z a = plus(1,2,3) print(&quot;normal arguments =&gt;&quot;, a) num_list = [1,2,3] b = plus(*num_list) #리스트의 개별 값을 전달하기 위해서는 *(아스터리스크)를 붙인다. print(&quot;list arguments =&gt;&quot;, b) . normal arguments =&gt; 6 list arguments =&gt; 6 y = (1, 2, 3, 4) || *y = 1 2 3 4 . def plus2(*y): print(&quot; y = &quot;, y, &quot;|| *y = &quot;, *y) plus2(1,2,3,4) . y = (1, 2, 3, 4) || *y = 1 2 3 4 . def plus3(x, *y): number = x for i in range(x): print(&quot;x[&quot;, i, &quot;] = &quot;, y[i]) k = [40, 60, 50, 23, 100, 213] plus3(len(k), *k) # x는 고정, 그 뒤에는 전부 패킹되어서 튜플로 받음 . x[ 0 ] = 40 x[ 1 ] = 60 x[ 2 ] = 50 x[ 3 ] = 23 x[ 4 ] = 100 x[ 5 ] = 213 . . &#53412;&#50892;&#46300; &#44032;&#48320;&#51064;&#49688; (**kwargs) . # 사전형 예 d1 = {&quot;이름&quot; : &quot;박철수&quot;, &quot;나이&quot; : 20, &quot;직업&quot;:&quot;학생&quot;} d2 = {&quot;yellow&quot;:&quot;노랑&quot;, &quot;red&quot; :&quot;빨강&quot;, &quot;black&quot; :&quot;검정&quot;} print(&quot;items&quot;) print(d1.items()) print(d2.items()) print(&quot;keys&quot;) print(d1.keys()) print(d2.keys()) print(&quot;values&quot;) print(d1.values()) print(d2.values()) . items dict_items([(&#39;이름&#39;, &#39;박철수&#39;), (&#39;나이&#39;, 20), (&#39;직업&#39;, &#39;학생&#39;)]) dict_items([(&#39;yellow&#39;, &#39;노랑&#39;), (&#39;red&#39;, &#39;빨강&#39;), (&#39;black&#39;, &#39;검정&#39;)]) keys dict_keys([&#39;이름&#39;, &#39;나이&#39;, &#39;직업&#39;]) dict_keys([&#39;yellow&#39;, &#39;red&#39;, &#39;black&#39;]) values dict_values([&#39;박철수&#39;, 20, &#39;학생&#39;]) dict_values([&#39;노랑&#39;, &#39;빨강&#39;, &#39;검정&#39;]) . def Disp(**y): ## 사전형 앞에는 ** 두개를 붙여야 한다. for i, j in y.items(): print(i, &quot; ==&gt; &quot;, j) Disp(**d1) Disp(**d2) . 이름 ==&gt; 박철수 나이 ==&gt; 20 직업 ==&gt; 학생 yellow ==&gt; 노랑 red ==&gt; 빨강 black ==&gt; 검정 .",
            "url": "https://jaysung00.github.io/jays_blog/til/2021/11/03/TIL211103-2.html",
            "relUrl": "/til/2021/11/03/TIL211103-2.html",
            "date": " • Nov 3, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "파이썬 예제9) 문자열 압축",
            "content": ". # 내풀이.... =&gt; OK # 통과하긴 했으나, 상당히 어거지 ㅜㅜ s = &quot;aaaaaaaaaa&quot; def solution(s): answer = len(s) for d in range(1, len(s) // 2 + 1): list1 = [ s[k:k+d] for k in range(0, len(s), d) ] n = 0 i = 0 while i &lt; len(list1) - 1: if list1[i] == list1[i+1]: m = 0 while list1[i] == list1[i+1]: m += 1 del list1[i+1] if len(list1) == i+1: break if m &gt;= 999: n += 4 elif m &gt;= 99: n += 3 elif m &gt;= 9: n += 2 elif m &gt;= 1: n += 1 i += 1 if answer &gt; d * (len(list1) - 1) + len(list1[-1]) + n: answer = d * (len(list1) - 1) + len(list1[-1]) + n return answer print(solution(s)) . 3 . # 다른사람 풀이 def compress(text, tok_len): words = [text[i:i+tok_len] for i in range(0, len(text), tok_len)] res = [] cur_word = words[0] cur_cnt = 1 for a, b in zip(words, words[1:] + [&#39;&#39;]): if a == b: cur_cnt += 1 else: res.append([cur_word, cur_cnt]) cur_word = b cur_cnt = 1 return sum(len(word) + (len(str(cnt)) if cnt &gt; 1 else 0) for word, cnt in res) def solution(text): return min(compress(text, tok_len) for tok_len in list(range(1, int(len(text)/2) + 1)) + [len(text)]) a = [ &quot;aabbaccc&quot;, &quot;ababcdcdababcdcd&quot;, &quot;abcabcdede&quot;, &quot;abcabcabcabcdededededede&quot;, &quot;xababcdcdababcdcd&quot;, &#39;aaaaaa&#39;, ] for x in a: print(solution(x)) . 7 9 8 14 17 2 . # 위의 compress함수 분해. # 멋진 코드다. 배울 수 있도록! text = &quot;aabbaccc&quot; tok_len = 1 words = [text[i:i+tok_len] for i in range(0, len(text), tok_len)] res = [] cur_word = words[0] # 가장 처음단어 가리키는중 cur_cnt = 1 for a, b in zip(words, words[1:] + [&#39;&#39;]): # 하나씩 엇갈리게 만든 리스트를 zip으로 병렬처리함 ## zip은 병렬처리가 가능한 파이썬내장함수 if a == b: cur_cnt += 1 #같으면 카운트 1추가 else: res.append([cur_word, cur_cnt]) # 다를때 현재 단어와 카운트 개수 저장 cur_word = b # 다를 때의 뒷단어로 현재단어 이동 cur_cnt = 1 # 카운트 1로 초기화 print(res) sum(len(word) + (len(str(cnt)) if cnt &gt; 1 else 0) for word, cnt in res) . [] [[&#39;a&#39;, 2]] [[&#39;a&#39;, 2]] [[&#39;a&#39;, 2], [&#39;b&#39;, 2]] [[&#39;a&#39;, 2], [&#39;b&#39;, 2], [&#39;a&#39;, 1]] [[&#39;a&#39;, 2], [&#39;b&#39;, 2], [&#39;a&#39;, 1]] [[&#39;a&#39;, 2], [&#39;b&#39;, 2], [&#39;a&#39;, 1]] [[&#39;a&#39;, 2], [&#39;b&#39;, 2], [&#39;a&#39;, 1], [&#39;c&#39;, 3]] . 7 .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/02/python9.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/02/python9.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "파이썬 예제8) 오픈채팅방",
            "content": ". # 첫번째 시도 =&gt; OK # 전략 ; 1. 딕셔너리로 각 아이디 별 최종 닉네임을 보관 2. 아웃풋메세지 네임드튜플에 보관 # import from collections import namedtuple Output = namedtuple(&#39;Output&#39;, &#39;Command Id&#39;) record = [&quot;Enter uid1234 Muzi&quot;, &quot;Enter uid4567 Prodo&quot;, &quot;Leave uid1234&quot;, &quot;Enter uid1234 Prodo&quot;, &quot;Change uid4567 Ryan&quot;] def solution(record): answer = [] nickname_dic = {} output_order = [] for info in record: info_list = info.split() if len(info_list) == 3: nickname_dic[info_list[1]] = info_list[2] if info_list[0] != &quot;Change&quot;: output_order.append(Output(info_list[0], info_list[1])) for m in output_order: if m.Command == &#39;Enter&#39;: answer.append(nickname_dic[m.Id] + &quot;님이 들어왔습니다.&quot;) else: answer.append(nickname_dic[m.Id] + &quot;님이 나갔습니다.&quot;) return answer print(solution(record)) . [&#39;Prodo님이 들어왔습니다.&#39;, &#39;Ryan님이 들어왔습니다.&#39;, &#39;Prodo님이 나갔습니다.&#39;, &#39;Prodo님이 들어왔습니다.&#39;] . # 다른 사람 풀이 뜯어보기 def solution(record): answer = [] namespace = {} printer = {&#39;Enter&#39;:&#39;님이 들어왔습니다.&#39;, &#39;Leave&#39;:&#39;님이 나갔습니다.&#39;} for r in record: rr = r.split(&#39; &#39;) if rr[0] in [&#39;Enter&#39;, &#39;Change&#39;]: namespace[rr[1]] = rr[2] for r in record: if r.split(&#39; &#39;)[0] != &#39;Change&#39;: answer.append(namespace[r.split(&#39; &#39;)[1]] + printer[r.split(&#39; &#39;)[0]]) return answer .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/02/python8.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/02/python8.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "파이썬 예제7) 신규 아이디 추천",
            "content": ". * &#51221;&#44508;&#54364;&#54788;&#49885;&#51004;&#47196; &#53945;&#51221; &#47928;&#51088;&#50676;&#51012; &#52286;&#51008; &#46244; &#45796;&#47480; &#47928;&#51088;&#50676;&#47196; &#48148;&#44984;&#45716; &#48169;&#48277; . import re . re.sub(&#39;패턴&#39;, &#39;바꿀문자열&#39;, &#39;문자열&#39;, 바꿀횟수) . # 첫번째 시도 =&gt; OK import re new_id = &quot;....!@BaT#*..y.abcdefg-..hi..ijk__lm...&quot; def solution(new_id): # 1단계 new_id의 모든 대문자를 대응되는 소문자로 치환 answer = new_id.lower() # 2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거 answer = re.sub(&#39;[^a-z0-9-_.]&#39;, &#39;&#39;, answer) # 3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환 answer = re.sub(&#39;(([.]) 2{1,})&#39;, &#39;.&#39;, answer) # 4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거 [빈 문자열일 때 인덱스 예외처리] if (len(answer) &gt; 0) and (answer[0] == &#39;.&#39;): answer = answer[1:] if (len(answer) &gt; 0) and (answer[-1] == &#39;.&#39;): answer = answer[:-1] # 5단계 new_id가 빈 문자열이라면, new_id에 &quot;a&quot;를 대입 if answer == &#39;&#39;: answer = &#39;a&#39; # 6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거 if len(answer) &gt;= 16: answer = answer[:15] if (len(answer) &gt; 0) and (answer[-1] == &#39;.&#39;): answer = answer[:-1] # 7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙임 if len(answer) &lt;= 2: while len(answer) != 3: answer = answer + answer[-1] return answer print(solution(new_id)) . bat.y.abcdefg- . # 정규식을 통한 풀이 def solution(new_id): st = new_id st = st.lower() st = re.sub(&#39;[^a-z0-9 -_.]&#39;, &#39;&#39;, st) st = re.sub(&#39; .+&#39;, &#39;.&#39;, st) # + 는 한번이상 반복 st = re.sub(&#39;^[.]|[.]$&#39;, &#39;&#39;, st) # ^문자 | 문자$ 는 각각 맨 앞문자와 맨 뒤문자를 의미한다. st = &#39;a&#39; if len(st) == 0 else st[:15] st = re.sub(&#39;^[.]|[.]$&#39;, &#39;&#39;, st) st = st if len(st) &gt; 2 else st + &quot;&quot;.join([st[-1] for i in range(3-len(st))]) # list comprehension으로 리스트 생성한 후 join으로 구분자가 공백인 상태로 리스트를 합쳐 문자열로 만들고 + 로 문자열끼리 합쳐줬다 return st print(solution(new_id)) . bat.y.abcdefg- . # 단계 3에 대한 다른 풀이법 생각 st2 = &quot;...ab..c.&quot; while &#39;..&#39; in st2: st2 = st2.replace(&#39;..&#39;, &#39;.&#39;) print(st2) # answer 문자열에서 &#39;..&#39; 두개짜리 문자열을 in 으로 찾아서 존재한다면 계속해서 &#39;..&#39;를 &#39;.&#39;로 치환한다. # 비효율적인 움직임 일수 있지만 이해해둘 필요 있음 . .ab.c. .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/02/python7.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/11/02/python7.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Today I Learned 211102",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 매직 메소드(3-1, 3-2, 3-3) . . &#45936;&#51060;&#53552; &#47784;&#45944;(Data Model) . 참조 : https://docs.python.org/3/reference/datamodel.html . -&gt; Namedtuple 실습 . . &#44061;&#52404; -&gt; &#54028;&#51060;&#50028;&#51032; &#45936;&#51060;&#53552;&#47484; &#52628;&#49345;&#54868; . &#47784;&#46304; &#44061;&#52404; -&gt; id, type -&gt; value . # 일반적인 튜플 사용해서 두 점 사이의 거리 구하기 pt1 = (1.0, 5.0) pt2 = (2.5, 1.5) from math import sqrt l_leng1 = sqrt((pt1[0]-pt2[0]) ** 2 + (pt1[1]-pt2[1]) ** 2) print(&quot;Answer is&quot;, l_leng1) . Answer is 3.8078865529319543 . &#45348;&#51076;&#46300; &#53916;&#54540;&#51060;&#46976;? . 네임드튜플은 일반 튜플이 인덱스로 접근하는 것에 비해 이름으로 접근이 가능한 튜플을 말한다. . 공식 레퍼런스에서는 객체를 사용하는 것보다 튜플 활용을 추천하고 있다. 네임드 튜플이 유용한 이유는 다음과 같다. . 튜플의 기본 성질인 불변 객체 | 일반 객체 형태보다 적은 메모리 사용 | 다양한 접근법 지원 | Dictionary key와 같이 사용 | . # 네임드 튜플 사용해서 두 점 사이의 거리 구하기 # import from collections import namedtuple # 네임드 튜플 선언 # 1번째 인자 - namedtuple name # 2번째 인자 - field names Point = namedtuple(&#39;Point&#39;, &#39;x y&#39;) # -&gt; x,y가 key가 되는 튜플 (더욱 명시적이다) pt3 = Point(1.0, 5.0) pt4 = Point(2.5, 1.5) print(pt3, pt4, sep=&quot; n&quot;) print(pt3.x) # key로 참조 print(pt4[1]) # 기존 튜플 처럼 index로 참조하는 것도 물론 가능하나, 실수할 수 있으므로 key가 나음 l_leng2 = sqrt((pt3.x-pt4.x) ** 2 + (pt3.y-pt4.y) ** 2) print(&quot;Answer is&quot;, l_leng2) . Point(x=1.0, y=5.0) Point(x=2.5, y=1.5) 1.0 1.5 Answer is 3.8078865529319543 . # 네임드튜플의 여러가지 선언 방법 Point1 = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;]) Point2 = namedtuple(&#39;Point&#39;, &#39;x, y&#39;) Point3 = namedtuple(&#39;Point&#39;, &#39;x y&#39;) Point4 = namedtuple(&#39;Point&#39;, &#39;x y x class&#39;, rename=True) ## 중복된 키값 혹은 예약어같이 가질수 없는 키가 올 경우에는 rename=Ture 옵션이 필요하다 . # 출력 print(Point1, Point2, Point3, Point4) . &lt;class &#39;__main__.Point&#39;&gt; &lt;class &#39;__main__.Point&#39;&gt; &lt;class &#39;__main__.Point&#39;&gt; &lt;class &#39;__main__.Point&#39;&gt; . # Dict to Unpacking 딕셔너리로 받은 것을 네임도 튜플로 변환 temp_dict = {&#39;x&#39;: 75, &#39;y&#39;: 55} . # 객체생성 p1 = Point1(x=10, y=35) p2 = Point2(20, 40) p3 = Point3(45, y=20) p4 = Point4(10, 20, 30, 40) p5 = Point1(**temp_dict) ## Unpacking print(p1) print(p2) print(p3) print(p4) ## 알아서 rename해서 레이블 생성해줌 print(p5) . Point(x=10, y=35) Point(x=20, y=40) Point(x=45, y=20) Point(x=10, y=20, _2=30, _3=40) Point(x=75, y=55) . # 사용 print(p1[0] + p2[1]) print(p1.x + p2.y) x, y = p3 print(x, y) . 50 50 45 20 . ### 네임드 튜플 메소드 temp = [52, 38] # _make() : 새로운 객체 생성 p4 = Point1._make(temp) print(p4) # _fields : 필드 네임확인 print(p1._fields, p2._fields, p3._fields) # _asdict() : OrderedDict 반환 print(p1._asdict()) . Point(x=52, y=38) (&#39;x&#39;, &#39;y&#39;) (&#39;x&#39;, &#39;y&#39;) (&#39;x&#39;, &#39;y&#39;) OrderedDict([(&#39;x&#39;, 10), (&#39;y&#39;, 35)]) . # 실 사용 실습 # 긱 반에 20명이 있고, 4개의 반이 있다 (A1~20, B1~20, C1~20, D1~20) Classes = namedtuple(&#39;Classes&#39;, [&#39;rank&#39;, &#39;number&#39;]) . [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;11&#39;, &#39;12&#39;, &#39;13&#39;, &#39;14&#39;, &#39;15&#39;, &#39;16&#39;, &#39;17&#39;, &#39;18&#39;, &#39;19&#39;, &#39;20&#39;] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] . List Comprehension &#51060;&#46976;? . 리스트를 쉽게, 짧게 한 줄로 만들 수 있는 파이썬의 문법 . . [ (&#48320;&#49688;&#47484; &#54876;&#50857;&#54620; &#44050;) for (&#49324;&#50857;&#54624; &#48320;&#49688; &#51060;&#47492;) in (&#49692;&#54924;&#54624; &#49688; &#51080;&#45716; &#44050;) {if (&#51312;&#44148;&#47928;)}] . {}은 생략가능. . # 그룹 리스트 선언 numbers = [str(n) for n in range(1, 21)] ranks = &#39;A B C D&#39;.split() print(numbers) print(ranks) # List Comprehension students = [Classes(rank, number) for rank in ranks for number in numbers] print(len(students)) print(students) . [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;11&#39;, &#39;12&#39;, &#39;13&#39;, &#39;14&#39;, &#39;15&#39;, &#39;16&#39;, &#39;17&#39;, &#39;18&#39;, &#39;19&#39;, &#39;20&#39;] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 80 [Classes(rank=&#39;A&#39;, number=&#39;1&#39;), Classes(rank=&#39;A&#39;, number=&#39;2&#39;), Classes(rank=&#39;A&#39;, number=&#39;3&#39;), Classes(rank=&#39;A&#39;, number=&#39;4&#39;), Classes(rank=&#39;A&#39;, number=&#39;5&#39;), Classes(rank=&#39;A&#39;, number=&#39;6&#39;), Classes(rank=&#39;A&#39;, number=&#39;7&#39;), Classes(rank=&#39;A&#39;, number=&#39;8&#39;), Classes(rank=&#39;A&#39;, number=&#39;9&#39;), Classes(rank=&#39;A&#39;, number=&#39;10&#39;), Classes(rank=&#39;A&#39;, number=&#39;11&#39;), Classes(rank=&#39;A&#39;, number=&#39;12&#39;), Classes(rank=&#39;A&#39;, number=&#39;13&#39;), Classes(rank=&#39;A&#39;, number=&#39;14&#39;), Classes(rank=&#39;A&#39;, number=&#39;15&#39;), Classes(rank=&#39;A&#39;, number=&#39;16&#39;), Classes(rank=&#39;A&#39;, number=&#39;17&#39;), Classes(rank=&#39;A&#39;, number=&#39;18&#39;), Classes(rank=&#39;A&#39;, number=&#39;19&#39;), Classes(rank=&#39;A&#39;, number=&#39;20&#39;), Classes(rank=&#39;B&#39;, number=&#39;1&#39;), Classes(rank=&#39;B&#39;, number=&#39;2&#39;), Classes(rank=&#39;B&#39;, number=&#39;3&#39;), Classes(rank=&#39;B&#39;, number=&#39;4&#39;), Classes(rank=&#39;B&#39;, number=&#39;5&#39;), Classes(rank=&#39;B&#39;, number=&#39;6&#39;), Classes(rank=&#39;B&#39;, number=&#39;7&#39;), Classes(rank=&#39;B&#39;, number=&#39;8&#39;), Classes(rank=&#39;B&#39;, number=&#39;9&#39;), Classes(rank=&#39;B&#39;, number=&#39;10&#39;), Classes(rank=&#39;B&#39;, number=&#39;11&#39;), Classes(rank=&#39;B&#39;, number=&#39;12&#39;), Classes(rank=&#39;B&#39;, number=&#39;13&#39;), Classes(rank=&#39;B&#39;, number=&#39;14&#39;), Classes(rank=&#39;B&#39;, number=&#39;15&#39;), Classes(rank=&#39;B&#39;, number=&#39;16&#39;), Classes(rank=&#39;B&#39;, number=&#39;17&#39;), Classes(rank=&#39;B&#39;, number=&#39;18&#39;), Classes(rank=&#39;B&#39;, number=&#39;19&#39;), Classes(rank=&#39;B&#39;, number=&#39;20&#39;), Classes(rank=&#39;C&#39;, number=&#39;1&#39;), Classes(rank=&#39;C&#39;, number=&#39;2&#39;), Classes(rank=&#39;C&#39;, number=&#39;3&#39;), Classes(rank=&#39;C&#39;, number=&#39;4&#39;), Classes(rank=&#39;C&#39;, number=&#39;5&#39;), Classes(rank=&#39;C&#39;, number=&#39;6&#39;), Classes(rank=&#39;C&#39;, number=&#39;7&#39;), Classes(rank=&#39;C&#39;, number=&#39;8&#39;), Classes(rank=&#39;C&#39;, number=&#39;9&#39;), Classes(rank=&#39;C&#39;, number=&#39;10&#39;), Classes(rank=&#39;C&#39;, number=&#39;11&#39;), Classes(rank=&#39;C&#39;, number=&#39;12&#39;), Classes(rank=&#39;C&#39;, number=&#39;13&#39;), Classes(rank=&#39;C&#39;, number=&#39;14&#39;), Classes(rank=&#39;C&#39;, number=&#39;15&#39;), Classes(rank=&#39;C&#39;, number=&#39;16&#39;), Classes(rank=&#39;C&#39;, number=&#39;17&#39;), Classes(rank=&#39;C&#39;, number=&#39;18&#39;), Classes(rank=&#39;C&#39;, number=&#39;19&#39;), Classes(rank=&#39;C&#39;, number=&#39;20&#39;), Classes(rank=&#39;D&#39;, number=&#39;1&#39;), Classes(rank=&#39;D&#39;, number=&#39;2&#39;), Classes(rank=&#39;D&#39;, number=&#39;3&#39;), Classes(rank=&#39;D&#39;, number=&#39;4&#39;), Classes(rank=&#39;D&#39;, number=&#39;5&#39;), Classes(rank=&#39;D&#39;, number=&#39;6&#39;), Classes(rank=&#39;D&#39;, number=&#39;7&#39;), Classes(rank=&#39;D&#39;, number=&#39;8&#39;), Classes(rank=&#39;D&#39;, number=&#39;9&#39;), Classes(rank=&#39;D&#39;, number=&#39;10&#39;), Classes(rank=&#39;D&#39;, number=&#39;11&#39;), Classes(rank=&#39;D&#39;, number=&#39;12&#39;), Classes(rank=&#39;D&#39;, number=&#39;13&#39;), Classes(rank=&#39;D&#39;, number=&#39;14&#39;), Classes(rank=&#39;D&#39;, number=&#39;15&#39;), Classes(rank=&#39;D&#39;, number=&#39;16&#39;), Classes(rank=&#39;D&#39;, number=&#39;17&#39;), Classes(rank=&#39;D&#39;, number=&#39;18&#39;), Classes(rank=&#39;D&#39;, number=&#39;19&#39;), Classes(rank=&#39;D&#39;, number=&#39;20&#39;)] . # 추천방식 students2 = [Classes(rank, number) for rank in &#39;A B C D&#39;.split() for number in [str(n) for n in range(1, 21)]] print(students2) . [Classes(rank=&#39;A&#39;, number=&#39;1&#39;), Classes(rank=&#39;A&#39;, number=&#39;2&#39;), Classes(rank=&#39;A&#39;, number=&#39;3&#39;), Classes(rank=&#39;A&#39;, number=&#39;4&#39;), Classes(rank=&#39;A&#39;, number=&#39;5&#39;), Classes(rank=&#39;A&#39;, number=&#39;6&#39;), Classes(rank=&#39;A&#39;, number=&#39;7&#39;), Classes(rank=&#39;A&#39;, number=&#39;8&#39;), Classes(rank=&#39;A&#39;, number=&#39;9&#39;), Classes(rank=&#39;A&#39;, number=&#39;10&#39;), Classes(rank=&#39;A&#39;, number=&#39;11&#39;), Classes(rank=&#39;A&#39;, number=&#39;12&#39;), Classes(rank=&#39;A&#39;, number=&#39;13&#39;), Classes(rank=&#39;A&#39;, number=&#39;14&#39;), Classes(rank=&#39;A&#39;, number=&#39;15&#39;), Classes(rank=&#39;A&#39;, number=&#39;16&#39;), Classes(rank=&#39;A&#39;, number=&#39;17&#39;), Classes(rank=&#39;A&#39;, number=&#39;18&#39;), Classes(rank=&#39;A&#39;, number=&#39;19&#39;), Classes(rank=&#39;A&#39;, number=&#39;20&#39;), Classes(rank=&#39;B&#39;, number=&#39;1&#39;), Classes(rank=&#39;B&#39;, number=&#39;2&#39;), Classes(rank=&#39;B&#39;, number=&#39;3&#39;), Classes(rank=&#39;B&#39;, number=&#39;4&#39;), Classes(rank=&#39;B&#39;, number=&#39;5&#39;), Classes(rank=&#39;B&#39;, number=&#39;6&#39;), Classes(rank=&#39;B&#39;, number=&#39;7&#39;), Classes(rank=&#39;B&#39;, number=&#39;8&#39;), Classes(rank=&#39;B&#39;, number=&#39;9&#39;), Classes(rank=&#39;B&#39;, number=&#39;10&#39;), Classes(rank=&#39;B&#39;, number=&#39;11&#39;), Classes(rank=&#39;B&#39;, number=&#39;12&#39;), Classes(rank=&#39;B&#39;, number=&#39;13&#39;), Classes(rank=&#39;B&#39;, number=&#39;14&#39;), Classes(rank=&#39;B&#39;, number=&#39;15&#39;), Classes(rank=&#39;B&#39;, number=&#39;16&#39;), Classes(rank=&#39;B&#39;, number=&#39;17&#39;), Classes(rank=&#39;B&#39;, number=&#39;18&#39;), Classes(rank=&#39;B&#39;, number=&#39;19&#39;), Classes(rank=&#39;B&#39;, number=&#39;20&#39;), Classes(rank=&#39;C&#39;, number=&#39;1&#39;), Classes(rank=&#39;C&#39;, number=&#39;2&#39;), Classes(rank=&#39;C&#39;, number=&#39;3&#39;), Classes(rank=&#39;C&#39;, number=&#39;4&#39;), Classes(rank=&#39;C&#39;, number=&#39;5&#39;), Classes(rank=&#39;C&#39;, number=&#39;6&#39;), Classes(rank=&#39;C&#39;, number=&#39;7&#39;), Classes(rank=&#39;C&#39;, number=&#39;8&#39;), Classes(rank=&#39;C&#39;, number=&#39;9&#39;), Classes(rank=&#39;C&#39;, number=&#39;10&#39;), Classes(rank=&#39;C&#39;, number=&#39;11&#39;), Classes(rank=&#39;C&#39;, number=&#39;12&#39;), Classes(rank=&#39;C&#39;, number=&#39;13&#39;), Classes(rank=&#39;C&#39;, number=&#39;14&#39;), Classes(rank=&#39;C&#39;, number=&#39;15&#39;), Classes(rank=&#39;C&#39;, number=&#39;16&#39;), Classes(rank=&#39;C&#39;, number=&#39;17&#39;), Classes(rank=&#39;C&#39;, number=&#39;18&#39;), Classes(rank=&#39;C&#39;, number=&#39;19&#39;), Classes(rank=&#39;C&#39;, number=&#39;20&#39;), Classes(rank=&#39;D&#39;, number=&#39;1&#39;), Classes(rank=&#39;D&#39;, number=&#39;2&#39;), Classes(rank=&#39;D&#39;, number=&#39;3&#39;), Classes(rank=&#39;D&#39;, number=&#39;4&#39;), Classes(rank=&#39;D&#39;, number=&#39;5&#39;), Classes(rank=&#39;D&#39;, number=&#39;6&#39;), Classes(rank=&#39;D&#39;, number=&#39;7&#39;), Classes(rank=&#39;D&#39;, number=&#39;8&#39;), Classes(rank=&#39;D&#39;, number=&#39;9&#39;), Classes(rank=&#39;D&#39;, number=&#39;10&#39;), Classes(rank=&#39;D&#39;, number=&#39;11&#39;), Classes(rank=&#39;D&#39;, number=&#39;12&#39;), Classes(rank=&#39;D&#39;, number=&#39;13&#39;), Classes(rank=&#39;D&#39;, number=&#39;14&#39;), Classes(rank=&#39;D&#39;, number=&#39;15&#39;), Classes(rank=&#39;D&#39;, number=&#39;16&#39;), Classes(rank=&#39;D&#39;, number=&#39;17&#39;), Classes(rank=&#39;D&#39;, number=&#39;18&#39;), Classes(rank=&#39;D&#39;, number=&#39;19&#39;), Classes(rank=&#39;D&#39;, number=&#39;20&#39;)] . # 출력 for s in students2: print(s) . Classes(rank=&#39;A&#39;, number=&#39;1&#39;) Classes(rank=&#39;A&#39;, number=&#39;2&#39;) Classes(rank=&#39;A&#39;, number=&#39;3&#39;) Classes(rank=&#39;A&#39;, number=&#39;4&#39;) Classes(rank=&#39;A&#39;, number=&#39;5&#39;) Classes(rank=&#39;A&#39;, number=&#39;6&#39;) Classes(rank=&#39;A&#39;, number=&#39;7&#39;) Classes(rank=&#39;A&#39;, number=&#39;8&#39;) Classes(rank=&#39;A&#39;, number=&#39;9&#39;) Classes(rank=&#39;A&#39;, number=&#39;10&#39;) Classes(rank=&#39;A&#39;, number=&#39;11&#39;) Classes(rank=&#39;A&#39;, number=&#39;12&#39;) Classes(rank=&#39;A&#39;, number=&#39;13&#39;) Classes(rank=&#39;A&#39;, number=&#39;14&#39;) Classes(rank=&#39;A&#39;, number=&#39;15&#39;) Classes(rank=&#39;A&#39;, number=&#39;16&#39;) Classes(rank=&#39;A&#39;, number=&#39;17&#39;) Classes(rank=&#39;A&#39;, number=&#39;18&#39;) Classes(rank=&#39;A&#39;, number=&#39;19&#39;) Classes(rank=&#39;A&#39;, number=&#39;20&#39;) Classes(rank=&#39;B&#39;, number=&#39;1&#39;) Classes(rank=&#39;B&#39;, number=&#39;2&#39;) Classes(rank=&#39;B&#39;, number=&#39;3&#39;) Classes(rank=&#39;B&#39;, number=&#39;4&#39;) Classes(rank=&#39;B&#39;, number=&#39;5&#39;) Classes(rank=&#39;B&#39;, number=&#39;6&#39;) Classes(rank=&#39;B&#39;, number=&#39;7&#39;) Classes(rank=&#39;B&#39;, number=&#39;8&#39;) Classes(rank=&#39;B&#39;, number=&#39;9&#39;) Classes(rank=&#39;B&#39;, number=&#39;10&#39;) Classes(rank=&#39;B&#39;, number=&#39;11&#39;) Classes(rank=&#39;B&#39;, number=&#39;12&#39;) Classes(rank=&#39;B&#39;, number=&#39;13&#39;) Classes(rank=&#39;B&#39;, number=&#39;14&#39;) Classes(rank=&#39;B&#39;, number=&#39;15&#39;) Classes(rank=&#39;B&#39;, number=&#39;16&#39;) Classes(rank=&#39;B&#39;, number=&#39;17&#39;) Classes(rank=&#39;B&#39;, number=&#39;18&#39;) Classes(rank=&#39;B&#39;, number=&#39;19&#39;) Classes(rank=&#39;B&#39;, number=&#39;20&#39;) Classes(rank=&#39;C&#39;, number=&#39;1&#39;) Classes(rank=&#39;C&#39;, number=&#39;2&#39;) Classes(rank=&#39;C&#39;, number=&#39;3&#39;) Classes(rank=&#39;C&#39;, number=&#39;4&#39;) Classes(rank=&#39;C&#39;, number=&#39;5&#39;) Classes(rank=&#39;C&#39;, number=&#39;6&#39;) Classes(rank=&#39;C&#39;, number=&#39;7&#39;) Classes(rank=&#39;C&#39;, number=&#39;8&#39;) Classes(rank=&#39;C&#39;, number=&#39;9&#39;) Classes(rank=&#39;C&#39;, number=&#39;10&#39;) Classes(rank=&#39;C&#39;, number=&#39;11&#39;) Classes(rank=&#39;C&#39;, number=&#39;12&#39;) Classes(rank=&#39;C&#39;, number=&#39;13&#39;) Classes(rank=&#39;C&#39;, number=&#39;14&#39;) Classes(rank=&#39;C&#39;, number=&#39;15&#39;) Classes(rank=&#39;C&#39;, number=&#39;16&#39;) Classes(rank=&#39;C&#39;, number=&#39;17&#39;) Classes(rank=&#39;C&#39;, number=&#39;18&#39;) Classes(rank=&#39;C&#39;, number=&#39;19&#39;) Classes(rank=&#39;C&#39;, number=&#39;20&#39;) Classes(rank=&#39;D&#39;, number=&#39;1&#39;) Classes(rank=&#39;D&#39;, number=&#39;2&#39;) Classes(rank=&#39;D&#39;, number=&#39;3&#39;) Classes(rank=&#39;D&#39;, number=&#39;4&#39;) Classes(rank=&#39;D&#39;, number=&#39;5&#39;) Classes(rank=&#39;D&#39;, number=&#39;6&#39;) Classes(rank=&#39;D&#39;, number=&#39;7&#39;) Classes(rank=&#39;D&#39;, number=&#39;8&#39;) Classes(rank=&#39;D&#39;, number=&#39;9&#39;) Classes(rank=&#39;D&#39;, number=&#39;10&#39;) Classes(rank=&#39;D&#39;, number=&#39;11&#39;) Classes(rank=&#39;D&#39;, number=&#39;12&#39;) Classes(rank=&#39;D&#39;, number=&#39;13&#39;) Classes(rank=&#39;D&#39;, number=&#39;14&#39;) Classes(rank=&#39;D&#39;, number=&#39;15&#39;) Classes(rank=&#39;D&#39;, number=&#39;16&#39;) Classes(rank=&#39;D&#39;, number=&#39;17&#39;) Classes(rank=&#39;D&#39;, number=&#39;18&#39;) Classes(rank=&#39;D&#39;, number=&#39;19&#39;) Classes(rank=&#39;D&#39;, number=&#39;20&#39;) .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/11/02/TIL211102.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/11/02/TIL211102.html",
            "date": " • Nov 2, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "파이썬 예제6) 크레인 인형뽑기 게임",
            "content": ". # 첫번째 시도 (리스트 이용 -&gt; 시간초과 실패....) board = [[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]] moves = [1, 5, 3, 5, 1, 2, 1, 4] def solution(board, moves): n = len(board) in_col = [] # input column 리스트화 for m in moves: height = 0 while height &lt; n: if board[height][m - 1] == 0: height += 1 else: in_col.append(board[height][m - 1]) board[height][m - 1] = 0 break # answer 구하기 answer = 0 end_condition = False while end_condition == False: if len(in_col) == 0: end_condition = True for i in range(len(in_col) - 1): if in_col[i+1] == in_col[i]: answer += 2 end_condition = False del in_col[i:i+2] break; else: end_condition = True return answer print(solution(board, moves)) ## 런타임에러.... . 4 . #두 번째 시도 (스택구조 이용 -&gt; 성공) board = [[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]] moves = [1, 5, 3, 5, 1, 2, 1, 4] class Stack: #리스트를 이용하여 스택 생성 def __init__ (self): self.top = [] #스택의 크기를 출력 def __len__(self): return len(self.top) #스택 내부 자료를 string으로 변환하여 반환 def __str__(self): return str(self.top[::1]) #PUSH def push(self, item): self.top.append(item) #POP def pop(self): #if Stack is not empty if not self.isEmpty(): #pop and return return self.top.pop(-1) else: print(&quot;Stack underflow&quot;) exit() #스택이 비어있는지 확인 def isEmpty(self): return len(self.top)==0 #스택에서 top의 값을 읽어온다 def peek(self): if not self.isEmpty(): return self.top[-1] else: print(&quot;underflow&quot;) def solution(board, moves): n = len(board) answer = 0 in_stack = Stack() # input stack for m in moves: height = 0 while height &lt; n: if board[height][m - 1] == 0: height += 1 else: if in_stack.peek() == board[height][m - 1]: in_stack.pop() answer += 2 else: in_stack.push(board[height][m - 1]) board[height][m - 1] = 0 break return answer print(solution(board, moves)) . underflow 4 . # 좋은 풀이 뜯어보기 (굳이 스택구조를 만들지 않고 리스트를 충분히 스택처럼 사용할 수 있다) def solution(board, moves): stacklist = [] answer = 0 for i in moves: for j in range(len(board)): if board[j][i-1] != 0: stacklist.append(board[j][i-1]) board[j][i-1] = 0 if len(stacklist) &gt; 1: if stacklist[-1] == stacklist[-2]: stacklist.pop(-1) stacklist.pop(-1) answer += 2 break return answer .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/python6.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/python6.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "Today I Learned 211018",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 매직 메소드(1-1, 2-1, 2-2) . . &#54028;&#51060;&#50028;&#51032; &#54645;&#49900; . 시퀀스(Sequence) | 반복(Iterator) | 함수(Functions) | 클래스(Class) | . . &#47588;&#51649; &#47700;&#49548;&#46300; (&#49828;&#54168;&#49500; &#47700;&#49548;&#46300;)&#46976;? . 클래스 안에 정의할 수 있는 특별한 Built-in 메서드 . # 기본형 print(int) print(float) # 모든 속성 및 메소드 출력 print(dir(int)) print(dir(float)) . &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;, &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;, &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;, &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;] [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__bool__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getformat__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__set_format__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;as_integer_ratio&#39;, &#39;conjugate&#39;, &#39;fromhex&#39;, &#39;hex&#39;, &#39;imag&#39;, &#39;is_integer&#39;, &#39;real&#39;] . n = 10 print(n + 100) # 여기서 내부적으로 일어나는 일. print(n.__add__(100)) #int class의 매직메소드인 __add__가 호출됨 . 110 110 . print(bool(n), n.__bool__()) #내부적으로 일어나는 일 print(n * 100, n.__mul__(100)) . True True 1000 1000 . #클래스 예제1 class Fruit: def __init__(self, name, price): self._name = name self._price = price def __str__(self): return &#39;Fruit Class Info : {} , {}&#39;.format(self._name, self._price) def __add__(self, x): print(&#39;Called &gt;&gt; __add__&#39;) return self._price + x._price def __sub__(self, x): print(&#39;Called &gt;&gt; __sub__&#39;) return self._price - x._price def __le__(self, x): print(&#39;Called &gt;&gt; __le__&#39;) if self._price &lt;= x._price: return True else: return False def __ge__(self, x): print(&#39;Called &gt;&gt; __ge__&#39;) if self._price &gt;= x._price: return True else: return False . #인스턴스 생성 s1 = Fruit(&#39;Orange&#39;, 7500) s2 = Fruit(&#39;Banana&#39;, 3000) . #일반적인 계산 print(s1._price + s2._price) ##코드 양도 늘어나고 가독성도 떨어지므로 좋지않은 방식 . 10500 . # __add__ 매소드의 이용 print(s1 + s2) ## + 를 사용하므로써 __add__가 실행되는 빌트인 매직메소드 . Called &gt;&gt; __add__ 10500 . # 매직메소드 print(s1 &gt;= s2) print(s1 &lt;= s2) print(s1 - s2) print(s2 - s1) print(s1) ## __str__ print(s2) . Called &gt;&gt; __ge__ True Called &gt;&gt; __le__ False Called &gt;&gt; __sub__ 4500 Called &gt;&gt; __sub__ -4500 Fruit Class Info : Orange , 7500 Fruit Class Info : Banana , 3000 . &#48372;&#52649;&#51648;&#49885; . *args . 매개변수 앞에 애스터리스크(*)를 붙여주면, 여러개의 변수를 하나의 튜플로 묶어 패킹(packing)해줌 함수에 값을 넘길때, 리스트나 튜플같이 컨테이너형 변수에 애스터리스크를 붙이면 unpacking되어 전달된다. . **kwargs . 키와 밸류값을 가변적으로 패킹하여 전달받을 수 있다. . # 클래스 예제2 # 벡터를 다루는 클래스를 만들어보자 ## 예1) (5,2) + (4,3) = (9,5) ## 예2) (10,3) * 3 = (50,15) ## 예3) Max((5,10)) = 10 class Vector(object): def __init__(self, *args): # packing해서 넘겨받아 나중에 unpacking &#39;&#39;&#39; Create a vector, example : v = Vector(5,10) &#39;&#39;&#39; if len(args) == 0: self._x, self._y = 0, 0 else: self._x, self._y = args def __repr__(self): &#39;&#39;&#39;Returns the vector informations.&#39;&#39;&#39; return &#39;Vector(%r, %r)&#39; % (self._x, self._y) def __add__(self, other): &#39;&#39;&#39;Returns the vector addition of self and other&#39;&#39;&#39; return Vector(self._x + other._x, self._y + other._y) def __mul__(self, y): return Vector(self._x * y, self._y * y) def __bool__(self): return bool(max(self._x, self._y)) #좌표 평면에서 0,0인지 확인 print(Vector.__doc__) #클래스 자체의 주석은 없음 print(Vector.__init__.__doc__) #메소드 단위의 주석 . None Create a vector, example : v = Vector(5,10) . # Vector 인스턴스 생성 v1 = Vector(5,7) v2 = Vector(23, 53) v3 = Vector() . # 매직메소드 출력 print(Vector.__init__.__doc__) print(Vector.__repr__.__doc__) print(Vector.__add__.__doc__) print(v1, v2, v3) print(v1 + v2) print(v1 * 3) print(v2 * 10) print(bool(v1), bool(v2)) print(bool(v3)) . Create a vector, example : v = Vector(5,10) Returns the vector informations. Returns the vector addition of self and other Vector(5, 7) Vector(23, 53) Vector(0, 0) Vector(28, 60) Vector(15, 21) Vector(230, 530) True True False .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/10/18/TIL211018.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/10/18/TIL211018.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "파이썬 예제5) 이진수",
            "content": ". &#47928;&#51228; . 양의 정수 n이 주어졌을 때, 이를 이진수로 나타냈을 때 1의 위치를 모두 찾는 프로그램을 작성하시오. 최하위 비트(least significant bit, lsb)의 위치는 0이다. . &#51077;&#47141; . 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, n이 주어진다. (1 ≤ T ≤ 10, 1 ≤ n ≤ 106) . &#52636;&#47141; . 각 테스트 케이스에 대해서, 1의 위치를 공백으로 구분해서 줄 하나에 출력한다. 위치가 낮은 것부터 출력한다. . &#50696;&#51228; &#51077;&#47141; 1 . 1 13 . &#50696;&#51228; &#52636;&#47141; 1 . 0 2 3 . # 첫번째 시도 T = int(input()) for _ in range(T): position = 0 n = int(input()) while n != 0: if n % 2 == 1: print(position, end = &#39; &#39;) position += 1 n = n // 2 . 0 2 3 .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/BOJ3460.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/BOJ3460.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "파이썬 예제3) 알람시계",
            "content": ". &#47928;&#51228; . 상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다. . 상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다. . 이런 상근이를 불쌍하게 보던, 창영이는 자신이 사용하는 방법을 추천해 주었다. . 바로 &quot;45분 일찍 알람 설정하기&quot;이다. . 이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다. . 현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오. . &#51077;&#47141; . 첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다. . 입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다. . &#52636;&#47141; . 첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.) . 예제 입력 예제 출력 . 10 10 | 9 25 | . 0 30 | 23 45 | . 23 40 | 22 55 | . # 첫번째 시도 h, m = map(int, input().split()) if m &gt;= 45: m -= 45 elif (m &lt;= 45) and (h &gt;= 1): m += 15 h -= 1 else: m += 15 h = 23 print(h, m) #sep 디폴트 옵션은 공백하나, end 디폴트 옵션은 개행. . 22 55 .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/BOJ2884.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/BOJ2884.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "파이썬 예제4) Yangjojang of the year",
            "content": ". &#47928;&#51228; . 입학 OT때 누구보다도 남다르게 놀았던 당신은 자연스럽게 1학년 과대를 역임하게 되었다. . 타교와의 조인트 엠티를 기획하려는 당신은 근처에 있는 학교 중 어느 학교가 술을 가장 많이 먹는지 궁금해졌다. . 학교별로 한 해동안 술 소비량이 주어질 때, 가장 술 소비가 많은 학교 이름을 출력하여라. . &#51077;&#47141; . 입력의 첫 줄에는 테스트 케이스의 숫자 T가 주어진다. . 매 입력의 첫 줄에는 학교의 숫자 정수 N(1 ≤ N ≤ 100)이 주어진다. . 이어서 N줄에 걸쳐 학교 이름 S(1 ≤ |S| ≤ 20, S는 공백없는 대소문자 알파벳 문자열)와 해당 학교가 지난 한 해동안 소비한 술의 양 L(0 ≤ L ≤ 10,000,000)이 공백으로 구분되어 정수로 주어진다. . 같은 테스트 케이스 안에서 소비한 술의 양이 같은 학교는 없다고 가정한다. . &#52636;&#47141; . 각 테스트 케이스마다 한 줄에 걸쳐 술 소비가 가장 많은 학교의 이름을 출력한다. . &#50696;&#51228; &#51077;&#47141; 1 . 2 . 3 . Yonsei 10 . Korea 10000000 . Ewha 20 . 2 . Yonsei 1 . Korea 10000000 . &#50696;&#51228; &#52636;&#47141; 1 . Korea . Korea . # 첫번째 시도 -&gt; OK T = int(input()) for i in range(T): dic = {} N = int(input()) for num in range(N): S, L = input().split() dic[S] = int(L) print(max(dic, key=dic.get)) . Korea Korea .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/BOJ11557.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/18/BOJ11557.html",
            "date": " • Oct 18, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "Today I Learned 211017",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 클래스 &amp; 메소드 심화(3-1, 3-2) . # 클래스 선언 class Car(object): &#39;&#39;&#39; Car Class Author : Me Date : 2019.11.08 Description : Class, Static, Instance Method &#39;&#39;&#39; # Class Variable price_per_raise = 1.0 def __init__(self, company, details): self._company = company self._details = details def __str__(self): return &#39;str : {} - {}&#39;.format(self._company, self._details) def __repr__(self): return &#39;repr : {} - {}&#39;.format(self._company, self._details) # Instance Method # self : 객체의 고유한 속성 값 사용 def detail_info(self): print(&#39;Current Id : {}&#39;.format(id(self))) print(&#39;Car Detail Info : {} {}&#39;.format(self._company, self._details.get(&#39;price&#39;))) # Instance Method def get_price(self): return &#39;Before Car Price -&gt; company : {}, price : {}&#39;.format(self._company, self._details.get(&#39;price&#39;)) # Instance Method def get_price_culc(self): return &#39;After Car Price -&gt; company : {}, price : {}&#39;.format(self._company, self._details.get(&#39;price&#39;) * Car.price_per_raise) # Class Method @classmethod # decorator def raise_price(cls, per): # 클래스메소드는 self 대신 cls를 받는다. if per &lt;= 1: print(&#39;Please Enter 1 or More&#39;) return cls.price_per_raise = per print(&#39;Succeed! price increased.&#39;) # Static Method @staticmethod def is_bmw(inst): # 아무것도 인수로 받지 않는다.. 그러나 필요성에 대해서는 의문 if inst._company == &#39;Bmw&#39;: return &#39;OK! This car is {}.&#39;.format(inst._company) return &#39;Sorry. This car is not Bmw.&#39; . # 자동차 인스턴스 car1 = Car(&#39;Bmw&#39;, {&#39;color&#39; : &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}) car2 = Car(&#39;Audi&#39;, {&#39;color&#39; : &#39;Silver&#39;, &#39;horsepower&#39;: 300, &#39;price&#39;: 6000}) . # 전체정보 car1.detail_info() car2.detail_info() . Current Id : 4558480720 Car Detail Info : Bmw 5000 Current Id : 4558481560 Car Detail Info : Audi 6000 . # 가격 정보(인상 전) print(car1.get_price()) print(car2.get_price()) . Before Car Price -&gt; company : Bmw, price : 5000 Before Car Price -&gt; company : Audi, price : 6000 . # 가격 인상(클래스 메소드 미사용) Car.price_per_raise = 1.2 . # 가격 정보(인상 후) print(car1.get_price_culc()) print(car2.get_price_culc()) print() . After Car Price -&gt; company : Bmw, price : 6000.0 After Car Price -&gt; company : Audi, price : 7200.0 . # 가격 인상(클래스 메소드 사용) Car.raise_price(1.6) # 가격 정보(인상 후 : 클래스메소드) print(car1.get_price_culc()) print(car2.get_price_culc()) print() . Succeed! price increased. After Car Price -&gt; company : Bmw, price : 8000.0 After Car Price -&gt; company : Audi, price : 9600.0 . # Bmw 여부(스테이틱 메소드 미사용) def is_bmw(inst): if inst._company == &#39;Bmw&#39;: return &#39;OK! This car is {}.&#39;.format(inst._company) return &#39;Sorry. This car is not Bmw.&#39; # 별도의 메소드 작성 후 호출 print(is_bmw(car1)) print(is_bmw(car2)) . OK! This car is Bmw. Sorry. This car is not Bmw. . # Bmw 여부(스테이틱 메소드 사용) print(&#39;Static : &#39;, Car.is_bmw(car1)) print(&#39;Static : &#39;, Car.is_bmw(car2)) print() print(&#39;Static : &#39;, car1.is_bmw(car1)) print(&#39;Static : &#39;, car2.is_bmw(car2)) . Static : OK! This car is Bmw. Static : Sorry. This car is not Bmw. Static : OK! This car is Bmw. Static : Sorry. This car is not Bmw. .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/10/17/TIL211017_2.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/10/17/TIL211017_2.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "Today I Learned 211017",
            "content": ". &#51064;&#54532;&#47088; &#54028;&#51060;&#50028; &#51473;&#44553; (Inflearn Original) . 클래스 &amp; 메소드 심화(2-1, 2-2) . # 클래스 재 선언 class Car(): &quot;&quot;&quot; Car Class Author : Kim Date : 2019.11.08 &quot;&quot;&quot; # 클래스 변수 (모든 인스턴스가 공유) car_count = 0 def __init__(self, company, details): self._company = company self._details = details Car.car_count += 1 def __str__(self): return &#39;str : {} - {}&#39;.format(self._company, self._details) def __repr__(self): return &#39;repr : {} - {}&#39;.format(self._company, self._details) def detail_info(self): print(&#39;Current Id : {}&#39;.format(id(self))) print(&#39;Car Detail Info : {} {}&#39;.format(self._company, self._details.get(&#39;price&#39;))) def __del__(self): Car.car_count -= 1 . car1 = Car(&#39;Ferrari&#39;, {&#39;color&#39; : &#39;White&#39;, &#39;horsepower&#39;: 400, &#39;price&#39;: 8000}) car2 = Car(&#39;Bmw&#39;, {&#39;color&#39; : &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}) car3 = Car(&#39;Audi&#39;, {&#39;color&#39; : &#39;Silver&#39;, &#39;horsepower&#39;: 300, &#39;price&#39;: 6000}) . # dir 확인 print(dir(car1)) print(dir(car2)) # 매직메서드를 포함한 모든 어트리뷰트 포함 . [&#39;__class__&#39;, &#39;__del__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_company&#39;, &#39;_details&#39;, &#39;car_count&#39;, &#39;detail_info&#39;] [&#39;__class__&#39;, &#39;__del__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_company&#39;, &#39;_details&#39;, &#39;car_count&#39;, &#39;detail_info&#39;] . # __dict__ 확인 print(car1.__dict__) print(car2.__dict__) #딕셔너리 형태로 실제로 사용중인 것만 키와 밸류로 들여다볼수 있음 #네임스페이스 . {&#39;_company&#39;: &#39;Ferrari&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;White&#39;, &#39;horsepower&#39;: 400, &#39;price&#39;: 8000}} {&#39;_company&#39;: &#39;Bmw&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}} . # Doctring print(Car.__doc__) #클래스 내의 설명부분 주석을 보여줌 . Car Class Author : Kim Date : 2019.11.08 . # 메서드 실행 car1.detail_info() car2.detail_info() # 에러 # Car.detail_info() . Current Id : 4361860096 Car Detail Info : Ferrari 8000 Current Id : 4361860152 Car Detail Info : Bmw 5000 . # 비교 print(car1.__class__, car2.__class__) print(id(car1.__class__), id(car2.__class__)) ## 부모에서 나오기 떄문에 아이디는 모두 같다 . &lt;class &#39;__main__.Car&#39;&gt; &lt;class &#39;__main__.Car&#39;&gt; 140610028679592 140610028679592 . # 인스턴스 변수 # 직접 접근(PEP 문법적으로 권장X) print(car1._company, car2._company) print(car2._company, car3._company) . Ferrari Bmw Bmw Audi . # 클래스 변수 # 접근 print(car1.car_count) print(car2.car_count) print(Car.car_count) . 3 3 3 . # 공유 확인 print(Car.__dict__) print(car1.__dict__) print(car2.__dict__) print(car3.__dict__) . {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: &#39; n Car Class n Author : Kim n Date : 2019.11.08 n &#39;, &#39;car_count&#39;: 3, &#39;__init__&#39;: &lt;function Car.__init__ at 0x103f1b6a8&gt;, &#39;__str__&#39;: &lt;function Car.__str__ at 0x103f1b1e0&gt;, &#39;__repr__&#39;: &lt;function Car.__repr__ at 0x103f1b378&gt;, &#39;detail_info&#39;: &lt;function Car.detail_info at 0x103f1b730&gt;, &#39;__del__&#39;: &lt;function Car.__del__ at 0x103f1b598&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Car&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Car&#39; objects&gt;} {&#39;_company&#39;: &#39;Ferrari&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;White&#39;, &#39;horsepower&#39;: 400, &#39;price&#39;: 8000}} {&#39;_company&#39;: &#39;Bmw&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;Black&#39;, &#39;horsepower&#39;: 270, &#39;price&#39;: 5000}} {&#39;_company&#39;: &#39;Audi&#39;, &#39;_details&#39;: {&#39;color&#39;: &#39;Silver&#39;, &#39;horsepower&#39;: 300, &#39;price&#39;: 6000}} . # 인스턴스 네임스페이스 없으면 상위에서 검색 # 즉, 동일한 이름으로 변수 생성 가능(인스턴스 검색 후 -&gt; 상위(클래스 변수, 부모 클래스 변수)) del car2 print(car1.car_count) print(Car.car_count) . 2 2 .",
            "url": "https://jaysung00.github.io/jays_blog/engineering%09%20%3E%09a.%20python%09%20%3E%09b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/10/17/TIL211017.html",
            "relUrl": "/engineering%09%20%3E%09a.%20python%09%20%3E%09b.%20%EC%9D%B8%ED%94%84%EB%9F%B0%20%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B0%95%EC%9D%98/2021/10/17/TIL211017.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "파이썬 예제2) 완주하지 못한 선수",
            "content": ". Description . 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. . 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. . &#51228;&#54620;&#49324;&#54637; . 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. . &#51077;&#52636;&#47141; &#50696; . participant completion return . [&quot;leo&quot;, &quot;kiki&quot;, &quot;eden&quot;] | [&quot;eden&quot;, &quot;kiki&quot;] | &quot;leo&quot; | . [&quot;marina&quot;, &quot;josipa&quot;, &quot;nikola&quot;, &quot;vinko&quot;, &quot;filipa&quot;] | [&quot;josipa&quot;, &quot;filipa&quot;, &quot;marina&quot;, &quot;nikola&quot;] | &quot;vinko&quot; | . [&quot;mislav&quot;, &quot;stanko&quot;, &quot;mislav&quot;, &quot;ana&quot;] | [&quot;stanko&quot;, &quot;ana&quot;, &quot;mislav&quot;] | &quot;mislav&quot; | . 입출력 예 설명 . 예제 #1 . &quot;leo&quot;는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. . 예제 #2 . &quot;vinko&quot;는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. . 예제 #3 . &quot;mislav&quot;는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. . participant = [&quot;leo&quot;, &quot;kiki&quot;, &quot;eden&quot;] completion = [&quot;eden&quot;, &quot;kiki&quot;] . # 첫번째 시도 def solution(participant, completion): for i in range(len(completion)): participant.remove(completion[i]) answer = participant[0] return answer print(solution(participant, completion)) # 정답은 무사히 나오지만 해시 구조를 사용하지 않았으므로, 효율성 면에서 오답처리 . leo . 해시란? . 해시(hash)란 데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 자료구조이다. 이 때 매핑 전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing)라고 한다. . # 풀이 1 # 해시 def solution(participant, completion): hash = {} for i in participant: if i in hash: hash[i] += 1 else: hash[i] = 1 for i in completion: if hash[i] == 1: del hash[i] else: hash[i] -= 1 answer = list(hash.keys())[0] return answer print(solution(participant, completion)) . leo . # 풀이 2 # 데이터의 개수를 셀 때 유용한 파이썬의 collections 모듈의 Counter 클래스 사용 import collections def solution(participant, completion): answer = collections.Counter(participant) - collections.Counter(completion) return list(answer.keys())[0] print(solution(participant, completion)) . leo . # 풀이 3 # 별도의 풀이. 정렬해서 다른 부분에서 찾는 방법 def solution(participant, completion): participant.sort() completion.sort() for i in range(len(completion)): if participant[i] != completion[i]: return participant[i] return participant[len(participant)-1] print(solution(participant, completion)) . [&#39;eden&#39;, &#39;kiki&#39;, &#39;leo&#39;] [&#39;eden&#39;, &#39;kiki&#39;] leo .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/17/PGM_hash1.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/17/PGM_hash1.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "파이썬 예제1) A+B",
            "content": ". 문제 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. . 입력 첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10) . 출력 첫째 줄에 A+B를 출력한다. . 예제 입력 1 1 2 예제 출력 1 3 . # 첫번째 시도 a = input() # 1 b = input() # 2 print(a + b) # int 형으로 인식되지 않는다 . 12 . type(a) . str . # 개선1 a = int(input()) b = int(input()) print(a + b) # int형으로 인식되나, 한줄에 입력받지 못함 . ValueError Traceback (most recent call last) &lt;ipython-input-11-625471334fa1&gt; in &lt;module&gt; 1 # 개선1 -&gt; 2 a = int(input()) 3 b = int(input()) 4 5 print(a + b) # int형으로 인식되나, 한줄에 입력받지 못함 ValueError: invalid literal for int() with base 10: &#39;1 2&#39; . # 개선2 a, b = input().split() print(int(a) + int(b)) . 3 . split&#51012; &#51060;&#50857;&#54644;&#49436; &#54620; &#51460;&#47196; &#51077;&#47141;&#48155;&#45716; &#44163;&#51060; &#44032;&#45733;&#54664;&#45796;. . 한 번에 값을 여러 개 입력받으려면 input에서 split을 사용한 변수 여러 개에 저장해주면 된다. . 변수1, 변수2 = input().split() | 변수1, 변수2 = input().split(&#39;기준문자열&#39;) | 변수1, 변수2 = input(&#39;문자열&#39;).split() | 변수1, 변수2 = input(&#39;문자열&#39;).split(&#39;기준문자열&#39;) | . # 개선3 a, b = map(int, input().split()) print(a + b) . 3 . map&#51012; &#51060;&#50857;&#54644;&#49436; &#45908;&#50865; &#44036;&#45800;&#54616;&#44172; . map에 int와 input().split()을 넣으면 split의 결과를 모두 int로 변환해줌 . 변수1, 변수2 = map(int, input().split()) | 변수1, 변수2 = map(int, input().split(&#39;기준문자열&#39;)) | 변수1, 변수2 = map(int, input(&#39;문자열&#39;).split()) | 변수1, 변수2 = map(int, input(&#39;문자열&#39;).split(&#39;기준문자열&#39;)) | .",
            "url": "https://jaysung00.github.io/jays_blog/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/16/BOJ1000_A+B.html",
            "relUrl": "/eng%20%3E%20a.%20python%20%3E%20a.%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/2021/10/16/BOJ1000_A+B.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "Bayesian Networkとは何か？ ①",
            "content": ". &#12505;&#12452;&#12472;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#65288;BN; Bayesian Network&#65289;&#12392;&#12399;? . 確率変数（RV;Random variables）間の条件付き独立などの関係を見せることにより、RVのfull joint distributionなどを簡潔に表現できるグラフ表記法（Graphical Notation）である。 | . . &#29992;&#35486;&#12398;&#35500;&#26126; . ここで グラフ（Graph） とは、数学においてチャート（Chart）と対照されて定義された nodeとedgeの集合 . | edgeの方向が指定されていればdirected、そうでなければundirected . | グラフの全てのedgeがdirectedの時、directed graph . | directed edgeにおいて、始まる側のノードをparent nodeとし、反対側はchild nodeと言う。 . | つながっている複数のdirected edgeの方向が同じ場合、これをdirected pathとし、directed pathの最初のノードは経路上のすべてのノードのancestor nodeであり、逆に残りのノードは最初のノードのdescendant nodeである。 . | directed pathの開始点と終了点が一致する場合はこれをcyclic、そうでない場合はacyclicと呼ぶ。 . | . . &#12505;&#12540;&#12472;&#12517;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#65288;BN&#65289; &#12398;&#26465;&#20214; . NetworkはNodeと彼らを繋ぐEdgeで構成されている。 . | 方向性の非循環グラフ（DAG; Directed Acyclic Graph）である。 . | 個別のNodeはRVである$X$に対して$ bf P(X | Paranets(X))$を意味する。 . | 個別のEdgeとは親が子供に与える直接的な影響（Direct Influence） を意味する。 . | . . . &#12414;&#12378;&#30906;&#29575;&#12395;&#38306;&#12377;&#12427;&#31777;&#21336;&#12394;&#24489;&#32722;&#12363;&#12425; . ベージュアンネットワークというものは結局確率変数（RV）間の関係を表現したものである。 | 確率というのは相対的な頻度である。 | . . 独立性 （Independence） . $P(A|B) = P(A)$ $ Leftrightarrow P(A,B) = P(A)P(B)$ $ Leftrightarrow P(B|A) = P(B) $; A とB が独立ならば、B はA と独立である。 . 事象Bが発生したという情報は、事象Aが発生する確率に追加的な情報を提供しない。 . | これは、下述のConditional Independence と対立する意味で Marginal Independence と言える。 . | . | . . 条件付き独立（Conditional Independence） . $P(A|B,C) = P(A|C)$ . 事象Cが与えられたときに二つの事象AとBが独立なら、これはCという条件の下で条件付き独立 である。 | . | . . 条件付き確率（Conditional Probability） . $P(A= true|B=true)$ . &quot;Probablity of A given B&quot; . | Bが与えられた時、Aの確率 . | . | . 結合確率（joint Probability） . $P(A= true, B=true)$ . &quot;the probability of A=true and B=true&quot; . | A=trueとB=trueが同時に満足できる確率 . | 条件付き確率と結合確率の関係は一般に、$P(X|Y) = cfrac{P(X,Y)}{P(Y)}$ . | . | . 総確率法則（Law of Total Probability） . &quot;Summing out&quot; or &quot;Marginalization&quot; . | $P(A) = sum_kP(A,B_k) = sum_kP(A|B_k)P(B_k)$ . $P(A) = sum_kP(A,B_k)$は$B_1,B_2,...,B_n$がそれぞれ相互背反的な集合であり、これらの和集合が全体集合となるので成立（marginalize） . | $ sum_kP(A,B_k) = sum_kP(A|B_k)P(B_k)$は条件付き確率と結合確率の関係を利用すると誘導可能 . | . | これによる利点は、$P(A)$を直接求めるより、$P(A|B_k)$のような条件付き確率を求めて合わせることが一般的により容易であることである。 . | あるいは結合確率を知っている時、様々な確率が計算できる。 . 例えば、結合確率である$P(a,b,c,d)$を知っているとき、$P(c|b)$は以下のように表せる。 . | $P(c|b) = sum_a sum_d P(a,c,d|b) = cfrac{1}{P(b)} sum_a sum_d { bf P(a,b,c,d)}$ . | しかし、jointの場合にはparameterの数がexponentialに増えることになる！ （Chain Ruleの必要性） . | . | . . 確率の連鎖法則（Chain Rule for probability） . 全てのjoint distribution について、結合確率と条件付き確率の関係により常に以下のように表せる。 . | $P(a,b,c,...,z) = P(a|b,c,...,z)P(b,c,....,z)$ . | これを繰り返すと、$P(a,b,c,...,z) = P(a|b,c,...,z)P(b|c,...,z)P(c|d,...,z)...P(z)$で表現可能（Factorization） . | . . 乗分解法則（Rule of product decomposition） . Bayesian Networkでは、グラフに属するRVの結合分布（joint distribution）は、familyのすべての条件付き分布$P(Child|Parent)$の乗$^{[*1]}$で表現できる。 （次のポストのFactorization of Bayes Networkの内容を参照されたい） . | $P(x_1,x_2,...,x_n) = prod _iP(x_i|Parents(x_i))$ （Parentsは直接的に接続されて影響を受ける変数だけを意味） . 例えば、$X rightarrow Y rightarrow Z$ のグラフで$P(X=x,Y=y,Z=z)$を求めることを考えてみよう . | 本来は可能なすべての組み合わせの$(x, y, z)$に該当する確率テーブルを作らなければならない . | しかし、この法則を利用すると$P(X=x,Y=y,Z=z) = P(X=x)P(Y=y|X=x)P(Z=z|Y=y)$で簡潔に表現可能 . | このように高次元を低次元にすることで次元の呪い（curse of dimensionality）からも比較的自由になることができる。 . | . | . . $^{[*1]}:$ このように表現可能な理由は、後述するベイジアンネットワークのTypical Local Structures Rules に関連している。 . . &#12505;&#12452;&#12472;&#12450;&#12531;&#12493;&#12483;&#12488;&#12527;&#12540;&#12463;&#12398;Rules of Typical Local Structures . . Rule 1. 鎖または滝型（Chain or Cascading） . . 変数$X$と変数$Y$の間で一つの方向性経路だけがあって変数$Z$が当該経路を塞いでいるとき、$Z$が条件付きで与えられると、二つの変数$X$と$Y$は条件付き独立 である。 . | $X perp Y|Z$ $ Leftrightarrow P(Y|X,Z) = P(Y|Z)$ . | . . Rule 2. 分岐あるいは共通の親型（Fork or Common parent） . . 変数$Z$が$X$と$Y$の共通原因で、$X$と$Y$の間にたった一つの経路があるとき、$Z$の条件が与えられると、$X$と$Y$は条件付き独立 である。 . | $X perp Y|Z$ $ Leftrightarrow P(X,Y|Z) = P(X|Z)P(Y|Z)$ . | . . Rule 3.衝突部あるいはV-構造(Collider or V-structure) . . 変数$Z$が二つの変数$X$と$Y$の間の衝突ノードで、$X$と$Y$の間でたった一つの経路だけあるとき、$X$と$Y$は非条件付き独立（underconditionally independent） である。しかし、$Z$または$Z$のdescendantを条件付きにした場合、$X$と$Y$は従属となる可能性 がある。 . | $ sim (X perp Y|Z)$ $ Leftrightarrow P(X,Y,Z)=P(X)P(Y)P(Z|X,Y)$ . | つまり$Z$が not given の時は独立だが、逆に$Z$がgivenで与えられれば$X$、$Y$が従属となる可能性が生じてしまう。 . | . . . Bayes Ball Algorithm . 目的：$X perp Y | Z$（$Z$がgivenの場合、$X$と$Y$が独立）が成立するかどうかを判定するためのアルゴリズム . | $X$からボールが出発すると仮定した時、 $Y$までボールが到達するかを確認する方法 . | ここでボールはInformationを意味し、矢印はボールの動きを意味する。ノード間が直接的なedgeで結ばれていなくても、ボールが転がって到達できるならIndirect influenceが存在するため、2つの変数はdepedentであることを意味する。 . | . . Rule 1の場合 . (1) $Z$がgivenでない時、ボールは通ることができる。 ($X, Y$は従属) . . (2) $Z$が given の時、ボールは通れない。 ($X perp Y|Z$) . . . Rule 2の場合 . (1) $Z$がgivenでない時、ボールは通ることができる。 ($X, Y$は従属) . . (2) $Z$が given の時、ボールは通れない。 ($X perp Y|Z$) . . . Rule 3の場合 . (1) $Z$が givenでない時、ボールは通れない。 ($ bf X perp Y$) . . (2) $X_C$がgivenであるとき、逆にpathができてボールが通ることができるようになる。 ($X, Y$は従属 $|Z$) . . . . Bayes Ball Algorithm&#12398;&#20363;&#38988; . . 問題 1. $X_1 perp X_4|X_2$ . 二つの経路でボールを転がすことができる。 . (1) $X_1 rightarrow{ bf X_2} (given) rightarrow X_4$の経路は$X_2$が鎖のgivenで塞がれているので通ることができない。 . (2) $X_1 rightarrow X_3 rightarrow X_5 rightarrow X_6 leftarrow{ bf X_2}(given) rightarrow X_4$の経路は$X_6$が衝突部のnot givenで塞がれているので通ることができない。 . 従って、いかなる経路でもボールは通れないので$X_2$がgivenのとき$X_1$と$X_4$は独立 である。 . | . . 問題 2. $X_2 perp X_5|X_1$ | . 二つの経路でボールを転がすことができる。 . (1) $X_2 rightarrow X_6 leftarrow X_5$ の経路は$X_6$が衝突部のnot givenで塞がれているので通れない。 . (2) $X_2 leftarrow{ bf X_1}(given) rightarrow X_3 rightarrow X_5$の経路は$X_1$が分岐のdivenで塞がれているので通れない。 . 従って、どんな経路でもボールは通れないので$X_1$がgivenのとき$X_2$と$X_5$は独立 である。 . . 問題 3. $X_1 perp X_6| {X_2, X_3 } $ | . 二つの経路でボールを転がすことができる。 . (1) $X_1 rightarrow{ bf X_2}(given) rightarrow X_6$の経路は$X_2$が鎖のgivenで塞がれているので通ることができない。 . (2) $X_1 rightarrow{ bf X_3}(given) rightarrow X_5 rightarrow X_6$の経路は$X_3$が鎖のgivenで塞がれているので通れない。 . 従って、いかなる経路でもボールは通れないので、$ {X_2, X_3 }$がgivenのとき$X_1$と$X_6$は独立 である。 . . 問題 4. $X_2 perp X_3| {X_1, X_6 } $ | . 二つの経路でボールを転がすことができる。 . (1) $X_2 leftarrow{ bf X_1}(given) rightarrow X_3$ の経路は$X_1$が分岐のgivenで塞がれているので通れない。 . (2) $X_2 rightarrow{ bf X_6}(given) leftarrow X_5 leftarrow X_3$の経路は$X_6$が衝突部のgivenで開いているので通ることができる。 . 従って、二番目のパスでボールは通過できるので、$ {X_1, X_6 }$がgivenのとき$X_2$と$X_3$は独立が成立しない。 . . . $d$-Seperation&#12398;&#23450;&#32681; . $d$は方向性（directly）を意味する。 . | Bayesian Ball Algorithmで$d$-Seperationかどうかを確認することができる。 . | 整理すると、パスpが条件付き集合 $ {W }$により$d$-Seperateされるという命題は以下と必要十分条件である。 . 1.経路pは条件付き集合 $ {W }$に属する中間ノード$Z$の鎖$X rightarrow Z rightarrow Y$または分岐$X leftarrow Z rightarrow Y$を含む。 . 2.経路pは条件付き集合 $ {W }$に属さない中間ノード$Z&#39;$の衝突部$X rightarrow Z&#39; leftarrow Y$を含む。 . | . . . Additional reference . [1] Judea Pearl, Madelyn Glymour, Nicholas P. Jewell (2016). Causal Inference in Statistics: A Primer . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/causal%20inference%20%3E%20a.%20bayesian%20network/2021/02/08/Bayesian-Network-1.html",
            "relUrl": "/causal%20inference%20%3E%20a.%20bayesian%20network/2021/02/08/Bayesian-Network-1.html",
            "date": " • Feb 8, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "Market Basket Analysis in Python ①",
            "content": ". &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12392;&#12399;&#65311; . バスケット分析によって以下のようなことができる。 . 1. &#20341;&#22770;&#20998;&#26512; . 一回の買い物でよく一緒に買われるものは何か？ . 2. &#20341;&#22770;&#20998;&#26512;&#12395;&#22522;&#12389;&#12356;&#12390;&#26377;&#29992;&#12394;&#25512;&#22888;&#20107;&#38917;&#12398;&#25552;&#20379; . e.g. ・棚の近くに置くべき商品カテゴリー ・棚の遠くに置くべき商品カテゴリー など . . &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12398;&#20351;&#29992;&#20363; . e.g. ・Netflixスタイルの推奨エンジン ・eコマースにおける商品推奨の改善 ・小売店でのクロスセル（Cross-sell$^{[*1]}$）製品 ・在庫管理の改善 ・アップセル（Up-sell$^{[*2]}$）するアイテム選択　など . . $^{[*1]}$ Cross-sell : 顧客が購買する、あるいはすでに利用している製品・サービスに関連するものを販売していくこと $^{[*2]}$ Up-sell : 顧客が検討しているものよりランクの高い製品・サービスの販売をすること&lt;/p&gt; &lt;/span&gt; . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; . &#12496;&#12473;&#12465;&#12483;&#12488;&#20998;&#26512;&#12398;&#26041;&#27861; . Association Rule によって構成される . ・{A} $ rightarrow$ {B} . 「Aを買うと、Bを買う」という意味 . . (&#23455;&#35013;) &#12463;&#12525;&#12523;&#12475;&#12523;&#35069;&#21697;&#36984;&#25246; . 小売店ではガムをコーヒーかシリアルかパンかどれかとクロスセルしようとしている。 . ・{coffee} $ rightarrow$ {gum} ・{cereal} $ rightarrow$ {gum} ・{bread} $ rightarrow$ {gum} のうち、最も関係性が強いものを選びたい。 . . transactionsは [&#39;coffee&#39;,&#39;gum&#39;] &amp; [&#39;cereal&#39;,&#39;gum&#39;] &amp; [&#39;bread&#39;,&#39;gum&#39;] の３つのペアからなっている。 . # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np transactions = pd.read_csv(&#39;./dataset/transactions.csv&#39;, header=None) transactions . 0 1 . 0 bread | gum | . 1 bread | gum | . 2 cereal | gum | . 3 coffee | gum | . 4 bread | gum | . ... ... | ... | . 80 bread | gum | . 81 coffee | gum | . 82 bread | gum | . 83 coffee | gum | . 84 coffee | gum | . 85 rows × 2 columns . 各ペアの数をカウントする . # Count the number of transactions with coffee and gum coffee = transactions[(transactions[0] == &#39;coffee&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Count the number of transactions with cereal and gum cereal = transactions[(transactions[0] == &#39;cereal&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Count the number of transactions with bread and gum bread = transactions[(transactions[0] == &#39;bread&#39;) &amp; (transactions[1] == &#39;gum&#39;)] # Print the counts for each transaction. print(&#39;coffee:&#39;, len(coffee)) print(&#39;cereal:&#39;, len(cereal)) print(&#39;bread:&#39;, len(bread)) . coffee: 40 cereal: 25 bread: 20 . . Association Rules&#12398;&#20840;&#12390;&#12398;&#20505;&#35036;&#12434;&#30906;&#35469;&#12377;&#12427; . &#12487;&#12540;&#12479;&#12398;&#28310;&#20633; . 小売店の併売データを読み込む . # Load transactions from pandas groceries = pd.read_csv(&#39;./dataset/small_grocery_store.csv&#39;) # Split transaction strings into lists transactions = groceries[&#39;Transaction&#39;].apply(lambda t: t.split(&#39;,&#39;)) # Convert DataFrame column into list of strings transactions = list(transactions) # Print the list of transactions print(transactions) . [[&#39;milk&#39;, &#39;bread&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;milk&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;tea&#39;], [&#39;jam&#39;, &#39;bread&#39;, &#39;milk&#39;], [&#39;tea&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;tea&#39;], [&#39;tea&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;tea&#39;, &#39;biscuit&#39;], [&#39;jam&#39;, &#39;bread&#39;, &#39;tea&#39;], [&#39;bread&#39;, &#39;milk&#39;], [&#39;coffee&#39;, &#39;orange&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;coffee&#39;, &#39;orange&#39;, &#39;biscuit&#39;, &#39;cereal&#39;], [&#39;coffee&#39;, &#39;sugar&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;orange&#39;], [&#39;bread&#39;, &#39;sugar&#39;, &#39;biscuit&#39;], [&#39;coffee&#39;, &#39;sugar&#39;, &#39;cereal&#39;], [&#39;bread&#39;, &#39;sugar&#39;, &#39;biscuit&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;sugar&#39;], [&#39;bread&#39;, &#39;coffee&#39;, &#39;sugar&#39;], [&#39;tea&#39;, &#39;milk&#39;, &#39;coffee&#39;, &#39;cereal&#39;]] . Association rules&#12398;&#29983;&#25104; . ９つの食料品のリストを抽出し、すべての可能な単独原因単独結果の組み合わせ（Association rules）をitertoolsを使って生成する . # Import permutations from the itertools module from itertools import permutations # Define the set of groceries flattened = [i for t in transactions for i in t] groceries = list(set(flattened)) # Generate all possible rules rules = list(permutations(groceries, 2)) # Print the set of rules print(rules) # Print the number of rules print(&#39; n&#39;) print(len(rules),&quot;通り&quot;) . [(&#39;jam&#39;, &#39;cereal&#39;), (&#39;jam&#39;, &#39;sugar&#39;), (&#39;jam&#39;, &#39;tea&#39;), (&#39;jam&#39;, &#39;orange&#39;), (&#39;jam&#39;, &#39;bread&#39;), (&#39;jam&#39;, &#39;milk&#39;), (&#39;jam&#39;, &#39;coffee&#39;), (&#39;jam&#39;, &#39;biscuit&#39;), (&#39;cereal&#39;, &#39;jam&#39;), (&#39;cereal&#39;, &#39;sugar&#39;), (&#39;cereal&#39;, &#39;tea&#39;), (&#39;cereal&#39;, &#39;orange&#39;), (&#39;cereal&#39;, &#39;bread&#39;), (&#39;cereal&#39;, &#39;milk&#39;), (&#39;cereal&#39;, &#39;coffee&#39;), (&#39;cereal&#39;, &#39;biscuit&#39;), (&#39;sugar&#39;, &#39;jam&#39;), (&#39;sugar&#39;, &#39;cereal&#39;), (&#39;sugar&#39;, &#39;tea&#39;), (&#39;sugar&#39;, &#39;orange&#39;), (&#39;sugar&#39;, &#39;bread&#39;), (&#39;sugar&#39;, &#39;milk&#39;), (&#39;sugar&#39;, &#39;coffee&#39;), (&#39;sugar&#39;, &#39;biscuit&#39;), (&#39;tea&#39;, &#39;jam&#39;), (&#39;tea&#39;, &#39;cereal&#39;), (&#39;tea&#39;, &#39;sugar&#39;), (&#39;tea&#39;, &#39;orange&#39;), (&#39;tea&#39;, &#39;bread&#39;), (&#39;tea&#39;, &#39;milk&#39;), (&#39;tea&#39;, &#39;coffee&#39;), (&#39;tea&#39;, &#39;biscuit&#39;), (&#39;orange&#39;, &#39;jam&#39;), (&#39;orange&#39;, &#39;cereal&#39;), (&#39;orange&#39;, &#39;sugar&#39;), (&#39;orange&#39;, &#39;tea&#39;), (&#39;orange&#39;, &#39;bread&#39;), (&#39;orange&#39;, &#39;milk&#39;), (&#39;orange&#39;, &#39;coffee&#39;), (&#39;orange&#39;, &#39;biscuit&#39;), (&#39;bread&#39;, &#39;jam&#39;), (&#39;bread&#39;, &#39;cereal&#39;), (&#39;bread&#39;, &#39;sugar&#39;), (&#39;bread&#39;, &#39;tea&#39;), (&#39;bread&#39;, &#39;orange&#39;), (&#39;bread&#39;, &#39;milk&#39;), (&#39;bread&#39;, &#39;coffee&#39;), (&#39;bread&#39;, &#39;biscuit&#39;), (&#39;milk&#39;, &#39;jam&#39;), (&#39;milk&#39;, &#39;cereal&#39;), (&#39;milk&#39;, &#39;sugar&#39;), (&#39;milk&#39;, &#39;tea&#39;), (&#39;milk&#39;, &#39;orange&#39;), (&#39;milk&#39;, &#39;bread&#39;), (&#39;milk&#39;, &#39;coffee&#39;), (&#39;milk&#39;, &#39;biscuit&#39;), (&#39;coffee&#39;, &#39;jam&#39;), (&#39;coffee&#39;, &#39;cereal&#39;), (&#39;coffee&#39;, &#39;sugar&#39;), (&#39;coffee&#39;, &#39;tea&#39;), (&#39;coffee&#39;, &#39;orange&#39;), (&#39;coffee&#39;, &#39;bread&#39;), (&#39;coffee&#39;, &#39;milk&#39;), (&#39;coffee&#39;, &#39;biscuit&#39;), (&#39;biscuit&#39;, &#39;jam&#39;), (&#39;biscuit&#39;, &#39;cereal&#39;), (&#39;biscuit&#39;, &#39;sugar&#39;), (&#39;biscuit&#39;, &#39;tea&#39;), (&#39;biscuit&#39;, &#39;orange&#39;), (&#39;biscuit&#39;, &#39;bread&#39;), (&#39;biscuit&#39;, &#39;milk&#39;), (&#39;biscuit&#39;, &#39;coffee&#39;)] 72 通り . . Metric &amp; Pruning . 全ての可能な組み合わせを候補として置くのは、かなり時間とコストがかかる。 そのため、有用な規則だけに絞りたい。 → Metric &amp; Pruning Process . ①Metric : Association rulesにスコアを割り当て . ②Pruning : 特定の基準に従い、基準に満たさないRulesを放棄する . One-hot encoding transaction data . # Import the transaction encoder function from mlxtend from mlxtend.preprocessing import TransactionEncoder # Instantiate transaction encoder and identify unique items encoder = TransactionEncoder().fit(transactions) # One-hot encode transactions onehot = encoder.transform(transactions) # Convert one-hot encoded data to DataFrame onehot = pd.DataFrame(onehot, columns = encoder.columns_) # Print the one-hot encoded transaction dataset print(onehot) . biscuit bread cereal coffee jam milk orange sugar tea 0 True True False False False True False False False 1 True True True False False True False False False 2 False True False False False False False False True 3 False True False False True True False False False 4 True False False False False False False False True 5 False True False False False False False False True 6 False False True False False False False False True 7 True True False False False False False False True 8 False True False False True False False False True 9 False True False False False True False False False 10 True False True True False False True False False 11 True False True True False False True False False 12 False False False True False False False True False 13 False True False True False False True False False 14 True True False False False False False True False 15 False False True True False False False True False 16 True True False False False False False True False 17 False True False True False False False True False 18 False True False True False False False True False 19 False False True True False True False False True . # Compute the support support = onehot.mean() # Print the support print(support) . biscuit 0.40 bread 0.65 cereal 0.30 coffee 0.40 jam 0.10 milk 0.25 orange 0.15 sugar 0.30 tea 0.35 dtype: float64 . # Add a jam+bread column to the DataFrame onehot onehot[&#39;jam+bread&#39;] = np.logical_and(onehot[&#39;jam&#39;], onehot[&#39;bread&#39;]) # Compute the support support = onehot.mean() # Print the support values print(support) . biscuit 0.40 bread 0.65 cereal 0.30 coffee 0.40 jam 0.10 milk 0.25 orange 0.15 sugar 0.30 tea 0.35 jam+bread 0.10 dtype: float64 . . Additional Reference JMR生活総合研究所. アップセリング（Up-selling）、クロスセリング（Cross-selling）. マーケティング用語集. https://www.jmrlsi.co.jp/knowledge/yougo/my06/my0618.html . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] . &lt;/div&gt; .",
            "url": "https://jaysung00.github.io/jays_blog/marketing%20%3E%20a.%20datacamp%20class/2021/02/08/Basket-analysis-1.html",
            "relUrl": "/marketing%20%3E%20a.%20datacamp%20class/2021/02/08/Basket-analysis-1.html",
            "date": " • Feb 8, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "Analyzing Marketing Campaigns with pandas ④",
            "content": ". A/B&#12486;&#12473;&#12488;&#12392;&#12399; . どのバリアントのパフォーマンスが優れているかを評価するランダム化実験 | . A/B&#12486;&#12473;&#12488;&#12434;&#34892;&#12358;&#26178;&#12398;&#27880;&#24847;&#20107;&#38917; . 明確なコントロールが必要 | テストを行う前にKPI（Key Performance Index）を設定 | ポジティブな結果を見つけようと、成功を再定義することは望ましくない | KPIを事前に文書化することで、テストの成功を明確に保つことができる | . . # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . &#12486;&#12473;&#12488;&#12398;&#21106;&#12426;&#24403;&#12390; . このデータは実際A/Bテストが行われている。variant列がpersonlizationかcontrolかによって割り当てされている。 . 以下のコードではmarketing_channelがEmailであるデータの中でA/Bテストの結果を分析する。 . email = marketing[marketing[&#39;marketing_channel&#39;] == &#39;Email&#39;] # Group the email DataFrame by variant alloc = email.groupby([&#39;variant&#39;])[&#39;user_id&#39;].nunique() # Plot a bar chart of the test allocation alloc.plot(kind=&#39;bar&#39;) plt.title(&#39;Personalization test allocation&#39;) plt.ylabel(&#39;# participants&#39;) plt.show() . Personalizaiton&#12464;&#12523;&#12540;&#12503;&#12392;Control&#12464;&#12523;&#12540;&#12503;&#12398;&#36578;&#25563;&#29575;&#12398;&#24179;&#22343;&#35336;&#31639; . subscribers = email.groupby([&#39;user_id&#39;, &#39;variant&#39;])[&#39;converted&#39;].max() subscribers_df = pd.DataFrame(subscribers.unstack(level=1)) # Drop missing values from the control column control = subscribers_df[&#39;control&#39;].dropna() # Drop missing values from the personalization column personalization = subscribers_df[&#39;personalization&#39;].dropna() print(&#39;Control conversion rate:&#39;, np.mean(control)) print(&#39;Personalization conversion rate:&#39;, np.mean(personalization)) . Control conversion rate: 0.2814814814814815 Personalization conversion rate: 0.3908450704225352 . Lift&#20516;&#12398;&#35336;&#31639; . $Lift = cfrac{Treatment space conversion space rate space - space Control space conversion space rate}{Control space conversion space rate}$ . # Lift関数の定義 def lift(control, treat): # Calcuate the mean of control and treatment control_mean = np.mean(control) treat_mean = np.mean(treat) # Calculate the lift using control_mean and treat_mean lift = (treat_mean-control_mean)/control_mean return str(round(lift*100, 2)) + &#39;%&#39; # Print lift() with control and personalization as inputs print(lift(control, personalization)) . 38.85% . A/B&#12486;&#12473;&#12488;&amp;&#12475;&#12464;&#12513;&#12531;&#12486;&#12540;&#12471;&#12519;&#12531;&amp;T-test &#38306;&#25968; . E-mailのマーケッティングの実績における別の特徴（セグメント）ごとにLift値＆T-test（統計的有意性）を計算する関数 . from scipy import stats . def ab_segmentation(segment): # Build a for loop for each segment in marketing for subsegment in np.unique(marketing[segment].values): print(subsegment) # Limit marketing to email and subsegment email = marketing[(marketing[&#39;marketing_channel&#39;] == &#39;Email&#39;) &amp; (marketing[segment] == subsegment)] subscribers = email.groupby([&#39;user_id&#39;, &#39;variant&#39;])[&#39;converted&#39;].max() subscribers = pd.DataFrame(subscribers.unstack(level=1)) control = subscribers[&#39;control&#39;].dropna() personalization = subscribers[&#39;personalization&#39;].dropna() print(&#39;lift:&#39;, lift(control, personalization)) print(&#39;t-statistic:&#39;, stats.ttest_ind(control, personalization), &#39; n n&#39;) . ab_segmentation(&#39;language_displayed&#39;) . Arabic lift: 50.0% t-statistic: Ttest_indResult(statistic=-0.5773502691896255, pvalue=0.5795840000000001) English lift: 39.0% t-statistic: Ttest_indResult(statistic=-2.2183598646203166, pvalue=0.026991701290720815) German lift: -1.62% t-statistic: Ttest_indResult(statistic=0.1910083418078718, pvalue=0.8494394170062678) Spanish lift: 166.67% t-statistic: Ttest_indResult(statistic=-2.3570226039551585, pvalue=0.040156718110477524) . ab_segmentation(&#39;age_group&#39;) . 0-18 years lift: 121.4% t-statistic: Ttest_indResult(statistic=-2.966044912142211, pvalue=0.0038724494391297226) 19-24 years lift: 106.24% t-statistic: Ttest_indResult(statistic=-3.03179438478667, pvalue=0.0030623836114689134) 24-30 years lift: 161.19% t-statistic: Ttest_indResult(statistic=-3.861539544326876, pvalue=0.00018743381094867337) 30-36 years lift: -100.0% t-statistic: Ttest_indResult(statistic=3.1859064644147996, pvalue=0.0023238487431765137) 36-45 years lift: -85.23% t-statistic: Ttest_indResult(statistic=2.4317901279318503, pvalue=0.01797568600978829) 45-55 years lift: -72.22% t-statistic: Ttest_indResult(statistic=2.065499127317933, pvalue=0.043062339688201196) 55+ years lift: -100.0% t-statistic: Ttest_indResult(statistic=3.3265654564203397, pvalue=0.0016358623456360435) . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev] .",
            "url": "https://jaysung00.github.io/jays_blog/marketing%20%3E%20a.%20datacamp%20class/2021/02/04/Marketing-4.html",
            "relUrl": "/marketing%20%3E%20a.%20datacamp%20class/2021/02/04/Marketing-4.html",
            "date": " • Feb 4, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "Analyzing Marketing Campaigns with pandas ③",
            "content": ". # import &amp; read data import matplotlib.pyplot as plt import pandas as pd import numpy as np . marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . . &#36578;&#25563;&#29575;&#12434;&#27714;&#12417;&#12427;&#38306;&#25968;&#12398;&#20316;&#25104; . def conversion_rate(dataframe, column_names): # Total number of converted users column_conv = dataframe[dataframe[&#39;converted&#39;] == True] .groupby(column_names)[&#39;user_id&#39;].nunique() # Total number users column_total = dataframe.groupby(column_names)[&#39;user_id&#39;].nunique() # Conversion rate conversion_rate = column_conv/column_total # Fill missing values with 0 conversion_rate = conversion_rate.fillna(0) return conversion_rate . age_group_conv = conversion_rate(marketing, [&#39;date_served&#39;, &#39;age_group&#39;]) # Unstack and create a DataFrame age_group_df = pd.DataFrame(age_group_conv.unstack(level = 1)) # Visualize conversion by age_group age_group_df.plot() plt.title(&#39;Conversion rate by age group n&#39;, size = 16) plt.ylabel(&#39;Conversion rate&#39;, size = 14) plt.xlabel(&#39;Age group&#39;, size = 14) plt.show() . 別々にプロットする関数を作成してみよう。 . def plotting_conv(dataframe): for column in dataframe: # Plot column by dataframe&#39;s index plt.plot(dataframe.index, dataframe[column]) plt.title(&#39;Daily &#39; + str(column) + &#39; conversion rate n&#39;, size = 16) plt.ylabel(&#39;Conversion rate&#39;, size = 14) plt.xlabel(&#39;Date&#39;, size = 14) plt.xticks(rotation = 45) # Show plot plt.show() plt.clf() . age_group_conv = conversion_rate(marketing, [&#39;date_served&#39;, &#39;age_group&#39;]) # Unstack age_group_conv and create a DataFrame age_group_df = pd.DataFrame(age_group_conv.unstack(level=1)) # Plot the results plotting_conv(age_group_df) . &lt;Figure size 432x288 with 0 Axes&gt; . . &#21839;&#38988;&#30330;&#35211;&#12363;&#12425;&#28508;&#22312;&#30340;&#21407;&#22240;&#12434;&#32771;&#12360;&#12427; . &#21839;&#38988;&#30330;&#35211;&#12398;&#20363; . daily_conv_channel = conversion_rate(marketing, [&#39;date_served&#39;, &#39;marketing_channel&#39;]) # Unstack daily_conv_channel and convert it to a DataFrame daily_conv_channel = pd.DataFrame(daily_conv_channel.unstack(level = 1)) # Plot results of daily_conv_channel plotting_conv(daily_conv_channel) . &lt;Figure size 432x288 with 0 Axes&gt; . House Adsのチャネルで広告を打ったとき、1月11日頃から転換率が急に落ちている。 | . &#28508;&#22312;&#30340;&#12394;&#21407;&#22240;&#12434;&#25506;&#12377; . ① チャネルごとの曜日別転換率の差を見る . marketing[&#39;DoW_served&#39;] = marketing[&#39;date_served&#39;].dt.dayofweek # Calculate conversion rate by day of week DoW_conversion = conversion_rate(marketing, [&#39;DoW_served&#39;, &#39;marketing_channel&#39;]) # Unstack channels DoW_df = pd.DataFrame(DoW_conversion.unstack(level=1)) # Plot conversion rate by day of week DoW_df.plot() plt.title(&#39;Conversion rate by day of week n&#39;) plt.ylim(0) plt.show() . 【結果】特に関係性が見られない。 . ②House Adsチャネルのうち、広告表示言語ごとに日別転換率を計算 . house_ads = marketing[marketing[&#39;marketing_channel&#39;] == &#39;House Ads&#39;] # Calculate conversion by date served and language displayed conv_lang_channel = conversion_rate(house_ads, [&#39;date_served&#39;, &#39;language_displayed&#39;]) # Unstack conv_lang_channel conv_lang_df = pd.DataFrame(conv_lang_channel.unstack(level=1)) # Use plotting function to display results plotting_conv(conv_lang_df) . &lt;Figure size 432x288 with 0 Axes&gt; . 【結果】ほとんどの言語で1月11日以降転換率が落ちている。 . ③ユーザーの使用言語と広告の表示言語がどれだけ一致しているかを日別に見る . house_ads[&#39;is_correct_lang&#39;] = np.where( house_ads[&#39;language_preferred&#39;] == house_ads[&#39;language_displayed&#39;], &#39;Yes&#39;, &#39;No&#39;) # Groupby date_served and is_correct_lang language_check = house_ads.groupby([&#39;date_served&#39;,&#39;is_correct_lang&#39;])[&#39;is_correct_lang&#39;].count() # Unstack language_check and fill missing values with 0&#39;s language_check_df = pd.DataFrame(language_check.unstack(level=1)).fillna(0) # Print results print(language_check_df) . is_correct_lang No Yes date_served 2018-01-01 2.0 189.0 2018-01-02 3.0 247.0 2018-01-03 0.0 220.0 2018-01-04 0.0 168.0 2018-01-05 0.0 160.0 2018-01-06 1.0 151.0 2018-01-07 2.0 130.0 2018-01-08 0.0 154.0 2018-01-09 0.0 157.0 2018-01-10 0.0 170.0 2018-01-11 20.0 135.0 2018-01-12 18.0 130.0 2018-01-13 26.0 122.0 2018-01-14 20.0 131.0 2018-01-15 16.0 192.0 2018-01-16 28.0 127.0 2018-01-17 21.0 127.0 2018-01-18 31.0 121.0 2018-01-19 22.0 127.0 2018-01-20 28.0 124.0 2018-01-21 14.0 100.0 2018-01-22 13.0 72.0 2018-01-23 16.0 69.0 2018-01-24 13.0 83.0 2018-01-25 19.0 74.0 2018-01-26 24.0 92.0 2018-01-27 18.0 149.0 2018-01-28 28.0 136.0 2018-01-29 24.0 142.0 2018-01-30 23.0 145.0 2018-01-31 23.0 135.0 . /Users/sungminje/opt/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:5: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34; . language_check_df[&#39;pct&#39;] = language_check_df[&#39;Yes&#39;]/language_check_df.sum(axis=1) # Plot and show your results plt.plot(language_check_df.index.values, language_check_df[&#39;pct&#39;]) plt.xticks(rotation = 45) plt.show() . 【結果】1月11日以降間違った言語で送られたHouse Adsの広告が多いことが分かった。 →おそらく、このHouse Adsのバグによって転換率が低下した。 . &#12496;&#12464;&#12364;&#12394;&#12363;&#12387;&#12383;&#22580;&#21512;&#12434;&#20104;&#28204;&#12377;&#12427; . house_ads_bug = house_ads[house_ads[&#39;date_served&#39;] &lt; &#39;2018-01-11&#39;] lang_conv = conversion_rate(house_ads_bug, [&#39;language_displayed&#39;]) # Index other language conversion rate against English spanish_index = lang_conv[&#39;Spanish&#39;]/lang_conv[&#39;English&#39;] arabic_index = lang_conv[&#39;Arabic&#39;]/lang_conv[&#39;English&#39;] german_index = lang_conv[&#39;German&#39;]/lang_conv[&#39;English&#39;] print(&quot;Spanish index:&quot;, spanish_index) print(&quot;Arabic index:&quot;, arabic_index) print(&quot;German index:&quot;, german_index) . Spanish index: 1.681924882629108 Arabic index: 5.045774647887324 German index: 4.485133020344287 . converted = house_ads.groupby([&#39;date_served&#39;, &#39;language_preferred&#39;]) .agg({&#39;user_id&#39;:&#39;nunique&#39;, &#39;converted&#39;:&#39;sum&#39;}) # Unstack converted converted_df = pd.DataFrame(converted.unstack(level=1)) . converted_df[&#39;english_conv_rate&#39;] = converted_df.loc[&#39;2018-01-11&#39;:&#39;2018-01-31&#39;][(&#39;converted&#39;,&#39;English&#39;)] # Create expected conversion rates for each language converted_df[&#39;expected_spanish_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*spanish_index converted_df[&#39;expected_arabic_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*arabic_index converted_df[&#39;expected_german_rate&#39;] = converted_df[&#39;english_conv_rate&#39;]*german_index # Multiply number of users by the expected conversion rate converted_df[&#39;expected_spanish_conv&#39;] = converted_df[&#39;expected_spanish_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;Spanish&#39;)] converted_df[&#39;expected_arabic_conv&#39;] = converted_df[&#39;expected_arabic_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;Arabic&#39;)] converted_df[&#39;expected_german_conv&#39;] = converted_df[&#39;expected_german_rate&#39;]/100*converted_df[(&#39;user_id&#39;,&#39;German&#39;)] . converted_df = converted_df.loc[&#39;2018-01-11&#39;:&#39;2018-01-31&#39;] # Sum expected subscribers for each language expected_subs = converted_df[&#39;expected_spanish_conv&#39;].sum() + converted_df[&#39;expected_arabic_conv&#39;].sum() + converted_df[&#39;expected_german_conv&#39;].sum() # Calculate how many subscribers we actually got actual_subs = converted_df[(&#39;converted&#39;,&#39;Spanish&#39;)].sum() + converted_df[(&#39;converted&#39;,&#39;Arabic&#39;)].sum() + converted_df[(&#39;converted&#39;,&#39;German&#39;)].sum() # Subtract how many subscribers we got despite the bug lost_subs = expected_subs - actual_subs print(lost_subs) . 32.144143192488265 . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev]　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/marketing%20%3E%20a.%20datacamp%20class/2021/02/03/Marketing-3.html",
            "relUrl": "/marketing%20%3E%20a.%20datacamp%20class/2021/02/03/Marketing-3.html",
            "date": " • Feb 3, 2021"
        }
        
    
  
    
        ,"post24": {
            "title": "Analyzing Marketing Campaigns with pandas ②",
            "content": ". # import data import pandas as pd marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) . marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 2018-01-01 | House Ads | personalization | True | English | English | 0-18 years | 2018-01-01 | NaT | House Ads | True | . 1 a100000030 | 2018-01-01 | House Ads | personalization | True | English | English | 19-24 years | 2018-01-01 | NaT | House Ads | True | . 2 a100000031 | 2018-01-01 | House Ads | personalization | True | English | English | 24-30 years | 2018-01-01 | NaT | House Ads | True | . 3 a100000032 | 2018-01-01 | House Ads | personalization | True | English | English | 30-36 years | 2018-01-01 | NaT | House Ads | True | . 4 a100000033 | 2018-01-01 | House Ads | personalization | True | English | English | 36-45 years | 2018-01-01 | NaT | House Ads | True | . . &#12461;&#12515;&#12531;&#12506;&#12540;&#12531;&#12399;&#25104;&#21151;&#12375;&#12383;&#12398;&#12363;&#65311; . これを評価するために、いくつかの指標が使われる。 . 転換率（Conversion rate） | 保持率（Retention rate） | . etc. . &#36578;&#25563;&#29575;&#65288;Conversion rate&#65289;&#12434;&#27714;&#12417;&#12427; . $Conversion space rate = cfrac{Number space of space people space who space convert}{Total space number space of space people space we space marketed space to} $ . # すべての顧客を求める。(Total number of people we marketed to) total = marketing[&#39;user_id&#39;].nunique() # 転換した顧客を求める。(Number of people who converted) subscribers = marketing[marketing[&quot;converted&quot;] == True][&#39;user_id&#39;].nunique() # 転換率を計算する。 conversion_rate = subscribers/total print(round(conversion_rate*100, 2), &quot;%&quot;) . 13.89 % . &#20445;&#25345;&#29575;&#65288;Retention rate&#65289;&#12434;&#27714;&#12417;&#12427; . $Retention space rate = cfrac{Number space of space people space who space remain space subscribed}{Total space number space of space people space who space converted} $ . # 転換した顧客を求める。 (Total number of people who converted) total_subscribers = marketing[marketing[&quot;converted&quot;] == True] [&#39;user_id&#39;].nunique() # 保持した顧客を求める。(Number of people who remained subscribed) retained = marketing[marketing[&#39;is_retained&#39;] == True] [&#39;user_id&#39;].nunique() # 保持率を計算する。 retention_rate = retained/total_subscribers print(round(retention_rate*100, 2), &quot;%&quot;) . 66.8 % . . &#12475;&#12464;&#12513;&#12531;&#12486;&#12540;&#12471;&#12519;&#12531; . 顧客をセグメント化するには、いくつかの一般的な基準がある。 . 年齢 | 性別 | 場所 | 過去の取引 | 取引したマーケッティングチャネル | . etc. . # 英語使用者を抽出 english_speakers = marketing[marketing[&#39;language_displayed&#39;] == &#39;English&#39;] # 英語使用者のユニークIDを数える total = english_speakers[&#39;user_id&#39;].nunique() # 転換した英語使用者 subscribers = english_speakers[english_speakers[&#39;converted&#39;] == True] [&#39;user_id&#39;].nunique() # 英語使用者の転換率 conversion_rate = subscribers/total print(&#39;英語使用者の転換率：&#39;, round(conversion_rate*100,2), &#39;%&#39;) . 英語使用者の転換率： 12.92 % . # 各言語ごとにグループ化し、ユニークIDをカウント total = marketing.groupby([&#39;language_displayed&#39;])[&#39;user_id&#39;].nunique() # 各言語ごとにグループ化し、そのうち転換したIDをカウント subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;language_displayed&#39;])[&#39;user_id&#39;].nunique() # グループごとに転換率計算 language_conversion_rate = subscribers/total print(language_conversion_rate) . language_displayed Arabic 0.500000 English 0.129167 German 0.716216 Spanish 0.200000 Name: user_id, dtype: float64 . # 日付ごとにグループ化し、ユニークIDをカウント total = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;] .nunique() # 日付ごとにグループ化し、そのうち転換したIDをカウント subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;date_served&#39;]) [&#39;user_id&#39;].nunique() # 日付ごとの転換率 daily_conversion_rate = subscribers/total print(daily_conversion_rate) . date_served 2018-01-01 0.099448 2018-01-02 0.098930 2018-01-03 0.103448 2018-01-04 0.108359 2018-01-05 0.125392 2018-01-06 0.113636 2018-01-07 0.141818 2018-01-08 0.115385 2018-01-09 0.125000 2018-01-10 0.118694 2018-01-11 0.080645 2018-01-12 0.076412 2018-01-13 0.084967 2018-01-14 0.085246 2018-01-15 0.113429 2018-01-16 0.255155 2018-01-17 0.219512 2018-01-18 0.091195 2018-01-19 0.059016 2018-01-20 0.067524 2018-01-21 0.087336 2018-01-22 0.123596 2018-01-23 0.122093 2018-01-24 0.115789 2018-01-25 0.125000 2018-01-26 0.090090 2018-01-27 0.065625 2018-01-28 0.062500 2018-01-29 0.059561 2018-01-30 0.066246 2018-01-31 0.052941 Name: user_id, dtype: float64 . . &#12461;&#12515;&#12531;&#12506;&#12540;&#12531;&#32080;&#26524;&#12434;&#12503;&#12525;&#12483;&#12488; . import matplotlib.pyplot as plt # Create a bar chart using language_conversion_rate DataFrame language_conversion_rate.plot(kind = &#39;bar&#39;) # Add a title and x and y-axis labels plt.title(&#39;Conversion rate by language n&#39;, size = 16) plt.ylabel(&#39;Conversion rate (%)&#39;, size = 14) plt.xlabel(&#39;Language&#39;, size = 14) # Display the plot plt.show() . # Group by date_served and count unique users total = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;] .nunique() # Group by date_served and calculate subscribers subscribers = marketing[marketing[&#39;converted&#39;] == True] .groupby([&#39;date_served&#39;]) [&#39;user_id&#39;].nunique() # Calculate the conversion rate for all languages daily_conversion_rate = subscribers/total # Reset index to turn the results into a DataFrame daily_conversion_rate = pd.DataFrame(daily_conversion_rate.reset_index(0)) # Rename columns daily_conversion_rate.columns = [&#39;date_served&#39;, &#39;conversion_rate&#39;] # Create a line chart using daily_conversion_rate DataFrame daily_conversion_rate.plot(&#39;date_served&#39;, &#39;conversion_rate&#39;) plt.title(&#39;Daily conversion rate n&#39;, size = 16) plt.ylabel(&#39;Conversion rate (%)&#39;, size = 14) plt.xlabel(&#39;Date&#39;, size = 14) # Set the y-axis to begin at 0 plt.ylim(0) # Display the plot plt.show() . channel_age = marketing.groupby([&#39;marketing_channel&#39;, &#39;age_group&#39;]) [&#39;user_id&#39;].count() # Unstack channel_age and transform it into a DataFrame channel_age_df = pd.DataFrame(channel_age.unstack(level = 1)) # Plot the results channel_age_df.plot(kind = &#39;bar&#39;) plt.title(&#39;Marketing channels by age group&#39;) plt.xlabel(&#39;Age Group&#39;) plt.ylabel(&#39;Users&#39;) # Add a legend to the plot plt.legend(loc = &#39;upper right&#39;, labels = channel_age_df.columns.values) plt.show() . # Count the subs by subscribing channel and date subscribed retention_total = marketing.groupby([&#39;date_subscribed&#39;, &#39;subscribing_channel&#39;]) [&#39;user_id&#39;].nunique() # Count the retained subs by subscribing channel and date subscribed retention_subs = marketing[marketing[&#39;is_retained&#39;] == True] .groupby([&#39;date_subscribed&#39;, &#39;subscribing_channel&#39;]) [&#39;user_id&#39;].nunique() # Divide retained subscribers by total subscribers retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) retention_rate_df.head(10) . subscribing_channel Email Facebook House Ads Instagram Push . date_subscribed . 2018-01-01 1.00 | 0.875000 | 0.687500 | 0.750000 | 1.000000 | . 2018-01-02 0.75 | 1.000000 | 0.588235 | 0.625000 | 1.000000 | . 2018-01-03 NaN | 0.800000 | 0.647059 | 0.909091 | 0.666667 | . 2018-01-04 0.50 | 0.666667 | 0.466667 | 0.500000 | NaN | . 2018-01-05 1.00 | 0.571429 | 0.500000 | 0.636364 | 1.000000 | . 2018-01-06 0.80 | 0.571429 | 0.941176 | 0.500000 | 0.500000 | . 2018-01-07 0.50 | 0.750000 | 0.526316 | 0.400000 | 0.666667 | . 2018-01-08 NaN | 0.888889 | 0.500000 | 0.625000 | 1.000000 | . 2018-01-09 0.50 | 0.285714 | 0.850000 | 0.666667 | 0.500000 | . 2018-01-10 1.00 | 0.714286 | 0.666667 | 0.555556 | 1.000000 | . # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate (%)&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . retention_rate = retention_subs/retention_total retention_rate_df = pd.DataFrame(retention_rate.unstack(level=1)) # Plot retention rate retention_rate_df.plot() # Add a title, x-label, y-label, legend and display the plot plt.title(&#39;Retention Rate by Subscribing Channel&#39;) plt.xlabel(&#39;Date Subscribed&#39;) plt.ylabel(&#39;Retention Rate&#39;) plt.legend(loc = &#39;upper right&#39;, labels = retention_rate_df.columns.values) plt.show() . . このシリーズの別のポストを見るには . 　　　[&lt;&lt;Prev]　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/marketing%20%3E%20a.%20datacamp%20class/2021/02/02/Marketing-2.html",
            "relUrl": "/marketing%20%3E%20a.%20datacamp%20class/2021/02/02/Marketing-2.html",
            "date": " • Feb 2, 2021"
        }
        
    
  
    
        ,"post25": {
            "title": "Analyzing Marketing Campaigns with pandas ①",
            "content": ". &#12510;&#12540;&#12465;&#12486;&#12451;&#12531;&#12464;&#12481;&#12540;&#12512;&#12391;&#12487;&#12540;&#12479;&#12469;&#12452;&#12456;&#12531;&#12486;&#12451;&#12473;&#12488;&#12364;&#12420;&#12427;&#12371;&#12392; . マーケッティングキャンペーンの効果分析 &amp; ターゲッティング | マーケッティングチャネルの転換率や収益を考慮し、妥当性を分析 | A/B テストを行う | . . # import data import pandas as pd marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;) . &#12487;&#12540;&#12479;&#12434;&#30906;&#35469; . marketing.head() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . 0 a100000029 | 1/1/18 | House Ads | personalization | True | English | English | 0-18 years | 1/1/18 | NaN | House Ads | True | . 1 a100000030 | 1/1/18 | House Ads | personalization | True | English | English | 19-24 years | 1/1/18 | NaN | House Ads | True | . 2 a100000031 | 1/1/18 | House Ads | personalization | True | English | English | 24-30 years | 1/1/18 | NaN | House Ads | True | . 3 a100000032 | 1/1/18 | House Ads | personalization | True | English | English | 30-36 years | 1/1/18 | NaN | House Ads | True | . 4 a100000033 | 1/1/18 | House Ads | personalization | True | English | English | 36-45 years | 1/1/18 | NaN | House Ads | True | . marketing.describe() . user_id date_served marketing_channel variant converted language_displayed language_preferred age_group date_subscribed date_canceled subscribing_channel is_retained . count 10037 | 10021 | 10022 | 10037 | 10022 | 10037 | 10037 | 10037 | 1856 | 577 | 1856 | 1856 | . unique 7309 | 31 | 5 | 2 | 2 | 4 | 4 | 7 | 31 | 115 | 5 | 2 | . top a100000882 | 1/15/18 | House Ads | control | False | English | English | 19-24 years | 1/16/18 | 4/2/18 | Instagram | True | . freq 12 | 789 | 4733 | 5091 | 8946 | 9793 | 9275 | 1682 | 163 | 15 | 600 | 1279 | . marketing.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 10037 entries, 0 to 10036 Data columns (total 12 columns): # Column Non-Null Count Dtype -- -- 0 user_id 10037 non-null object 1 date_served 10021 non-null object 2 marketing_channel 10022 non-null object 3 variant 10037 non-null object 4 converted 10022 non-null object 5 language_displayed 10037 non-null object 6 language_preferred 10037 non-null object 7 age_group 10037 non-null object 8 date_subscribed 1856 non-null object 9 date_canceled 577 non-null object 10 subscribing_channel 1856 non-null object 11 is_retained 1856 non-null object dtypes: object(12) memory usage: 941.1+ KB . &#21015;&#12372;&#12392;&#12395;&#12487;&#12540;&#12479;&#22411;&#12434;&#26356;&#26032;&#12377;&#12427; . &#12487;&#12540;&#12479;&#22411;&#12398;&#22793;&#25563; . # Check the data type print(marketing[&#39;is_retained&#39;].dtype) . object . # Convert is_retained to a boolean marketing[&#39;is_retained&#39;] = marketing[&#39;is_retained&#39;].astype(&#39;bool&#39;) # Check the data type of is_retained, again print(marketing[&#39;is_retained&#39;].dtype) . bool . &#26032;&#12375;&#12356;&#21015;&#12398;&#36861;&#21152; . # Mapping for channels channel_dict = {&quot;House Ads&quot;: 1, &quot;Instagram&quot;: 2, &quot;Facebook&quot;: 3, &quot;Email&quot;: 4, &quot;Push&quot;: 5} # チャネルをコードにMappingする marketing[&#39;channel_code&#39;] = marketing[&#39;subscribing_channel&#39;].map(channel_dict) . # 結果 marketing[[&#39;subscribing_channel&#39;, &#39;channel_code&#39;]] . subscribing_channel channel_code . 0 House Ads | 1.0 | . 1 House Ads | 1.0 | . 2 House Ads | 1.0 | . 3 House Ads | 1.0 | . 4 House Ads | 1.0 | . ... ... | ... | . 10032 Email | 4.0 | . 10033 Email | 4.0 | . 10034 Email | 4.0 | . 10035 Email | 4.0 | . 10036 Email | 4.0 | . 10037 rows × 2 columns . import numpy as np # 列同士の一致有無を表す列を追加 marketing[&#39;is_correct_lang&#39;] = np.where( marketing[&#39;language_preferred&#39;] == marketing[&#39;language_displayed&#39;], &#39;Yes&#39;, &#39;No&#39; ) # 結果 marketing[[&#39;language_preferred&#39;, &#39;language_displayed&#39;, &#39;is_correct_lang&#39;]] . language_preferred language_displayed is_correct_lang . 0 English | English | Yes | . 1 English | English | Yes | . 2 English | English | Yes | . 3 English | English | Yes | . 4 English | English | Yes | . ... ... | ... | ... | . 10032 German | German | Yes | . 10033 German | German | Yes | . 10034 German | German | Yes | . 10035 German | German | Yes | . 10036 German | German | Yes | . 10037 rows × 3 columns . # インポートの時にdatatime型にすることも可能 # marketing = pd.read_csv(&#39;./dataset/marketing.csv&#39;, # parse_dates = [&#39;date_served&#39;, &#39;date_subscribed&#39;, &#39;date_canceled&#39;]) # 曜日の列を数字で表した列追加 # 月曜日:0, ... ,日曜日:6 marketing_with_date[&#39;DoW&#39;] = marketing_with_date[&#39;date_subscribed&#39;].dt.dayofweek #結果 marketing_with_date[[&#39;date_subscribed&#39;, &#39;DoW&#39;]] . date_subscribed DoW . 0 2018-01-01 | 0.0 | . 1 2018-01-01 | 0.0 | . 2 2018-01-01 | 0.0 | . 3 2018-01-01 | 0.0 | . 4 2018-01-01 | 0.0 | . ... ... | ... | . 10032 2018-01-17 | 2.0 | . 10033 2018-01-17 | 2.0 | . 10034 2018-01-17 | 2.0 | . 10035 2018-01-17 | 2.0 | . 10036 2018-01-17 | 2.0 | . 10037 rows × 2 columns . &#25506;&#32034;&#30340;&#12487;&#12540;&#12479;&#35299;&#26512;&#65288;EDA&#65289; . # date_served列をグループ化し、項目ごとにユニークなIDを数える daily_users = marketing.groupby([&#39;date_served&#39;])[&#39;user_id&#39;].nunique() # print head print(daily_users.head()) . date_served 1/1/18 362 1/10/18 337 1/11/18 310 1/12/18 301 1/13/18 306 Name: user_id, dtype: int64 . import matplotlib.pyplot as plt # Plot daily_subscribers daily_users.plot() # Include a title and y-axis label plt.title(&#39;Daily users&#39;) plt.ylabel(&#39;Number of users&#39;) # Rotate the x-axis labels by 45 degrees plt.xticks(rotation = 45) # Display the plot plt.show() . . このシリーズの別のポストを見るには . 　　　[Next &gt;&gt;] .",
            "url": "https://jaysung00.github.io/jays_blog/marketing%20%3E%20a.%20datacamp%20class/2021/02/02/Marketing-1.html",
            "relUrl": "/marketing%20%3E%20a.%20datacamp%20class/2021/02/02/Marketing-1.html",
            "date": " • Feb 2, 2021"
        }
        
    
  
    
        ,"post26": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jaysung00.github.io/jays_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jaysung00.github.io/jays_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jaysung00.github.io/jays_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}